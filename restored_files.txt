=== Object: ec4f9cd3ba5da110ac657467bd6a5adeb94ad4de | Date: 2025-09-23 19:05:08 | Type: blob ===

-----BEGIN PRIVATE KEY-----
MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCH0KEbBMA8VOm7
gtu6eyMrmchUIJgK1w/T6ZUKNKs/Vu7ImOFTbiq57v4nTaaPgXXB2iKIqJhlnDZv
cyaCZfp6hRdYgq8NEoRa4Y9d1Azg+oNJKg/K+vH5II4/HuUHB9+WxUxwfmbtVk8U
Icb6Pfx5BKs/nrCRQZCaRYbm9VXSs4ZdCV+9fQXpQCpNzhBEd/0y2b5EZ/atjJCn
rBTagmjjgLyWFp5pgmAphHZkEuOzbXh/z7votffeVNEz/ZSmrmDA1nq105pq9+Ef
59haHbbJM7opMxvmJUi9V/GUC/TEMHaUB/miO1t6TY13luD4fq03P+YQZgEUVIQ6
zJOrAvwXAgMBAAECggEAG0PGO9rRzqrLO1HzU3Xp4xRds4nRjAeNjWCsg158bFxC
1nFedrW8jRQN4I0FnXSDU9W7Lg0OfwODqA8JUY8wYA082Q9vHeQ0PtxeQBtUNIwF
9BemEP0cu4MOG1zT5HvvpmBYTpMJjabQfD2lqNHtz8ugp0ZvstFjOp0vjkj9IC2Q
M1iwh+w9A/rDhDQd1d3/6vgdGFzIzb6jUMnhf86Ahp94V7owEfusdZYJP+8hNVDw
6Euesw9tuPd3j8HInY0rZ6G5TmwAH/8BTBisCf2UzohRvcYtbBANNNVMyPTOVuNT
/wT4yAdrHi+cMBIJQ5XvUYj9UVQI+53l5Enxev0lNQKBgQC7TouGd31ipUidQ2QY
fPeUPHv++4LsdfkGFH7IVvX8gfFKMhCt4qRPuHgE7yxLBo83Sj969SssrB6v4jzC
f7sJ8+GTz1CTN6kv5Yyk2OdmucL/mi6IAbgh3dPhEaeyAGeOp9bKs6gU2og6j93D
axUfpwTV4hzC54v97Zbp/a1vqwKBgQC5n7qM7/Cn/9HF78rvttlE+axnuVNiI0Xi
DNCxPp5KBAaH5dPM0WWUvdwBau5Mi/E2VlmMJzriOg8gPC1exOBZTgn3bV6kANci
4Wn/FOCGrUgdS/oJj2yhh3zLayMyb4mwX3Fen6ZGGMGwCaTVaMTXpA1v2ZQLGDVu
ZMvGyaSpRQKBgH9dhZrGHci6Q4pMjP/p2iA+kMJuHDTWc6MixKNOHq65XW3qZVUY
TEq5UUNpr2DE8RXTsx7VH6qcz7Eh0dcgK/s0jyuHSW8R5kXffaeKpq8/mc1c9k8d
fCvrP2xIKRPtGn3yuyfSynSDtSa9NTrw0chYNf2KZ6xQ7uyYZopuKUVJAoGBAJAj
ci7CmrM5uODkxUbDS499+NxKUm9gSIGxxdP8ddmvqoqYcpEXALQxgccwC38xI8s3
3i0wwU6uGtTDJc/zPOrb6G1TZiwf4u7Y7v/+bCLoJ5loR+5oisgbd1JWDWy6o8Zr
NpNtkSXZT32s32xAAKoaX7y8zXKYB9WDO6FPLyepAoGAcXf6BqMSuZSlE/2PXqn+
l2aZJELGWgUlnBDBuZowWvPgXdxnSP1L89SActTqMblopCeqfTmXkrVt4T7kp8G4
j69mNm0JzaO2HqfnTUjD1w8+c16PExoFhlG/KveE9NhQuRcypIZ6oNLS40Hkdwtm
Hb09zFbhWjuYuPBLc09fkXU=
-----END PRIVATE KEY-----

---

=== Object: ea333aafd21896bff9f4f47ccb822c7fd6da027d | Date: 2025-09-23 19:05:08 | Type: blob ===

import { debugLog, errorLog } from "./utils";

type SimpleUser = any;
type SimpleUserOptions = any;
let Web: any = null;

export interface SipConfig {
  server: string;
  username: string;
  password: string;
  domain: string;
  websocket_port: number;
  use_secure: boolean;
  display_name?: string;
  debug?: boolean;
}

export interface CallInfo {
  id: string;
  remoteIdentity: string;
  displayName: string;
  state: "incoming" | "outgoing" | "connected" | "ended";
  startTime?: Date;
  duration: number;
}

export class SipManager extends EventTarget {
  private simpleUser: SimpleUser | null = null;
  private config: SipConfig | null = null;
  private isRegistered = false;
  private isConnected = false;
  private connectionTimer: number | null = null;
  private currentCall: CallInfo | null = null;
  private remoteAudio: HTMLAudioElement | null = null;
  private remoteVideo: HTMLVideoElement | null = null;
  private localVideo: HTMLVideoElement | null = null;
  private localStream: MediaStream | null = null;
  private videoEnabled = false;
  private isInitialized = false;
  private isInitializing = false;
  private lastVideoState = false;
  private isEnablingVideo = false; // Flag to prevent multiple simultaneous enableVideo calls

  constructor() {
    super();
    this.setupMediaElements();
  }

  private setupMediaElements(): void {
    this.remoteAudio = document.createElement("audio");
    this.remoteAudio.autoplay = true;
    this.remoteAudio.style.display = "none";
    document.body.appendChild(this.remoteAudio);

    this.remoteVideo = document.createElement("video");
    this.remoteVideo.autoplay = true;
    this.remoteVideo.playsInline = true;
    this.remoteVideo.style.display = "none";
    document.body.appendChild(this.remoteVideo);

    this.localVideo = document.createElement("video");
    this.localVideo.autoplay = true;
    this.localVideo.muted = true;
    this.localVideo.playsInline = true;
    this.localVideo.style.display = "none";
    document.body.appendChild(this.localVideo);
  }

  private async getUserMedia(includeVideo: boolean = false): Promise<MediaStream> {
    const constraints: MediaStreamConstraints = {
      audio: {
        echoCancellation: true,
        noiseSuppression: true,
        autoGainControl: true,
        sampleRate: 48000,
      },
      video: includeVideo
        ? {
            width: { ideal: 640, min: 320, max: 1280 },
            height: { ideal: 480, min: 240, max: 720 },
            frameRate: { ideal: 30, min: 15, max: 30 },
            facingMode: "user",
          }
        : false,
    };

    return navigator.mediaDevices.getUserMedia(constraints);
  }

  public async enableVideo(): Promise<void> {
    // Prevent multiple simultaneous enableVideo calls
    if (this.isEnablingVideo) {
      debugLog(this.config?.debug || false, "Video is already being enabled, ignoring duplicate request");
      return;
    }

    try {
      this.isEnablingVideo = true;
      
      const stream = await this.getUserMedia(true);

      if (this.localStream) {
        this.localStream.getTracks().forEach((track) => track.stop());
      }

      if (this.localVideo) {
        this.localVideo.srcObject = stream;
      }

      this.localStream = stream;
      this.videoEnabled = true;

      debugLog(this.config?.debug || false, "Local video enabled with new stream:", {
        videoTracks: stream.getVideoTracks().length,
        audioTracks: stream.getAudioTracks().length,
        streamId: stream.id,
      });

      if (this.simpleUser?.session && this.currentCall?.state === "connected") {
        await this.replaceMediaTracks(stream);
      }

      this.dispatchEvent(
        new CustomEvent("localVideoChanged", {
          detail: {
            enabled: true,
            transmitting: stream.getVideoTracks().some((track) => track.enabled && track.readyState === "live"),
          },
        })
      );
    } catch (error) {
      errorLog("Enable video failed", error);
      this.videoEnabled = false;
      throw error;
    } finally {
      this.isEnablingVideo = false;
    }
  }

  public async disableVideo(): Promise<void> {
    try {
      const audioOnlyStream = await this.getUserMedia(false);

      if (this.localVideo) {
        this.localVideo.srcObject = null;
      }

      if (this.localStream) {
        this.localStream.getTracks().forEach((track) => {
          track.stop();
          debugLog(this.config?.debug || false, `Stopped ${track.kind} track:`, track.id);
        });
      }

      this.localStream = audioOnlyStream;
      this.videoEnabled = false;

      debugLog(this.config?.debug || false, "Local video disabled, using audio-only stream:", {
        videoTracks: audioOnlyStream.getVideoTracks().length,
        audioTracks: audioOnlyStream.getAudioTracks().length,
        streamId: audioOnlyStream.id,
      });

      if (this.simpleUser?.session && this.currentCall?.state === "connected") {
        await this.replaceMediaTracks(audioOnlyStream);
      }

      this.dispatchEvent(
        new CustomEvent("localVideoChanged", {
          detail: {
            enabled: false,
            transmitting: false,
          },
        })
      );
    } catch (error) {
      errorLog("Disable video failed", error);
      throw error;
    }
  }

  private async replaceMediaTracks(newStream: MediaStream): Promise<void> {
    try {
      const session = this.simpleUser?.session;
      if (!session || !session.sessionDescriptionHandler) {
        debugLog(this.config?.debug || false, "No active session to replace tracks");
        return;
      }

      const pc = session.sessionDescriptionHandler.peerConnection;
      if (!pc) {
        debugLog(this.config?.debug || false, "No peer connection found");
        return;
      }

      const senders = pc.getSenders();

      const audioTrack = newStream.getAudioTracks()[0];
      const audioSender = senders.find((sender: any) => sender.track && sender.track.kind === "audio");
      if (audioSender && audioTrack) {
        await audioSender.replaceTrack(audioTrack);
        debugLog(this.config?.debug || false, "Audio track replaced successfully");
      }

      const videoTrack = newStream.getVideoTracks()[0] || null;
      const videoSender = senders.find((sender: any) => sender.track && sender.track.kind === "video");

      if (videoSender) {
        await videoSender.replaceTrack(videoTrack);
        debugLog(this.config?.debug || false, videoTrack ? "Video track replaced" : "Video track removed from sender");
      } else if (videoTrack) {
        try {
          pc.addTrack(videoTrack, newStream);
          debugLog(this.config?.debug || false, "Video track added to peer connection");

          if (session.sessionDescriptionHandler && typeof session.sessionDescriptionHandler.sendReinvite === "function") {
            await session.sessionDescriptionHandler.sendReinvite();
            debugLog(this.config?.debug || false, "Session renegotiated for new video track");
          }
        } catch (error) {
          debugLog(this.config?.debug || false, "Failed to add video track:", error);
        }
      }
    } catch (error) {
      debugLog(this.config?.debug || false, "Replace media tracks failed but call continues:", error);
    }
  }

  public async toggleVideo(): Promise<boolean> {
    try {
      if (this.videoEnabled) {
        await this.disableVideo();
        return false;
      } else {
        await this.enableVideo();
        return true;
      }
    } catch (error) {
      errorLog("Toggle video failed", error);
      throw error;
    }
  }

  public getLocalVideoState(): { enabled: boolean; transmitting: boolean } {
    return {
      enabled: this.videoEnabled,
      transmitting: this.localStream ? this.localStream.getVideoTracks().some((track) => track.enabled && track.readyState === "live") : false,
    };
  }

  private setupRemoteStreamHandlers(session: any): void {
    try {
      const sessionDescriptionHandler = session.sessionDescriptionHandler;
      if (!sessionDescriptionHandler) {
        debugLog(this.config?.debug || false, "No session description handler");
        return;
      }

      const pc = sessionDescriptionHandler.peerConnection;
      if (!pc) {
        debugLog(this.config?.debug || false, "No peer connection");
        return;
      }

      debugLog(this.config?.debug || false, "Setting up remote stream handlers for", pc.connectionState);

      pc.ontrack = (event: RTCTrackEvent) => {
        debugLog(this.config?.debug || false, "Remote track received:", {
          kind: event.track.kind,
          readyState: event.track.readyState,
          enabled: event.track.enabled,
          streams: event.streams.length,
          transceiver: event.transceiver.direction,
        });

        const stream = event.streams[0];
        if (!stream) {
          debugLog(this.config?.debug || false, "No stream in track event");
          return;
        }

        if (event.track.kind === "audio") {
          if (this.remoteAudio) {
            this.remoteAudio.srcObject = stream;
            debugLog(this.config?.debug || false, "Remote audio stream attached");
          }
        } else if (event.track.kind === "video") {
          if (this.remoteVideo) {
            this.remoteVideo.srcObject = stream;
            this.remoteVideo.autoplay = true;
            this.remoteVideo.playsInline = true;

            debugLog(this.config?.debug || false, "Remote video stream attached, playing...");

            // Handle video play with better error handling
            if (this.remoteVideo.srcObject) {
              const playPromise = this.remoteVideo.play();
              if (playPromise !== undefined) {
                playPromise
                  .then(() => {
                    debugLog(this.config?.debug || false, "Remote video playing successfully");
                  })
                  .catch((error) => {
                    debugLog(this.config?.debug || false, "Remote video play failed:", error);
                    
                    // Handle specific error types
                    if (error.name === "NotAllowedError") {
                      debugLog(this.config?.debug || false, "Video play not allowed, likely due to autoplay restrictions");
                      
                      // Try to handle autoplay restrictions by muting and retrying
                      if (this.remoteVideo) {
                        this.remoteVideo.muted = true;
                        const retryPromise = this.remoteVideo.play();
                        if (retryPromise !== undefined) {
                          retryPromise.catch((retryError) => {
                            debugLog(this.config?.debug || false, "Muted video play retry failed:", retryError);
                            
                            // Last resort: re-attach the stream
                            if (this.remoteVideo && this.remoteVideo.srcObject) {
                              const currentStream = this.remoteVideo.srcObject;
                              this.remoteVideo.srcObject = null;
                              this.remoteVideo.srcObject = currentStream;
                              setTimeout(() => {
                                if (this.remoteVideo && this.remoteVideo.srcObject) {
                                  this.remoteVideo.muted = true;
                                  const finalPromise = this.remoteVideo.play();
                                  if (finalPromise !== undefined) {
                                    finalPromise.catch((finalError) => {
                                      debugLog(this.config?.debug || false, "Final video play attempt failed:", finalError);
                                    });
                                  }
                                }
                              }, 100);
                            }
                          });
                        }
                      }
                                      } else if (error.name === "AbortError") {
                    debugLog(this.config?.debug || false, "Video play was interrupted, this is normal during stream updates");
                    
                    // Retry after a short delay, but be more careful about the timing
                    setTimeout(() => {
                      if (this.remoteVideo && this.remoteVideo.srcObject) {
                        // Check if the video element is in a playable state
                        if (this.remoteVideo.readyState >= 2) { // HAVE_CURRENT_DATA
                          const retryPromise = this.remoteVideo.play();
                          if (retryPromise !== undefined) {
                            retryPromise.catch((retryError) => {
                              debugLog(this.config?.debug || false, "Video play retry failed:", retryError);
                            });
                          }
                        } else {
                          // If not ready, wait a bit more
                          setTimeout(() => {
                            if (this.remoteVideo && this.remoteVideo.srcObject) {
                              const retryPromise = this.remoteVideo.play();
                              if (retryPromise !== undefined) {
                                retryPromise.catch((retryError) => {
                                  debugLog(this.config?.debug || false, "Delayed video play retry failed:", retryError);
                                });
                              }
                            }
                          }, 200);
                        }
                      }
                    }, 150);
                    } else {
                      // Try to handle other errors by re-attaching the stream
                      if (this.remoteVideo && this.remoteVideo.srcObject) {
                        const currentStream = this.remoteVideo.srcObject;
                        this.remoteVideo.srcObject = null;
                        this.remoteVideo.srcObject = currentStream;
                        setTimeout(() => {
                          if (this.remoteVideo && this.remoteVideo.srcObject) {
                            const retryPromise = this.remoteVideo.play();
                            if (retryPromise !== undefined) {
                              retryPromise.catch((retryError) => {
                                debugLog(this.config?.debug || false, "Remote video play retry failed:", retryError);
                              });
                            }
                          }
                        }, 100);
                      }
                    }
                  });
              }
            }

            const videoTracks = stream.getVideoTracks();
            const hasActiveVideo = videoTracks.length > 0 && videoTracks.some((track) => track.enabled);

            debugLog(this.config?.debug || false, "Video track details:", {
              trackCount: videoTracks.length,
              hasActive: hasActiveVideo,
              trackStates: videoTracks.map((t) => ({
                id: t.id,
                enabled: t.enabled,
                readyState: t.readyState,
                label: t.label,
              })),
            });

            this.lastVideoState = hasActiveVideo;

            this.dispatchEvent(
              new CustomEvent("remoteVideoChanged", {
                detail: {
                  enabled: true,
                  stream: stream,
                  hasVideoTracks: hasActiveVideo,
                },
              })
            );

            setTimeout(() => {
              this.dispatchEvent(
                new CustomEvent("remoteVideoChanged", {
                  detail: {
                    enabled: true,
                    stream: stream,
                    hasVideoTracks: hasActiveVideo,
                  },
                })
              );
            }, 200);
          }
        }
      };

      pc.oniceconnectionstatechange = () => {
        debugLog(this.config?.debug || false, "ICE connection state changed:", pc.iceConnectionState);

        if (pc.iceConnectionState === "failed") {
          errorLog("ICE connection failed - attempting to recover");
          this.handleIceConnectionFailure(pc);
        }
      };

      pc.onicegatheringstatechange = () => {
        debugLog(this.config?.debug || false, "ICE gathering state changed:", pc.iceGatheringState);
      };

      pc.onicecandidate = (event: RTCPeerConnectionIceEvent) => {
        if (event.candidate) {
          debugLog(this.config?.debug || false, "ICE candidate:", event.candidate.type, event.candidate.candidate);
        } else {
          debugLog(this.config?.debug || false, "ICE gathering complete");
        }
      };

      pc.onconnectionstatechange = () => {
        debugLog(this.config?.debug || false, "Connection state changed:", pc.connectionState);

        if (pc.connectionState === "failed") {
          errorLog("Peer connection failed completely");
          this.handleConnectionFailure();
        } else if (pc.connectionState === "connected") {
          setTimeout(() => {
            const transceivers = pc.getTransceivers();
            debugLog(this.config?.debug || false, "Checking transceivers:", transceivers.length);

            transceivers.forEach((transceiver: RTCRtpTransceiver, index: number) => {
              debugLog(this.config?.debug || false, `Transceiver ${index}:`, {
                direction: transceiver.direction,
                kind: transceiver.receiver?.track?.kind,
                trackState: transceiver.receiver?.track?.readyState,
                hasTrack: !!transceiver.receiver?.track,
              });

              if (transceiver.receiver?.track?.kind === "video" && transceiver.receiver.track.readyState === "live") {
                debugLog(this.config?.debug || false, "Found active video transceiver");

                let videoStream: MediaStream;
                if (this.remoteVideo?.srcObject instanceof MediaStream) {
                  videoStream = this.remoteVideo.srcObject;
                } else {
                  videoStream = new MediaStream([transceiver.receiver.track]);
                  if (this.remoteVideo) {
                    this.remoteVideo.srcObject = videoStream;
                  }
                }

                this.dispatchEvent(
                  new CustomEvent("remoteVideoChanged", {
                    detail: {
                      enabled: true,
                      stream: videoStream,
                      hasVideoTracks: true,
                    },
                  })
                );
              }
            });
          }, 500);
        }
      };

      pc.onremovetrack = (event: RTCTrackEvent) => {
        debugLog(this.config?.debug || false, "Remote track removed:", event.track.kind);

        if (event.track.kind === "video" && this.remoteVideo) {
          this.remoteVideo.srcObject = null;
          this.lastVideoState = false;

          this.dispatchEvent(
            new CustomEvent("remoteVideoChanged", {
              detail: {
                enabled: false,
                stream: null,
                hasVideoTracks: false,
              },
            })
          );
        }
      };
    } catch (error) {
      errorLog("Failed to setup remote stream handlers:", error);
    }
  }

  private handleIceConnectionFailure(pc: RTCPeerConnection): void {
    debugLog(this.config?.debug || false, "Attempting ICE restart");

    setTimeout(() => {
      if (pc.iceConnectionState === "failed") {
        try {
          pc.restartIce();
          debugLog(this.config?.debug || false, "ICE restart initiated");
        } catch (error) {
          errorLog("ICE restart failed:", error);
        }
      }
    }, 1000);
  }

  private handleConnectionFailure(): void {
    errorLog("Connection failed - notifying UI");

    this.dispatchEvent(
      new CustomEvent("error", {
        detail: {
          error: "Connection failed - check network and STUN servers",
          type: "connection_failure",
        },
      })
    );
  }

  private async waitForSipLibrary(timeout = 15000): Promise<void> {
    return new Promise<void>(async (resolve, reject) => {
      const startTime = Date.now();
      const timeoutId = setTimeout(() => {
        reject(new Error(`SIP.js library loading timeout after ${timeout}ms`));
      }, timeout);

      const checkLibrary = async () => {
        try {
          if (!Web) {
            const SIP = await import("sip.js");
            Web = (SIP as any).Web || SIP;
          }

          const isFullyLoaded =
            Web &&
            Web.SimpleUser &&
            Web.SimpleUser.prototype &&
            typeof Web.SimpleUser.prototype.register === "function" &&
            typeof Web.SimpleUser.prototype.connect === "function" &&
            typeof Web.SimpleUser.prototype.disconnect === "function";

          if (isFullyLoaded) {
            clearTimeout(timeoutId);
            debugLog(this.config?.debug || false, "SIP.js library fully loaded and verified");
            resolve();
            return;
          }

          if (Date.now() - startTime > timeout) {
            clearTimeout(timeoutId);
            reject(new Error("SIP.js library verification timeout"));
            return;
          }

          setTimeout(checkLibrary, 100);
        } catch (error) {
          setTimeout(checkLibrary, 200);
        }
      };

      checkLibrary();
    });
  }

  private async ensureSipClient(): Promise<void> {
    if (this.isInitialized) return;

    if (this.isInitializing) {
      return new Promise((resolve, reject) => {
        const checkInterval = setInterval(() => {
          if (this.isInitialized) {
            clearInterval(checkInterval);
            resolve();
          } else if (!this.isInitializing) {
            clearInterval(checkInterval);
            reject(new Error("Initialization failed"));
          }
        }, 100);
      });
    }

    if (!this.config) {
      throw new Error("SIP configuration not set");
    }

    await this.initialize(this.config);
  }

  setConfig(config: SipConfig): void {
    this.config = config;
    debugLog(config.debug || false, "SIP configuration set, will initialize on first use");
  }

  async initialize(config: SipConfig): Promise<void> {
    if (this.isInitializing || this.isInitialized) return;

    this.isInitializing = true;
    this.config = config;

    debugLog(config.debug || false, "Starting lazy SIP initialization");

    try {
      await this.waitForSipLibrary();
      await new Promise((resolve) => setTimeout(resolve, 500));

      const wsProtocol = config.use_secure ? "wss" : "ws";
      const wsPort = config.websocket_port || (config.use_secure ? 443 : 80);
      const wsServer = `${wsProtocol}://${config.server}:${wsPort}`;
      const sipAor = `sip:${config.username}@${config.domain}`;

      debugLog(config.debug || false, "WebSocket URL:", wsServer);
      debugLog(config.debug || false, "SIP AOR:", sipAor);

      const getMediaOptions = (includeVideo: boolean = false) => ({
        constraints: includeVideo
          ? {
              audio: {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true,
              },
              video: {
                width: { ideal: 640 },
                height: { ideal: 480 },
                frameRate: { ideal: 30 },
              },
            }
          : {
              audio: {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true,
              },
              video: false,
            },
        remote: {
          audio: this.remoteAudio!,
          video: this.remoteVideo!,
        },
      });

      const options: SimpleUserOptions = {
        aor: sipAor,
        media: getMediaOptions(false),
        userAgentOptions: {
          authorizationUsername: config.username,
          authorizationPassword: config.password,
          displayName: config.display_name || config.username,
          transportOptions: {
            server: wsServer,
            connectionTimeout: 15,
            maxReconnectionAttempts: 3,
            reconnectionTimeout: 4,
          },
          logLevel: config.debug ? "debug" : "error",
          sessionDescriptionHandlerFactoryOptions: {
            constraints: {
              audio: true,
              video: false,
            },
            peerConnectionConfiguration: {
              iceServers: [
                { urls: "stun:stun.l.google.com:19302" },
                { urls: "stun:stun1.l.google.com:19302" },
                { urls: "stun:stun2.l.google.com:19302" },
                { urls: "stun:stun3.l.google.com:19302" },
              ],
              iceCandidatePoolSize: 10,
              iceTransportPolicy: "all",
              bundlePolicy: "balanced",
              rtcpMuxPolicy: "require",
            },
          },
        },
      };

      if (!Web || !Web.SimpleUser) {
        throw new Error("SIP.js Web.SimpleUser not available after loading");
      }

      this.simpleUser = new Web.SimpleUser(wsServer, options);

      if (!this.simpleUser) {
        throw new Error("Failed to create SimpleUser instance");
      }

      if (!this.simpleUser.register || typeof this.simpleUser.register !== "function") {
        throw new Error("SimpleUser register method not available - library incomplete");
      }

      debugLog(config.debug || false, "SimpleUser created and verified successfully");

      this.setupEventHandlers();

      debugLog(config.debug || false, `Connecting to: ${wsServer}`);
      await this.simpleUser.connect();

      this.isConnected = true;
      this.dispatchEvent(new CustomEvent("connected"));
      debugLog(config.debug || false, "Connected to WebSocket server");

      debugLog(config.debug || false, "Registering with SIP server...");
      await this.simpleUser.register();

      this.isRegistered = true;
      this.dispatchEvent(new CustomEvent("registered", { detail: { registered: true } }));

      this.startConnectionMonitoring();

      this.isInitialized = true;
      this.isInitializing = false;

      debugLog(config.debug || false, "SIP client lazy initialization completed successfully");
    } catch (error) {
      this.isInitializing = false;
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      errorLog("SIP lazy initialization failed:", errorMessage);

      this.isConnected = false;
      this.isRegistered = false;

      if (this.simpleUser) {
        try {
          await this.simpleUser.disconnect();
        } catch (cleanupError) {
          debugLog(config.debug || false, "Cleanup error", cleanupError);
        }
        this.simpleUser = null;
      }

      this.dispatchEvent(
        new CustomEvent("error", {
          detail: {
            error: errorMessage,
            type: "initialization",
          },
        })
      );

      throw new Error(`Failed to initialize SIP client: ${errorMessage}`);
    }
  }

  private setupEventHandlers(): void {
    if (!this.simpleUser) {
      errorLog("Cannot setup event handlers: SimpleUser is null");
      return;
    }

    debugLog(this.config?.debug || false, "Setting up event handlers");

    this.simpleUser.delegate = {
      onCallCreated: () => {
        debugLog(this.config?.debug || false, "Call created");
        this.dispatchEvent(new CustomEvent("callCreated"));
      },

      onCallReceived: () => {
        debugLog(this.config?.debug || false, "Incoming call received");

        const session = this.simpleUser?.session;
        if (!session) {
          debugLog(this.config?.debug || false, "No session found for incoming call");
          return;
        }

        let remoteIdentity = "unknown";
        let displayName = "Unknown Caller";

        try {
          debugLog(this.config?.debug || false, "Current session state:", session.state);

          this.setupRemoteStreamHandlers(session);

          if (session.request) {
            const fromHeader = session.request.getHeader("From");
            debugLog(this.config?.debug || false, "From header:", fromHeader);

            if (fromHeader) {
              const uriMatches = fromHeader.match(/<sip:([^@]+)@/) || fromHeader.match(/sip:([^@]+)@/);
              if (uriMatches && uriMatches[1]) {
                remoteIdentity = uriMatches[1];
                debugLog(this.config?.debug || false, "Extracted extension from From:", remoteIdentity);
              }

              const nameMatches = fromHeader.match(/^"([^"]*)"/) || fromHeader.match(/^([^<]*)</);
              if (nameMatches && nameMatches[1] && nameMatches[1].trim()) {
                displayName = nameMatches[1].trim();
                debugLog(this.config?.debug || false, "Extracted display name:", displayName);
              } else if (remoteIdentity !== "unknown") {
                displayName = remoteIdentity;
              }
            }
          }

          if (remoteIdentity === "unknown" && session.remoteIdentity) {
            debugLog(this.config?.debug || false, "Trying session.remoteIdentity:", session.remoteIdentity);

            if (session.remoteIdentity.uri) {
              const uriString = session.remoteIdentity.uri.toString();
              debugLog(this.config?.debug || false, "Remote URI:", uriString);

              const matches = uriString.match(/sip:([^@]+)@/);
              if (matches && matches[1]) {
                remoteIdentity = matches[1];
                debugLog(this.config?.debug || false, "Extracted from remote URI:", remoteIdentity);
              }
            }

            if (session.remoteIdentity.displayName) {
              displayName = session.remoteIdentity.displayName;
              debugLog(this.config?.debug || false, "Remote display name:", displayName);
            } else if (remoteIdentity !== "unknown") {
              displayName = remoteIdentity;
            }
          }
        } catch (error) {
          debugLog(this.config?.debug || false, "Error parsing caller info:", error);
        }

        debugLog(this.config?.debug || false, "Final parsed caller info:", { remoteIdentity, displayName });

        this.currentCall = {
          id: Date.now().toString(),
          remoteIdentity: remoteIdentity,
          displayName: displayName,
          state: "incoming",
          duration: 0,
        };

        this.dispatchEvent(
          new CustomEvent("incomingCall", {
            detail: {
              from: remoteIdentity,
              displayName: displayName,
              callInfo: this.currentCall,
            },
          })
        );
      },

      onCallAnswered: () => {
        if (this.currentCall) {
          this.currentCall.state = "connected";
          this.currentCall.startTime = new Date();
        }

        debugLog(this.config?.debug || false, "Call answered");

        if (this.simpleUser?.session) {
          const session = this.simpleUser.session;
          this.setupRemoteStreamHandlers(session);

          // Set up session state change listener for incoming calls as well
          session.stateChange.addListener((newState: any) => {
            debugLog(this.config?.debug || false, "Incoming session state changed:", newState);

            switch (newState) {
              case "Terminated":
              case "Ended":
                debugLog(this.config?.debug || false, "Incoming call ended");
                // Stop local media tracks to release camera and microphone
                if (this.localStream) {
                  this.localStream.getTracks().forEach((track) => {
                    try {
                      track.stop();
                      debugLog(this.config?.debug || false, `Stopped local media track on incoming call end: ${track.kind}`);
                    } catch (error) {
                      debugLog(this.config?.debug || false, `Failed to stop track on incoming call end: ${track.kind}`, error);
                    }
                  });
                  this.localStream = null;
                }
                this.videoEnabled = false;
                
                if (this.currentCall) {
                  this.currentCall.state = "ended";
                  this.dispatchEvent(
                    new CustomEvent("callEnded", {
                      detail: { callInfo: this.currentCall },
                    })
                  );
                }
                break;
            }
          });

          // FIXED: Force remote video check for outgoing calls after answer
          setTimeout(() => {
            this.forceRemoteVideoCheck(session);
          }, 500);
        }

        this.dispatchEvent(
          new CustomEvent("callAnswered", {
            detail: { callInfo: this.currentCall },
          })
        );

        this.startCallTimer();
      },

      onCallHangup: () => {
        debugLog(this.config?.debug || false, "Call ended");

        // Stop local media tracks to release camera and microphone
        if (this.localStream) {
          this.localStream.getTracks().forEach((track) => {
            try {
              track.stop();
              debugLog(this.config?.debug || false, `Stopped local media track: ${track.kind}`);
            } catch (error) {
              debugLog(this.config?.debug || false, `Failed to stop track: ${track.kind}`, error);
            }
          });
          this.localStream = null;
        }

        if (this.remoteVideo) {
          this.remoteVideo.srcObject = null;
        }

        if (this.currentCall) {
          this.currentCall.state = "ended";
        }

        this.stopCallTimer();
        this.dispatchEvent(
          new CustomEvent("callEnded", {
            detail: { callInfo: this.currentCall },
          })
        );

        this.currentCall = null;
        this.lastVideoState = false;
        this.videoEnabled = false;
      },

      onCallHold: (held: boolean) => {
        debugLog(this.config?.debug || false, "Call hold state changed", held);
        this.dispatchEvent(
          new CustomEvent("callHold", {
            detail: { held, callInfo: this.currentCall },
          })
        );
      },

      onRegistered: () => {
        this.isRegistered = true;
        debugLog(this.config?.debug || false, "Registration successful");
        this.dispatchEvent(new CustomEvent("registered", { detail: { registered: true } }));
      },

      onUnregistered: () => {
        this.isRegistered = false;
        debugLog(this.config?.debug || false, "Unregistered");
        this.dispatchEvent(new CustomEvent("registered", { detail: { registered: false } }));
      },

      onServerConnect: () => {
        this.isConnected = true;
        debugLog(this.config?.debug || false, "Server connected");
        this.dispatchEvent(new CustomEvent("connected"));
      },

      onServerDisconnect: () => {
        this.isConnected = false;
        this.isRegistered = false;
        debugLog(this.config?.debug || false, "Server disconnected");
        this.dispatchEvent(new CustomEvent("disconnected"));
      },
    };
  }

  private callTimer: number | null = null;

  private startCallTimer(): void {
    this.stopCallTimer();
    this.callTimer = window.setInterval(() => {
      if (this.currentCall && this.currentCall.startTime) {
        this.currentCall.duration = Math.floor((Date.now() - this.currentCall.startTime.getTime()) / 1000);
        this.dispatchEvent(
          new CustomEvent("callTimer", {
            detail: { duration: this.currentCall.duration, callInfo: this.currentCall },
          })
        );
      }
    }, 1000);
  }

  private stopCallTimer(): void {
    if (this.callTimer) {
      clearInterval(this.callTimer);
      this.callTimer = null;
    }
  }

  private startConnectionMonitoring(): void {
    this.connectionTimer = window.setInterval(() => {
      const connected = this.simpleUser?.isConnected() || false;

      if (connected !== this.isConnected) {
        this.isConnected = connected;
        this.dispatchEvent(
          new CustomEvent("heartbeat", {
            detail: {
              connected,
              registered: this.isRegistered,
            },
          })
        );
      }
    }, 5000);
  }

  async makeCall(target: string, includeVideo = true): Promise<void> {
    await this.ensureSipClient();

    if (!this.simpleUser || !this.isRegistered) {
      throw new Error("SIP client not registered");
    }

    if (this.currentCall) {
      throw new Error("Another call is already in progress");
    }

    try {
      const targetUri = `sip:${target}@${this.config!.domain}`;
      debugLog(this.config?.debug || false, "Making VIDEO call to", targetUri, "with video:", includeVideo);

      if (!this.videoEnabled) {
        await this.enableVideo();
      }
      const mediaStream = this.localStream!;

      this.currentCall = {
        id: Date.now().toString(),
        remoteIdentity: target,
        displayName: target,
        state: "outgoing",
        duration: 0,
      };

      const callOptions = {
        sessionDescriptionHandlerOptions: {
          constraints: {
            audio: true,
            video: true,
          },
          offerToReceiveAudio: true,
          offerToReceiveVideo: true,

          iceGatheringTimeout: 10000,
          rtcConfiguration: {
            iceServers: [
              { urls: "stun:stun.l.google.com:19302" },
              { urls: "stun:stun1.l.google.com:19302" },
              { urls: "stun:stun2.l.google.com:19302" },
              { urls: "stun:stun3.l.google.com:19302" },
            ],
            iceCandidatePoolSize: 10,
            iceTransportPolicy: "all",
            bundlePolicy: "balanced",
            rtcpMuxPolicy: "require",
          },
        },
        sessionDescriptionHandlerFactory: (session: any, options: any) => {
          options.localStream = mediaStream;
          options.remote = {
            audio: this.remoteAudio,
            video: this.remoteVideo,
          };

          return session.sessionDescriptionHandlerFactory(session, options);
        },
      };

      await this.simpleUser.call(targetUri, callOptions);

      // FIXED: Enhanced outgoing call session handling
      if (this.simpleUser.session) {
        const session = this.simpleUser.session;
        debugLog(this.config?.debug || false, "Outgoing call session created, state:", session.state);

        // FIXED: Set up handlers immediately for outgoing calls
        this.setupRemoteStreamHandlers(session);

        // FIXED: Listen for all session state changes
        session.stateChange.addListener((newState: any) => {
          debugLog(this.config?.debug || false, "Outgoing session state changed:", newState);

          switch (newState) {
            case "Establishing":
              debugLog(this.config?.debug || false, "Call is establishing, setting up stream handlers");
              this.setupRemoteStreamHandlers(session);
              break;

            case "Established":
              debugLog(this.config?.debug || false, "Call established, ensuring stream handlers");
              setTimeout(() => {
                this.setupRemoteStreamHandlers(session);
                this.forceRemoteVideoCheck(session);
              }, 100);
              
              // Start the call timer when the call is established
              this.startCallTimer();
              break;

            case "Terminated":
            case "Ended":
              debugLog(this.config?.debug || false, "Outgoing call ended");
              // Stop local media tracks to release camera and microphone
              if (this.localStream) {
                this.localStream.getTracks().forEach((track) => {
                  try {
                    track.stop();
                    debugLog(this.config?.debug || false, `Stopped local media track on outgoing call end: ${track.kind}`);
                  } catch (error) {
                    debugLog(this.config?.debug || false, `Failed to stop track on outgoing call end: ${track.kind}`, error);
                  }
                });
                this.localStream = null;
              }
              this.videoEnabled = false;
              
              if (this.currentCall) {
                this.currentCall.state = "ended";
                this.dispatchEvent(
                  new CustomEvent("callEnded", {
                    detail: { callInfo: this.currentCall },
                  })
                );
              }
              break;
          }
        });

        // FIXED: Also listen for session description handler changes
        const checkForSDH = () => {
          if (session.sessionDescriptionHandler) {
            debugLog(this.config?.debug || false, "Session description handler available for outgoing call");
            this.setupRemoteStreamHandlers(session);
          } else {
            setTimeout(checkForSDH, 100);
          }
        };
        checkForSDH();
      }

      this.dispatchEvent(
        new CustomEvent("callStarted", {
          detail: {
            target,
            callInfo: this.currentCall,
            videoEnabled: true,
          },
        })
      );
    } catch (error) {
      errorLog("Call failed", error);
      
      // Stop local media tracks to release camera and microphone
      if (this.localStream) {
        this.localStream.getTracks().forEach((track) => {
          try {
            track.stop();
            debugLog(this.config?.debug || false, `Stopped local media track on call failure: ${track.kind}`);
          } catch (trackError) {
            debugLog(this.config?.debug || false, `Failed to stop track on call failure: ${track.kind}`, trackError);
          }
        });
        this.localStream = null;
      }
      
      this.currentCall = null;
      this.dispatchEvent(
        new CustomEvent("callFailed", {
          detail: {
            error: error instanceof Error ? error.message : "Call failed",
            target,
          },
        })
      );
      throw error;
    }
  }

  private forceRemoteVideoCheck(session: any): void {
    try {
      if (!session || !session.sessionDescriptionHandler) {
        debugLog(this.config?.debug || false, "No session description handler for video check");
        return;
      }

      const pc = session.sessionDescriptionHandler.peerConnection;
      if (!pc) {
        debugLog(this.config?.debug || false, "No peer connection for video check");
        return;
      }

      debugLog(this.config?.debug || false, "Forcing remote video check, connection state:", pc.connectionState);

      // Check for remote streams
      const remoteStreams = pc.getRemoteStreams ? pc.getRemoteStreams() : [];
      debugLog(this.config?.debug || false, "Remote streams found:", remoteStreams.length);

      if (remoteStreams.length > 0) {
        const remoteStream = remoteStreams[0];
        const videoTracks = remoteStream.getVideoTracks();

        debugLog(this.config?.debug || false, "Found remote stream with video tracks:", videoTracks.length);

        if (videoTracks.length > 0 && this.remoteVideo) {
          this.remoteVideo.srcObject = remoteStream;
          this.remoteVideo.autoplay = true;
          this.remoteVideo.playsInline = true;

          const playPromise = this.remoteVideo.play();
          if (playPromise !== undefined) {
            playPromise.catch((error) => {
              debugLog(this.config?.debug || false, "Remote video play failed:", error);
              // Try to handle the error by re-attaching the stream
              if (this.remoteVideo && this.remoteVideo.srcObject) {
                const currentStream = this.remoteVideo.srcObject;
                this.remoteVideo.srcObject = null;
                this.remoteVideo.srcObject = currentStream;
                setTimeout(() => {
                  if (this.remoteVideo && this.remoteVideo.srcObject) {
                    const retryPromise = this.remoteVideo.play();
                    if (retryPromise !== undefined) {
                      retryPromise.catch((retryError) => {
                        debugLog(this.config?.debug || false, "Remote video play retry failed:", retryError);
                      });
                    }
                  }
                }, 100);
              }
            });
          }

          const hasActiveVideo = videoTracks.some((track: any) => track.enabled && track.readyState === "live");

          this.dispatchEvent(
            new CustomEvent("remoteVideoChanged", {
              detail: {
                enabled: true,
                stream: remoteStream,
                hasVideoTracks: hasActiveVideo,
              },
            })
          );
        }
      }

      // Also check transceivers
      const transceivers = pc.getTransceivers();
      debugLog(this.config?.debug || false, "Checking transceivers for outgoing call:", transceivers.length);

      transceivers.forEach((transceiver: RTCRtpTransceiver, index: number) => {
        if (transceiver.receiver?.track?.kind === "video" && transceiver.receiver.track.readyState === "live") {
          debugLog(this.config?.debug || false, `Found active video transceiver ${index} for outgoing call`);

          if (this.remoteVideo && !this.remoteVideo.srcObject) {
            const videoStream = new MediaStream([transceiver.receiver.track]);
            this.remoteVideo.srcObject = videoStream;
            this.remoteVideo.autoplay = true;
            this.remoteVideo.playsInline = true;

            // Handle video play with better error handling
            if (this.remoteVideo.srcObject) {
              const playPromise = this.remoteVideo.play();
              if (playPromise !== undefined) {
                playPromise
                  .then(() => {
                    debugLog(this.config?.debug || false, "Transceiver video playing successfully");
                  })
                  .catch((error) => {
                    debugLog(this.config?.debug || false, "Transceiver video play failed:", error);
                    // Try to handle the error by re-attaching the stream
                    if (this.remoteVideo && this.remoteVideo.srcObject) {
                      const currentStream = this.remoteVideo.srcObject;
                      this.remoteVideo.srcObject = null;
                      this.remoteVideo.srcObject = currentStream;
                      // Add a small delay before retrying to avoid race conditions
                      setTimeout(() => {
                        if (this.remoteVideo && this.remoteVideo.srcObject) {
                          // Check if the video element is in a playable state
                          if (this.remoteVideo.readyState >= 2) { // HAVE_CURRENT_DATA
                            const retryPromise = this.remoteVideo.play();
                            if (retryPromise !== undefined) {
                              retryPromise.catch((retryError) => {
                                debugLog(this.config?.debug || false, "Transceiver video play retry failed:", retryError);
                              });
                            }
                          } else {
                            // If not ready, wait a bit more
                            setTimeout(() => {
                              if (this.remoteVideo && this.remoteVideo.srcObject) {
                                const retryPromise = this.remoteVideo.play();
                                if (retryPromise !== undefined) {
                                  retryPromise.catch((retryError) => {
                                    debugLog(this.config?.debug || false, "Delayed transceiver video play retry failed:", retryError);
                                  });
                                }
                              }
                            }, 200);
                          }
                        }
                      }, 150);
                    }
                  });
              }
            }

            this.dispatchEvent(
              new CustomEvent("remoteVideoChanged", {
                detail: {
                  enabled: true,
                  stream: videoStream,
                  hasVideoTracks: true,
                },
              })
            );
          }
        }
      });
    } catch (error) {
      debugLog(this.config?.debug || false, "Force remote video check failed:", error);
    }
  }

  async answerCall(): Promise<void> {
    await this.ensureSipClient();

    if (!this.simpleUser) {
      throw new Error("SIP client not available");
    }

    const session = this.simpleUser.session;
    if (!session) {
      throw new Error("No session available to answer");
    }

    if (!this.currentCall || this.currentCall.state !== "incoming") {
      throw new Error("No incoming call to answer");
    }

    const sessionState = session.state;
    debugLog(this.config?.debug || false, "Attempting to answer call, session state:", sessionState);

    if (sessionState === "Terminated" || sessionState === "Ended") {
      throw new Error("Call has already ended");
    }

    if (sessionState !== "Initial") {
      throw new Error(`Cannot answer call in state: ${sessionState}`);
    }

    try {
      if (!this.videoEnabled) {
        await this.enableVideo();
      }
      const mediaStream = this.localStream!;

      const answerOptions = {
        sessionDescriptionHandlerOptions: {
          constraints: {
            audio: true,
            video: true,
          },
          rtcConfiguration: {
            iceServers: [
              { urls: "stun:stun.l.google.com:19302" },
              { urls: "stun:stun1.l.google.com:19302" },
              { urls: "stun:stun2.l.google.com:19302" },
              { urls: "stun:stun3.l.google.com:19302" },
            ],
            iceCandidatePoolSize: 10,
            iceTransportPolicy: "all",
            bundlePolicy: "balanced",
            rtcpMuxPolicy: "require",
          },
        },
        sessionDescriptionHandlerFactory: (session: any, options: any) => {
          options.localStream = mediaStream;
          return session.sessionDescriptionHandlerFactory(session, options);
        },
      };

      await this.simpleUser.answer(answerOptions);
      debugLog(this.config?.debug || false, "Call answered with video:", this.videoEnabled);

      if (this.simpleUser.session) {
        this.setupRemoteStreamHandlers(this.simpleUser.session);
      }
    } catch (error) {
      errorLog("Answer call failed", error);
      // Stop any media tracks that might have been started during the failed attempt
      if (this.localStream) {
        this.localStream.getTracks().forEach((track) => {
          try {
            track.stop();
            debugLog(this.config?.debug || false, `Stopped local media track on answer failure: ${track.kind}`);
          } catch (trackError) {
            debugLog(this.config?.debug || false, `Failed to stop track on answer failure: ${track.kind}`, trackError);
          }
        });
        this.localStream = null;
      }
      throw error;
    }
  }

  async rejectCall(): Promise<void> {
    await this.ensureSipClient();

    if (!this.simpleUser) {
      throw new Error("SIP client not available");
    }

    try {
      await this.simpleUser.decline();

      if (this.currentCall) {
        this.currentCall.state = "ended";
      }

      this.currentCall = null;
      debugLog(this.config?.debug || false, "Call rejected");
    } catch (error) {
      errorLog("Reject call failed", error);
      throw error;
    }
  }

  async hangup(): Promise<void> {
    if (!this.simpleUser) return;

    try {
      await this.simpleUser.hangup();
      debugLog(this.config?.debug || false, "Call hung up");
    } catch (error) {
      errorLog("Hangup failed", error);
      throw error;
    }
  }

  async mute(): Promise<void> {
    if (!this.simpleUser) return;

    try {
      await this.simpleUser.mute();
      debugLog(this.config?.debug || false, "Call muted");
    } catch (error) {
      errorLog("Mute failed", error);
      throw error;
    }
  }

  async unmute(): Promise<void> {
    if (!this.simpleUser) return;

    try {
      await this.simpleUser.unmute();
      debugLog(this.config?.debug || false, "Call unmuted");
    } catch (error) {
      errorLog("Unmute failed", error);
      throw error;
    }
  }

  sendDTMF(tone: string): void {
    if (!this.simpleUser || !this.currentCall) return;

    try {
      if (typeof this.simpleUser.sendDTMF === "function") {
        this.simpleUser.sendDTMF(tone);
        debugLog(this.config?.debug || false, "DTMF sent", tone);

        this.dispatchEvent(
          new CustomEvent("dtmfSent", {
            detail: { tone, callInfo: this.currentCall },
          })
        );
      }
    } catch (error) {
      errorLog("DTMF send failed", error);
    }
  }

  getRemoteVideo(): HTMLVideoElement | null {
    return this.remoteVideo;
  }

  getRemoteAudio(): HTMLAudioElement | null {
    return this.remoteAudio;
  }

  getCurrentCall(): CallInfo | null {
    return this.currentCall;
  }

  getConnectionStatus(): { connected: boolean; registered: boolean; initialized: boolean } {
    return {
      connected: this.isConnected,
      registered: this.isRegistered,
      initialized: this.isInitialized,
    };
  }

  async connect(): Promise<void> {
    await this.ensureSipClient();
  }

  async disconnect(): Promise<void> {
    if (this.connectionTimer) {
      clearInterval(this.connectionTimer);
      this.connectionTimer = null;
    }

    this.stopCallTimer();

    if (this.simpleUser) {
      try {
        if (this.currentCall) {
          await this.hangup();
        }

        if (this.isRegistered) {
          await this.simpleUser.unregister();
        }

        if (this.isConnected) {
          await this.simpleUser.disconnect();
        }
      } catch (error) {
        errorLog("Disconnect error", error);
      }

      this.simpleUser = null;
    }

    try {
      if (this.localStream) {
        this.localStream.getTracks().forEach((track) => track.stop());
        this.localStream = null;
      }

      if (this.localVideo && this.localVideo.parentNode) {
        this.localVideo.pause();
        this.localVideo.srcObject = null;
        this.localVideo.parentNode.removeChild(this.localVideo);
        this.localVideo = null;
      }

      if (this.remoteVideo && this.remoteVideo.parentNode) {
        this.remoteVideo.pause();
        this.remoteVideo.srcObject = null;
        this.remoteVideo.parentNode.removeChild(this.remoteVideo);
        this.remoteVideo = null;
      }

      this.videoEnabled = false;

      if (this.remoteAudio && this.remoteAudio.parentNode) {
        this.remoteAudio.pause();
        this.remoteAudio.srcObject = null;
        this.remoteAudio.parentNode.removeChild(this.remoteAudio);
        this.remoteAudio = null;
      }
    } catch (error) {
      errorLog("Error cleaning up media resources:", error);
    }

    this.isConnected = false;
    this.isRegistered = false;
    this.isInitialized = false;
    this.isInitializing = false;
    this.currentCall = null;

    debugLog(this.config?.debug || false, "SIP client disconnected");
  }
}

---

=== Object: d753852faccec2ba5c7c4ca26b2c9fa9b4df42ef | Date: 2025-09-23 19:05:08 | Type: blob ===

import type { LovelaceCardConfig } from "custom-card-helpers";

export interface HomeAssistant {
  states: { [entity_id: string]: any };
  config: any;
  themes: any;
  panels: any;
  services: any;
  user?: any;
  callService(domain: string, service: string, serviceData?: any): Promise<any>;
}

export interface SIPCardConfig extends LovelaceCardConfig {
  type: string;
  title?: string;
  server_url: string;
  username: string;
  password: string;
  domain?: string;
  display_name?: string;
  stun_servers?: string[];
  turn_servers?: TURNServer[];
  auto_answer?: boolean;
  video_enabled?: boolean;
  dtmf_enabled?: boolean;
  call_history_enabled?: boolean;
  theme?: "auto" | "light" | "dark";
  contacts: SIPContact[];
  hide_keypad?: boolean;
  websocket_port?: number;
  [key: string]: unknown;
  hide_video_controls?: boolean;
  ring_timeout?: number;
  debug?: boolean;
}

export interface TURNServer {
  urls: string[];
  username: string;
  credential: string;
}

export interface SIPContact {
  name: string;
  extension: string;
  id?: string;
  icon?: string;
  video_enabled?: boolean;
}

export interface CallState {
  active: boolean;
  incoming: boolean;
  outgoing: boolean;
  onHold: boolean;
  muted: boolean;
  videoEnabled: boolean;
  remoteVideoEnabled: boolean;
  localVideoTransmitting: boolean;
  callerId?: string;
  callerName?: string;
  duration: number;
  status: "idle" | "connecting" | "ringing" | "answered" | "held" | "ended" | "error";
}

export interface ConnectionState {
  registered: boolean;
  connecting: boolean;
  error?: string;
  lastConnected?: Date;
  registrationExpires?: Date;
}

---

=== Object: d403a194b02a1637f273718d6be2b6f28130d1da | Date: 2025-09-23 19:05:08 | Type: blob ===

services:
  # Development environment
  dev:
    build:
      context: .
      target: development
    volumes:
      - .:/workspace
      - /workspace/node_modules
      - ./dist:/workspace/dist
    ports:
      - "3000:3000" # Vite dev server
      - "24678:24678" # Vite HMR
    environment:
      - NODE_ENV=development
      - CHOKIDAR_USEPOLLING=true
    command: npm run dev
    stdin_open: true
    tty: true

  # Production build
  build:
    build:
      context: .
      target: build
    volumes:
      - ./dist:/app/dist
    command: npm run build

  # Home Assistant test environment
  homeassistant:
    image: homeassistant/home-assistant:dev
    container_name: ha-webrtc-test
    volumes:
      - ./local-mount/ha-config:/config
      - ./dist:/config/www/community/ha-webrtc-sip-card
      - /etc/localtime:/etc/localtime:ro
      - ./config/ha-config/configuration.yaml:/config/configuration.yaml
      - ./config/ha-config/ui-lovelace.yaml:/config/ui-lovelace.yaml
    ports:
      - "8123:8123"
    restart: unless-stopped
    environment:
      - TZ=Africa/Kigali
    depends_on:
      - build
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8123"]
      interval: 30s
      timeout: 10s
      retries: 3

  nginx:
    container_name: ha-nginx
    image: nginx:alpine
    volumes:
      - ./config/nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./config/ssl:/etc/ssl:ro
    ports:
      - "443:443"
      - "80:80"
    restart: unless-stopped
    depends_on:
      - homeassistant

networks:
  default:
    name: ha-webrtc-network

---

=== Object: c8225a70fdd478a1c887f6ce68931df05209e6d5 | Date: 2025-09-23 19:05:08 | Type: blob ===

import type { SIPCardConfig, SIPContact } from "./types";
import { DEFAULT_CONFIG } from "./constants";

export function mergeConfig(userConfig: Partial<SIPCardConfig>): SIPCardConfig {
  return {
    ...DEFAULT_CONFIG,
    ...userConfig,
    contacts: userConfig.contacts || DEFAULT_CONFIG.contacts,
    stun_servers: userConfig.stun_servers || DEFAULT_CONFIG.stun_servers,
    turn_servers: userConfig.turn_servers || DEFAULT_CONFIG.turn_servers,
  };
}

export function validateConfig(config: SIPCardConfig): void {
  if (!config.server_url) {
    throw new Error("server_url is required");
  }
  if (!config.username) {
    throw new Error("username is required");
  }
  if (!config.password) {
    throw new Error("password is required");
  }

  // Validate WebSocket URL
  try {
    const url = new URL(config.server_url);
    if (!["ws:", "wss:"].includes(url.protocol)) {
      throw new Error("server_url must use ws:// or wss:// protocol");
    }
  } catch (error) {
    throw new Error("Invalid server_url format");
  }
}

export function formatDuration(seconds: number): string {
  const mins = Math.floor(seconds / 60);
  const secs = seconds % 60;
  return `${mins.toString().padStart(2, "0")}:${secs.toString().padStart(2, "0")}`;
}

export function formatPhoneNumber(number: string): string {
  // Simple formatting - can be enhanced based on requirements
  const cleaned = number.replace(/\D/g, "");
  if (cleaned.length === 10) {
    return `(${cleaned.slice(0, 3)}) ${cleaned.slice(3, 6)}-${cleaned.slice(6)}`;
  }
  return number;
}

export function playRingtone(): HTMLAudioElement | null {
  try {
    const audio = new Audio();
    audio.src =
      "data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBQ==";
    audio.loop = true;
    const playPromise = audio.play();
    if (playPromise !== undefined) {
      playPromise.catch(() => {
        // Ignore autoplay policy errors
      });
    }
    return audio;
  } catch (error) {
    console.warn("Failed to play ringtone:", error);
    return null;
  }
}

export function stopRingtone(audio: HTMLAudioElement | null): void {
  if (audio) {
    audio.pause();
    audio.currentTime = 0;
  }
}

export function getContactByExtension(contacts: SIPContact[], extension: string): SIPContact | undefined {
  return contacts.find((contact) => contact.extension === extension);
}

export function sanitizeExtension(extension: string): string {
  return extension.replace(/[^\d*#+]/g, "");
}

export function debugLog(debug: boolean, message: string, ...args: any[]): void {
  if (debug) {
    console.log(`[WebRTC SIP Card] ${message}`, ...args);
  }
}

export function errorLog(message: string, error?: any): void {
  console.error(`[WebRTC SIP Card] ${message}`, error);
}

---

=== Object: 9b43dde56f05001927d3083a1589a731466c6359 | Date: 2025-09-23 19:05:08 | Type: blob ===

import type { CallInfo } from "./sip-manager";
import { SipManager } from "./sip-manager";
import { formatDuration, playRingtone, stopRingtone, getContactByExtension } from "./utils";
import type { SIPContact } from "./types";

export interface CallState {
  active: boolean;
  incoming: boolean;
  outgoing: boolean;
  onHold: boolean;
  muted: boolean;
  remoteVideoEnabled: boolean;
  localVideoTransmitting: boolean;
  callerId?: string;
  callerName?: string;
  duration: number;
  status: "idle" | "connecting" | "ringing" | "answered" | "held" | "ended" | "error";
}

export class CallManager extends EventTarget {
  private sipManager: SipManager;
  private callState: CallState;
  private ringtone: HTMLAudioElement | null = null;
  private ringTimeout: number | null = null;
  private contacts: SIPContact[] = [];
  private isAnsweringCall = false; // Flag to prevent multiple simultaneous answer calls

  constructor(sipManager: SipManager, contacts: SIPContact[] = []) {
    super();
    this.sipManager = sipManager;
    this.contacts = contacts;
    this.callState = this.getInitialState();
    this.setupSipEventHandlers();
  }

  public updateContacts(contacts: SIPContact[]): void {
    this.contacts = contacts;
  }

  private getInitialState(): CallState {
    return {
      active: false,
      incoming: false,
      outgoing: false,
      onHold: false,
      muted: false,
      remoteVideoEnabled: false,
      localVideoTransmitting: false,
      duration: 0,
      status: "idle",
    };
  }

  private setupSipEventHandlers(): void {
    this.sipManager.addEventListener("incomingCall", this.handleIncomingCall.bind(this) as EventListener);
    this.sipManager.addEventListener("callStarted", this.handleCallStarted.bind(this) as EventListener);
    this.sipManager.addEventListener("callAnswered", this.handleCallAnswered.bind(this) as EventListener);
    this.sipManager.addEventListener("callEnded", this.handleCallEnded.bind(this) as EventListener);
    this.sipManager.addEventListener("callFailed", this.handleCallFailed.bind(this) as EventListener);
    this.sipManager.addEventListener("localVideoChanged", this.handleLocalVideoChanged.bind(this) as EventListener);
    this.sipManager.addEventListener("remoteVideoChanged", this.handleRemoteVideoChanged.bind(this) as EventListener);
    this.sipManager.addEventListener("callTimer", this.handleCallTimer.bind(this) as EventListener);
    this.sipManager.addEventListener("callHold", this.handleCallHold.bind(this) as EventListener);
  }

  private cleanExtension(rawExtension: string): string {
    if (!rawExtension || rawExtension === "unknown") return rawExtension;

    let cleaned = rawExtension.replace(/^Extension\s+/i, "");
    cleaned = cleaned.replace(/-screen$|-web$|-mobile$|-phone$/i, "");

    const numericMatch = cleaned.match(/(\d+)/);
    if (numericMatch) {
      return numericMatch[1];
    }

    return cleaned;
  }

  private cleanDisplayName(displayName: string, extension: string): string {
    if (!displayName || displayName === "unknown" || displayName === "Unknown Caller") {
      return extension;
    }

    let cleaned = displayName.replace(/^Extension\s+/i, "");
    cleaned = cleaned.replace(new RegExp(`\\b${extension}\\b`, "g"), "").trim();

    if (!cleaned || cleaned === extension) {
      return extension;
    }

    return cleaned;
  }

  private handleIncomingCall(event: CustomEvent): void {
    const { from, displayName, callInfo } = event.detail;

    const cleanedExtension = this.cleanExtension(from);
    const cleanedDisplayName = this.cleanDisplayName(displayName, cleanedExtension);
    const contact = this.contacts ? getContactByExtension(this.contacts, cleanedExtension) : null;
    const finalCallerName = contact ? contact.name : cleanedDisplayName;

    this.callState = {
      ...this.callState,
      active: true,
      incoming: true,
      outgoing: false,
      callerId: cleanedExtension,
      callerName: finalCallerName,
      status: "ringing",
      duration: 0,
    };

    this.ringtone = playRingtone();

    this.ringTimeout = window.setTimeout(() => {
      if (this.callState.status === "ringing" && this.callState.incoming) {
        this.rejectCall().catch((error) => {
          console.error("Auto-reject failed:", error);
          this.forceCallCleanup();
        });
      }
    }, 30000);

    this.dispatchCallStateUpdate();
  }

  private forceCallCleanup(): void {
    this.stopRinging();
    this.clearRingTimeout();

    // Ensure media tracks are stopped when force cleaning up
    try {
      // The SIP manager should handle this, but we'll make sure
      console.log("Force call cleanup, ensuring media tracks are stopped");
    } catch (error) {
      console.error("Error during force call cleanup:", error);
    }

    this.callState = this.getInitialState();
    this.callState.status = "ended";

    this.dispatchCallStateUpdate();

    setTimeout(() => {
      this.callState.status = "idle";
      this.dispatchCallStateUpdate();
    }, 1000);
  }

  private handleCallStarted(event: CustomEvent): void {
    const { target } = event.detail;

    const cleanedExtension = this.cleanExtension(target);
    const contact = this.contacts ? getContactByExtension(this.contacts, cleanedExtension) : null;
    const finalCallerName = contact ? contact.name : cleanedExtension;

    this.callState = {
      ...this.callState,
      active: true,
      incoming: false,
      outgoing: true,
      callerId: cleanedExtension,
      callerName: finalCallerName,
      status: "connecting",
      duration: 0,
    };

    this.dispatchCallStateUpdate();
  }

  private handleCallAnswered(_event: CustomEvent): void {
    this.stopRinging();
    this.clearRingTimeout();

    this.callState = {
      ...this.callState,
      status: "answered",
      incoming: false,
      outgoing: false,
      duration: 0,
    };

    // FIXED: Update local video state immediately
    const videoState = this.sipManager.getLocalVideoState();
    this.callState.localVideoTransmitting = videoState.transmitting;

    // Check if remote video is available
    setTimeout(() => {
      const remoteVideo = this.sipManager.getRemoteVideo();
      if (remoteVideo && remoteVideo.srcObject) {
        const stream = remoteVideo.srcObject as MediaStream;
        const videoTracks = stream.getVideoTracks();
        this.callState.remoteVideoEnabled = videoTracks.length > 0 && videoTracks.some((track) => track.enabled);
        console.log("Remote video detected in call answered:", {
          videoTracks: videoTracks.length,
          enabled: this.callState.remoteVideoEnabled,
        });
        this.dispatchCallStateUpdate();
      }
    }, 500);

    this.dispatchCallStateUpdate();
  }

  private handleCallEnded(_event: CustomEvent): void {
    this.stopRinging();
    this.clearRingTimeout();

    this.callState = this.getInitialState();
    this.callState.status = "ended";

    this.dispatchCallStateUpdate();

    setTimeout(() => {
      this.callState.status = "idle";
      this.dispatchCallStateUpdate();
    }, 2000);
  }

  private handleCallFailed(_event: CustomEvent): void {
    this.stopRinging();
    this.clearRingTimeout();

    // Ensure media tracks are stopped
    try {
      // The SIP manager should handle this, but we'll make sure
      console.log("Call failed, ensuring media tracks are stopped");
    } catch (error) {
      console.error("Error during call failure cleanup:", error);
    }

    this.callState = this.getInitialState();
    this.callState.status = "error";

    this.dispatchCallStateUpdate();
  }

  private handleCallTimer(event: CustomEvent): void {
    const { duration } = event.detail;
    this.callState.duration = duration;
    this.dispatchCallStateUpdate();
    
    // Dispatch formatted duration for UI updates
    this.dispatchEvent(
      new CustomEvent("callTimerUpdate", {
        detail: { 
          duration,
          formattedDuration: formatDuration(duration)
        }
      })
    );
  }

  private handleCallHold(event: CustomEvent): void {
    const { held } = event.detail;
    this.callState.onHold = held;
    this.callState.status = held ? "held" : "answered";
    this.dispatchCallStateUpdate();
  }

  private handleLocalVideoChanged(event: CustomEvent): void {
    const { transmitting } = event.detail;
    this.callState.localVideoTransmitting = transmitting;
    this.dispatchCallStateUpdate();
  }

  private handleRemoteVideoChanged(event: CustomEvent): void {
    const { enabled } = event.detail;
    this.callState.remoteVideoEnabled = enabled;
    this.dispatchCallStateUpdate();
  }

  public async toggleVideo(): Promise<boolean> {
    try {
      const enabled = await this.sipManager.toggleVideo();
      return enabled;
    } catch (error) {
      console.error("Failed to toggle video:", error);
      throw error;
    }
  }

  public async enableVideo(): Promise<void> {
    try {
      await this.sipManager.enableVideo();
      console.log("Video enabled successfully");
    } catch (error) {
      console.error("Failed to enable video:", error);
      throw error;
    }
  }

  public async disableVideo(): Promise<void> {
    try {
      await this.sipManager.disableVideo();
    } catch (error) {
      console.error("Failed to disable video:", error);
      throw error;
    }
  }

  private stopRinging(): void {
    if (this.ringtone) {
      stopRingtone(this.ringtone);
      this.ringtone = null;
    }
  }

  private clearRingTimeout(): void {
    if (this.ringTimeout) {
      clearTimeout(this.ringTimeout);
      this.ringTimeout = null;
    }
  }

  private dispatchCallStateUpdate(): void {
    this.dispatchEvent(
      new CustomEvent("callStateChanged", {
        detail: { callState: { ...this.callState } },
      })
    );
  }

  async makeCall(target: string, includeVideo?: boolean): Promise<void> {
    try {
      await this.sipManager.makeCall(target, includeVideo);
    } catch (error) {
      this.callState.status = "error";
      this.dispatchCallStateUpdate();
      throw error;
    }
  }

  // FIXED: Enhanced answerCall to properly handle video
  async answerCall(withVideo = false): Promise<void> {
    // Prevent multiple simultaneous answer calls
    if (this.isAnsweringCall) {
      console.warn("Call is already being answered, ignoring duplicate request");
      return;
    }

    try {
      this.isAnsweringCall = true;
      
      if (withVideo) {
        console.log("Answering with video - enabling video first");
        await this.sipManager.enableVideo();
      }

      await this.sipManager.answerCall();
      console.log(`Call answered ${withVideo ? "with" : "without"} video`);
    } catch (error) {
      console.error("Failed to answer call:", error);
      this.callState.status = "error";
      this.dispatchCallStateUpdate();
      throw error;
    } finally {
      this.isAnsweringCall = false;
    }
  }

  async rejectCall(): Promise<void> {
    this.stopRinging();
    this.clearRingTimeout();

    try {
      if (this.sipManager && (this.callState.status === "ringing" || this.callState.incoming)) {
        await this.sipManager.rejectCall();
      } else {
        console.warn("Cannot reject call - invalid state:", this.callState.status);
        this.forceCallCleanup();
        return;
      }
    } catch (error) {
      console.error("Reject call failed:", error);
      this.forceCallCleanup();
      throw error;
    }
  }

  async hangupCall(): Promise<void> {
    try {
      await this.sipManager.hangup();
    } catch (error) {
      this.callState = this.getInitialState();
      this.dispatchCallStateUpdate();
      throw error;
    }
  }

  async toggleMute(): Promise<boolean> {
    try {
      if (this.callState.muted) {
        await this.sipManager.unmute();
        this.callState.muted = false;
      } else {
        await this.sipManager.mute();
        this.callState.muted = true;
      }

      this.dispatchCallStateUpdate();
      return this.callState.muted;
    } catch (error) {
      throw error;
    }
  }

  sendDTMF(tone: string): void {
    if (this.callState.active && this.callState.status === "answered") {
      this.sipManager.sendDTMF(tone);
    }
  }

  getCallState(): CallState {
    return { ...this.callState };
  }

  getRemoteVideo(): HTMLVideoElement | null {
    return this.sipManager.getRemoteVideo();
  }

  getCurrentCall(): CallInfo | null {
    return this.sipManager.getCurrentCall();
  }

  getFormattedDuration(): string {
    return formatDuration(this.callState.duration);
  }
}

---

=== Object: 8c651b0790a72dc26bcf3ac939691b1896e95b83 | Date: 2025-09-23 19:05:08 | Type: blob ===

title: Development Dashboard
views:
  - path: default_view
    title: Test Cards
    cards:
      - type: custom:ha-webrtc-sip-card
---

=== Object: 77112136d869f4e2759db6a7d6407cdeeef974a5 | Date: 2025-09-23 19:05:08 | Type: blob ===

events {
    worker_connections 1024;
}

http {
    upstream homeassistant {
        server homeassistant:8123;
    }
    
    server {
        listen 80;
        server_name _;
        return 301 https://$host$request_uri;
    }

    server {
        listen 443 ssl;
        server_name _;
        
        ssl_certificate /etc/ssl/homeassistant.crt;
        ssl_certificate_key /etc/ssl/homeassistant.key;
        ssl_protocols TLSv1.2 TLSv1.3;
        
        # WebSocket specific configurations
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        location / {
            proxy_pass http://homeassistant;
            proxy_redirect off;
        }
        
        # WebRTC/WebSocket endpoint for Home Assistant
        location /api/websocket {
            proxy_pass http://homeassistant;
            proxy_read_timeout 300s;
            proxy_send_timeout 300s;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
        }
        
        # Static files
        location /local/ {
            proxy_pass http://homeassistant;
            proxy_redirect off;
        }
    }
}

---

=== Object: 703d9f10fa11fdf366fd2bbde87c97b507b6b0c2 | Date: 2025-09-23 19:05:08 | Type: blob ===

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

# Local mount
local-mount/
---

=== Object: 676d8aadc36aeb751e2d5d13f5bd64a991cf1e01 | Date: 2025-09-23 19:05:08 | Type: blob ===

lovelace:
      # Available modes:
      # - yaml: Use the UI editor in YAML mode
      # - storage: Use the UI editor in storage mode
      # - auto: Use the UI editor in YAML mode if a YAML file is found, otherwise use storage mode
      # - disabled: Disable the UI editor
      mode: storage
      dashboards:
        lovelace-main:
          mode: yaml
          filename: ui-lovelace.yaml
          title: Main Dashboard
          icon: mdi:home
          show_in_sidebar: true

# Basic configuration
homeassistant:
  name: Development
  latitude: 0
  longitude: 0
  elevation: 0
  unit_system: metric
  time_zone: Africa/Kigali

# Enable frontend development tools
frontend:
  themes: !include_dir_merge_named themes
  extra_module_url:
    - /local/community/ha-webrtc-sip-card/ha-webrtc-sip-card.js
    - /local/community/ha-webrtc-sip-card/ha-webrtc-sip-card-editor.js

http:
  use_x_forwarded_for: true
  trusted_proxies:
    - 172.16.0.0/12    # Docker network range
    - 172.17.0.0/16    # Docker bridge network
    - 172.18.0.0/16    # Docker compose network


# Enable configuration UI
config:

# Enable system health
system_health:

# Enable Home Assistant iOS app support
mobile_app:

# Enable energy dashboard
energy:

# Demo entities for testing
demo:

---

=== Object: 4715d03c5c00e6808e4fa63e1a2f2526fe77877e | Date: 2025-09-23 19:05:08 | Type: blob ===

{
  "name": "ha-webrtc-sip-card",
  "version": "1.0.0",
  "description": "A modern WebRTC SIP client card for Home Assistant",
  "main": "dist/ha-webrtc-sip-card.js",
  "scripts": {
    "dev": "vite --host 0.0.0.0 --port 3000",
    "build": "vite build",
    "preview": "vite preview",
    "lint": "eslint src --ext .ts",
    "type-check": "tsc --noEmit",
    "serve": "vite build && vite preview"
  },
  "keywords": [
    "home-assistant",
    "custom-card",
    "webrtc",
    "sip",
    "voip",
    "hacs"
  ],
  "author": "Ahmed Waleed",
  "license": "MIT",
  "devDependencies": {
    "@types/node": "^24.5.2",
    "@typescript-eslint/eslint-plugin": "^6.21.0",
    "@typescript-eslint/parser": "^6.21.0",
    "eslint": "^8.57.0",
    "typescript": "^5.4.3",
    "vite": "^5.2.8"
  },
  "dependencies": {
    "custom-card-helpers": "^1.9.0",
    "lit": "^3.1.2",
    "sip.js": "^0.21.2"
  }
}

---

=== Object: 2634cf9204db9290f50a7af2ca32bee1fe2671bb | Date: 2025-09-23 19:05:08 | Type: blob ===

import { LitElement, html, css, type CSSResultGroup, type TemplateResult } from "lit";
import { customElement, property, state } from "lit/decorators.js";
import type { HomeAssistant, SIPCardConfig, SIPContact } from "./types";
import { mergeConfig } from "./utils";

@customElement("ha-webrtc-sip-card-editor")
export class WebRTCSipCardEditor extends LitElement {
  @property({ attribute: false }) public hass!: HomeAssistant;
  @property({ attribute: false }) public lovelace?: any;
  @state() private config!: SIPCardConfig;
  @state() private selectedTab: "connection" | "contacts" | "advanced" = "connection";
  @state() private editingContact: SIPContact | null = null;
  @state() private showAddContact = false;

  public setConfig(config: SIPCardConfig): void {
    this.config = mergeConfig(config);
  }

  protected render(): TemplateResult {
    if (!this.config) {
      return html`<div>Loading...</div>`;
    }

    return html` <div class="card-config">${this.renderHeader()} ${this.renderTabs()} ${this.renderTabContent()} ${this.renderContactDialog()}</div> `;
  }

  private renderHeader(): TemplateResult {
    return html`
      <div class="config-header">
        <h2>WebRTC SIP Card Configuration</h2>
        <p>Configure your SIP server connection and manage contacts</p>
      </div>
    `;
  }

  private renderTabs(): TemplateResult {
    return html`
      <div class="config-tabs">
        <button class="tab ${this.selectedTab === "connection" ? "active" : ""}" @click=${() => (this.selectedTab = "connection")}>
          <ha-icon icon="mdi:server-network"></ha-icon>
          Connection
        </button>
        <button class="tab ${this.selectedTab === "contacts" ? "active" : ""}" @click=${() => (this.selectedTab = "contacts")}>
          <ha-icon icon="mdi:contacts"></ha-icon>
          Contacts
        </button>
        <button class="tab ${this.selectedTab === "advanced" ? "active" : ""}" @click=${() => (this.selectedTab = "advanced")}>
          <ha-icon icon="mdi:cog"></ha-icon>
          Advanced
        </button>
      </div>
    `;
  }

  private renderTabContent(): TemplateResult {
    switch (this.selectedTab) {
      case "connection":
        return this.renderConnectionTab();
      case "contacts":
        return this.renderContactsTab();
      case "advanced":
        return this.renderAdvancedTab();
      default:
        return html``;
    }
  }

  private renderConnectionTab(): TemplateResult {
    return html`
      <div class="tab-content">
        <div class="config-section">
          <h3>Server Configuration</h3>

          <ha-textfield
            label="Card Title"
            .value=${this.config.title || ""}
            .configValue=${"title"}
            @input=${this._valueChanged}
            helper="Display name for this card"
          ></ha-textfield>

          <ha-textfield
            label="SIP Server URL *"
            .value=${this.config.server_url || ""}
            .configValue=${"server_url"}
            @input=${this._valueChanged}
            placeholder="wss://sip.example.com"
            helper="WebSocket URL (ws:// or wss://)"
            required
          ></ha-textfield>

          <ha-textfield
            label="WebSocket Port"
            .value=${this.config.websocket_port || ""}
            .configValue=${"websocket_port"}
            @input=${this._valueChanged}
            placeholder="443"
            type="number"
            helper="WebSocket port (default: 443 for wss, 80 for ws)"
          ></ha-textfield>

          <ha-textfield
            label="SIP Domain"
            .value=${this.config.domain || ""}
            .configValue=${"domain"}
            @input=${this._valueChanged}
            placeholder="example.com"
            helper="SIP domain (defaults to server hostname)"
          ></ha-textfield>
        </div>

        <div class="config-section">
          <h3>Authentication</h3>

          <ha-textfield
            label="Username *"
            .value=${this.config.username || ""}
            .configValue=${"username"}
            @input=${this._valueChanged}
            placeholder="1001"
            required
          ></ha-textfield>

          <ha-textfield
            label="Password *"
            .value=${this.config.password || ""}
            .configValue=${"password"}
            @input=${this._valueChanged}
            type="password"
            placeholder=""
            required
          ></ha-textfield>

          <ha-textfield
            label="Display Name"
            .value=${this.config.display_name || ""}
            .configValue=${"display_name"}
            @input=${this._valueChanged}
            placeholder="John Doe"
            helper="Name shown in calls"
          ></ha-textfield>
        </div>

        <div class="config-section">
          <h3>Connection Test</h3>
          <div class="test-connection">
            <ha-button @click=${this.testConnection}>
              <ha-icon icon="mdi:connection" slot="icon"></ha-icon>
              Test Connection
            </ha-button>
            <div class="test-result" id="test-result"></div>
          </div>
        </div>
      </div>
    `;
  }

  private renderContactsTab(): TemplateResult {
    return html`
      <div class="tab-content">
        <div class="contacts-header">
          <h3>Quick Dial Contacts</h3>
          <ha-button @click=${this.addContact} class="add-contact-btn">
            <ha-icon icon="mdi:plus" slot="icon"></ha-icon>
            Add Contact
          </ha-button>
        </div>

        ${this.config.contacts.length === 0
          ? html`
              <div class="no-contacts-message">
                <ha-icon icon="mdi:contacts-outline"></ha-icon>
                <p>No contacts configured</p>
                <p class="helper">Add contacts for quick dialing</p>
              </div>
            `
          : ""}

        <div class="contacts-list">${this.config.contacts.map((contact, index) => this.renderContactItem(contact, index))}</div>
      </div>
    `;
  }

  private renderContactItem(contact: SIPContact, index: number): TemplateResult {
    return html`
      <div class="contact-item">
        <div class="contact-info">
          <ha-icon icon=${contact.icon || "mdi:account"}></ha-icon>
          <div class="contact-details">
            <div class="contact-name">${contact.name}</div>
            <div class="contact-extension">${contact.extension}</div>
          </div>
        </div>
        <div class="contact-actions">
          <ha-icon-button @click=${() => this.editContact(contact, index)} icon="mdi:pencil" title="Edit contact"></ha-icon-button>
          <ha-icon-button @click=${() => this.deleteContact(index)} icon="mdi:delete" title="Delete contact"></ha-icon-button>
        </div>
      </div>
    `;
  }

  private renderAdvancedTab(): TemplateResult {
    return html`
      <div class="tab-content">
        <div class="config-section">
          <h3>Call Settings</h3>

          <ha-formfield label="Auto Answer Incoming Calls">
            <ha-checkbox .checked=${this.config.auto_answer === true} .configValue=${"auto_answer"} @change=${this._valueChanged}></ha-checkbox>
          </ha-formfield>

          <ha-formfield label="Enable Video Calling">
            <ha-checkbox .checked=${this.config.video_enabled !== false} .configValue=${"video_enabled"} @change=${this._valueChanged}></ha-checkbox>
          </ha-formfield>

          <ha-formfield label="Enable DTMF Keypad">
            <ha-checkbox .checked=${this.config.dtmf_enabled !== false} .configValue=${"dtmf_enabled"} @change=${this._valueChanged}></ha-checkbox>
          </ha-formfield>

          <ha-textfield
            label="Ring Timeout (seconds)"
            .value=${this.config.ring_timeout ? (this.config.ring_timeout / 1000).toString() : "30"}
            .configValue=${"ring_timeout"}
            @input=${this._ringTimeoutChanged}
            type="number"
            min="5"
            max="120"
            helper="Auto-reject calls after this duration"
          ></ha-textfield>
        </div>

        <div class="config-section">
          <h3>Interface Options</h3>

          <ha-formfield label="Hide Keypad">
            <ha-checkbox .checked=${this.config.hide_keypad === true} .configValue=${"hide_keypad"} @change=${this._valueChanged}></ha-checkbox>
          </ha-formfield>

          <ha-formfield label="Hide Video Controls">
            <ha-checkbox .checked=${this.config.hide_video_controls === true} .configValue=${"hide_video_controls"} @change=${this._valueChanged}></ha-checkbox>
          </ha-formfield>

          <ha-select label="Theme" .value=${this.config.theme || "auto"} .configValue=${"theme"} @selected=${this._valueChanged}>
            <mwc-list-item value="auto">Auto (Follow HA Theme)</mwc-list-item>
            <mwc-list-item value="light">Light</mwc-list-item>
            <mwc-list-item value="dark">Dark</mwc-list-item>
          </ha-select>
        </div>

        <div class="config-section">
          <h3>WebRTC Settings</h3>

          <ha-textarea
            label="STUN Servers (one per line)"
            .value=${this.config.stun_servers?.join("\n") || "stun:stun.l.google.com:19302"}
            .configValue=${"stun_servers"}
            @input=${this._stunServersChanged}
            helper="STUN servers for NAT traversal"
            rows="3"
          ></ha-textarea>

          <ha-formfield label="Enable Debug Logging">
            <ha-checkbox .checked=${this.config.debug === true} .configValue=${"debug"} @change=${this._valueChanged}></ha-checkbox>
          </ha-formfield>
        </div>
      </div>
    `;
  }

  private renderContactDialog(): TemplateResult {
    if (!this.showAddContact && !this.editingContact) return html``;

    const contact = this.editingContact || { name: "", extension: "", icon: "mdi:account" };
    const isEditing = this.editingContact !== null;

    return html`
      <ha-dialog open @closed=${this.closeContactDialog} heading=${isEditing ? "Edit Contact" : "Add Contact"}>
        <div class="contact-dialog">
          <ha-textfield
            label="Contact Name *"
            .value=${contact.name}
            @input=${(e: Event) => this.updateContactField("name", (e.target as HTMLInputElement).value)}
            placeholder="John Doe"
            required
          ></ha-textfield>

          <ha-textfield
            label="Extension/Number *"
            .value=${contact.extension}
            @input=${(e: Event) => this.updateContactField("extension", (e.target as HTMLInputElement).value)}
            placeholder="1001"
            required
          ></ha-textfield>

          <ha-select label="Icon" .value=${contact.icon || "mdi:account"} @selected=${(e: Event) => this.updateContactField("icon", (e.target as any).value)}>
            <mwc-list-item value="mdi:account">Person</mwc-list-item>
            <mwc-list-item value="mdi:phone">Phone</mwc-list-item>
            <mwc-list-item value="mdi:home">Home</mwc-list-item>
            <mwc-list-item value="mdi:office-building">Office</mwc-list-item>
            <mwc-list-item value="mdi:cellphone">Mobile</mwc-list-item>
            <mwc-list-item value="mdi:account-supervisor">Manager</mwc-list-item>
            <mwc-list-item value="mdi:shield-account">Security</mwc-list-item>
            <mwc-list-item value="mdi:wrench">Maintenance</mwc-list-item>
            <mwc-list-item value="mdi:medical-bag">Medical</mwc-list-item>
            <mwc-list-item value="mdi:fire-truck">Emergency</mwc-list-item>
          </ha-select>

          <div class="preview-contact">
            <h4>Preview:</h4>
            <div class="contact-preview">
              <ha-icon icon=${contact.icon || "mdi:account"}></ha-icon>
              <div>
                <div class="preview-name">${contact.name || "Contact Name"}</div>
                <div class="preview-extension">${contact.extension || "Extension"}</div>
              </div>
            </div>
          </div>
        </div>

        <ha-button slot="primaryAction" @click=${this.saveContact} ?disabled=${!contact.name?.trim() || !contact.extension?.trim()}>
          ${isEditing ? "Update" : "Add"} Contact
        </ha-button>

        <ha-button slot="secondaryAction" @click=${this.closeContactDialog}> Cancel </ha-button>
      </ha-dialog>
    `;
  }

  // Event handlers
  private _valueChanged(ev: Event): void {
    if (!this.config || !this.hass) return;

    const target = ev.target as any;
    const configValue = target.configValue;

    if (!configValue) return;

    let value: any;
    if (target.checked !== undefined) {
      value = target.checked;
    } else if (target.value !== undefined) {
      value = target.value;
    } else if (target.selected !== undefined) {
      value = target.value;
    } else {
      return;
    }

    // Convert empty strings to undefined for optional fields
    if (value === "" && ["title", "display_name", "domain", "websocket_port"].includes(configValue)) {
      value = undefined;
    }

    const newConfig = { ...this.config, [configValue]: value };
    this.fireConfigChanged(newConfig);
  }

  private _ringTimeoutChanged(ev: Event): void {
    const target = ev.target as HTMLInputElement;
    const seconds = parseInt(target.value) || 30;
    const milliseconds = Math.max(5000, Math.min(120000, seconds * 1000));

    const newConfig = { ...this.config, ring_timeout: milliseconds };
    this.fireConfigChanged(newConfig);
  }

  private _stunServersChanged(ev: Event): void {
    const target = ev.target as HTMLTextAreaElement;
    const servers = target.value
      .split("\n")
      .map((s) => s.trim())
      .filter((s) => s.length > 0);

    const newConfig = { ...this.config, stun_servers: servers };
    this.fireConfigChanged(newConfig);
  }

  private async testConnection(): Promise<void> {
    const resultEl = this.shadowRoot?.getElementById("test-result");
    if (!resultEl) return;

    resultEl.innerHTML = '<ha-circular-progress size="small" indeterminate></ha-circular-progress> Testing...';

    try {
      // Basic URL validation
      if (!this.config.server_url || !this.config.username || !this.config.password) {
        throw new Error("Server URL, username, and password are required");
      }

      // Validate WebSocket URL format
      const url = new URL(this.config.server_url);
      if (!["ws:", "wss:"].includes(url.protocol)) {
        throw new Error("Server URL must use ws:// or wss:// protocol");
      }

      // Test basic connectivity (this is a simplified test)
      const wsUrl = this.config.server_url;
      const testWs = new WebSocket(wsUrl);

      const testPromise = new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          testWs.close();
          reject(new Error("Connection timeout"));
        }, 10000);

        testWs.onopen = () => {
          clearTimeout(timeout);
          testWs.close();
          resolve("Connection successful");
        };

        testWs.onerror = () => {
          clearTimeout(timeout);
          reject(new Error("Connection failed"));
        };
      });

      await testPromise;
      resultEl.innerHTML = '<ha-icon icon="mdi:check-circle" style="color: var(--success-color)"></ha-icon> Connection test successful';
    } catch (error) {
      resultEl.innerHTML = `<ha-icon icon="mdi:alert-circle" style="color: var(--error-color)"></ha-icon> ${
        error instanceof Error ? error.message : "Connection test failed"
      }`;
    }
  }

  // Contact management
  private addContact(): void {
    this.editingContact = null;
    this.showAddContact = true;
  }

  private editContact(contact: SIPContact, index: number): void {
    this.editingContact = { ...contact, originalIndex: index } as any;
    this.showAddContact = false;
  }

  private deleteContact(index: number): void {
    const contacts = [...this.config.contacts];
    contacts.splice(index, 1);

    const newConfig = { ...this.config, contacts };
    this.fireConfigChanged(newConfig);
  }

  private updateContactField(field: keyof SIPContact, value: string): void {
    if (this.editingContact) {
      this.editingContact = { ...this.editingContact, [field]: value };
    } else {
      // Handle new contact case
      this.editingContact = {
        name: "",
        extension: "",
        icon: "mdi:account",
        [field]: value,
      };
    }
    this.requestUpdate();
  }

  private saveContact(): void {
    if (!this.editingContact) return;

    const contact = {
      name: this.editingContact.name.trim(),
      extension: this.editingContact.extension.trim(),
      icon: this.editingContact.icon || "mdi:account",
    };

    let contacts = [...this.config.contacts];
    const originalIndex = (this.editingContact as any).originalIndex;

    if (originalIndex !== undefined) {
      // Edit existing contact
      contacts[originalIndex] = contact;
    } else {
      // Add new contact
      contacts.push(contact);
    }

    const newConfig = { ...this.config, contacts };
    this.fireConfigChanged(newConfig);

    this.closeContactDialog();
  }

  private closeContactDialog(): void {
    this.editingContact = null;
    this.showAddContact = false;
  }

  private fireConfigChanged(newConfig: SIPCardConfig): void {
    this.config = newConfig;

    const event = new CustomEvent("config-changed", {
      detail: { config: newConfig },
      bubbles: true,
      composed: true,
    });
    this.dispatchEvent(event);
  }

  static get styles(): CSSResultGroup {
    return css`
      .card-config {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .config-header {
        text-align: center;
        padding-bottom: 16px;
        border-bottom: 1px solid var(--divider-color);
      }

      .config-header h2 {
        margin: 0 0 8px 0;
        color: var(--primary-text-color);
      }

      .config-header p {
        margin: 0;
        color: var(--secondary-text-color);
        font-size: 14px;
      }

      .config-tabs {
        display: flex;
        border-bottom: 1px solid var(--divider-color);
      }

      .tab {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        padding: 12px 16px;
        border: none;
        background: transparent;
        color: var(--secondary-text-color);
        cursor: pointer;
        font-family: inherit;
        font-size: 14px;
        border-bottom: 2px solid transparent;
        transition: all 0.2s ease;
      }

      .tab:hover {
        background: var(--secondary-background-color);
        color: var(--primary-text-color);
      }

      .tab.active {
        color: var(--primary-color);
        border-bottom-color: var(--primary-color);
        background: var(--secondary-background-color);
      }

      .tab-content {
        padding: 16px 0;
      }

      .config-section {
        margin-bottom: 32px;
      }

      .config-section h3 {
        margin: 0 0 16px 0;
        font-size: 16px;
        font-weight: 500;
        color: var(--primary-text-color);
      }

      .config-section > * {
        margin-bottom: 16px;
      }

      .test-connection {
        display: flex;
        align-items: center;
        gap: 16px;
      }

      .test-result {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 14px;
      }

      .contacts-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 16px;
      }

      .contacts-header h3 {
        margin: 0;
      }

      .add-contact-btn {
        --mdc-theme-primary: var(--primary-color);
      }

      .no-contacts-message {
        text-align: center;
        padding: 40px 20px;
        color: var(--secondary-text-color);
      }

      .no-contacts-message ha-icon {
        font-size: 48px;
        margin-bottom: 16px;
        opacity: 0.5;
      }

      .no-contacts-message p {
        margin: 8px 0;
      }

      .no-contacts-message .helper {
        font-size: 12px;
        opacity: 0.7;
      }

      .contacts-list {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      .contact-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 12px;
        background: var(--secondary-background-color);
        border-radius: 8px;
        border: 1px solid var(--divider-color);
      }

      .contact-info {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .contact-info ha-icon {
        color: var(--primary-color);
        font-size: 24px;
      }

      .contact-details {
        display: flex;
        flex-direction: column;
      }

      .contact-name {
        font-weight: 500;
        color: var(--primary-text-color);
      }

      .contact-extension {
        font-size: 12px;
        color: var(--secondary-text-color);
      }

      .contact-actions {
        display: flex;
        gap: 4px;
      }

      .contact-dialog {
        display: flex;
        flex-direction: column;
        gap: 16px;
        min-width: 320px;
      }

      .preview-contact h4 {
        margin: 0 0 8px 0;
        font-size: 14px;
        color: var(--secondary-text-color);
      }

      .contact-preview {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px;
        background: var(--secondary-background-color);
        border-radius: 8px;
        border: 1px solid var(--divider-color);
      }

      .contact-preview ha-icon {
        color: var(--primary-color);
        font-size: 24px;
      }

      .preview-name {
        font-weight: 500;
        color: var(--primary-text-color);
      }

      .preview-extension {
        font-size: 12px;
        color: var(--secondary-text-color);
      }

      ha-textfield,
      ha-textarea,
      ha-select {
        width: 100%;
      }

      ha-formfield {
        display: block;
        margin-bottom: 16px;
      }
    `;
  }
}

declare global {
  interface HTMLElementTagNameMap {
    "ha-webrtc-sip-card-editor": WebRTCSipCardEditor;
  }
}

---

=== Object: 2384673b63e2ae01d414c771632b5139f950555a | Date: 2025-09-23 19:05:08 | Type: blob ===

[req]
default_bits = 2048
prompt = no
default_md = sha256
distinguished_name = dn
req_extensions = v3_req

[dn]
C = US
ST = Local
L = Local
O = Home Assistant
CN = localhost

[v3_req]
basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment
extendedKeyUsage = serverAuth
subjectAltName = @alt_names

[alt_names]
DNS.1 = localhost
DNS.2 = homeassistant.local
IP.1 = 127.0.0.1
---

=== Object: 85b15c3cba7361d4165391701879778fa23e1983 | Date: 2025-09-23 15:35:25 | Type: blob ===

import type { CallInfo } from "./sip-manager";
import { SipManager } from "./sip-manager";
import { formatDuration, playRingtone, stopRingtone, getContactByExtension } from "./utils";
import type { SIPContact } from "./types";

export interface CallState {
  active: boolean;
  incoming: boolean;
  outgoing: boolean;
  onHold: boolean;
  muted: boolean;
  remoteVideoEnabled: boolean;
  localVideoTransmitting: boolean;
  callerId?: string;
  callerName?: string;
  duration: number;
  status: "idle" | "connecting" | "ringing" | "answered" | "held" | "ended" | "error";
}

export class CallManager extends EventTarget {
  private sipManager: SipManager;
  private callState: CallState;
  private ringtone: HTMLAudioElement | null = null;
  private ringTimeout: number | null = null;
  private contacts: SIPContact[] = [];
  private isAnsweringCall = false; // Flag to prevent multiple simultaneous answer calls

  constructor(sipManager: SipManager, contacts: SIPContact[] = []) {
    super();
    this.sipManager = sipManager;
    this.contacts = contacts;
    this.callState = this.getInitialState();
    this.setupSipEventHandlers();
  }

  public updateContacts(contacts: SIPContact[]): void {
    this.contacts = contacts;
  }

  private getInitialState(): CallState {
    return {
      active: false,
      incoming: false,
      outgoing: false,
      onHold: false,
      muted: false,
      remoteVideoEnabled: false,
      localVideoTransmitting: false,
      duration: 0,
      status: "idle",
    };
  }

  private setupSipEventHandlers(): void {
    this.sipManager.addEventListener("incomingCall", this.handleIncomingCall.bind(this) as EventListener);
    this.sipManager.addEventListener("callStarted", this.handleCallStarted.bind(this) as EventListener);
    this.sipManager.addEventListener("callAnswered", this.handleCallAnswered.bind(this) as EventListener);
    this.sipManager.addEventListener("callEnded", this.handleCallEnded.bind(this) as EventListener);
    this.sipManager.addEventListener("callFailed", this.handleCallFailed.bind(this) as EventListener);
    this.sipManager.addEventListener("localVideoChanged", this.handleLocalVideoChanged.bind(this) as EventListener);
    this.sipManager.addEventListener("remoteVideoChanged", this.handleRemoteVideoChanged.bind(this) as EventListener);
    this.sipManager.addEventListener("callTimer", this.handleCallTimer.bind(this) as EventListener);
    this.sipManager.addEventListener("callHold", this.handleCallHold.bind(this) as EventListener);
  }

  private cleanExtension(rawExtension: string): string {
    if (!rawExtension || rawExtension === "unknown") return rawExtension;

    let cleaned = rawExtension.replace(/^Extension\s+/i, "");
    cleaned = cleaned.replace(/-screen$|-web$|-mobile$|-phone$/i, "");

    const numericMatch = cleaned.match(/(\d+)/);
    if (numericMatch) {
      return numericMatch[1];
    }

    return cleaned;
  }

  private cleanDisplayName(displayName: string, extension: string): string {
    if (!displayName || displayName === "unknown" || displayName === "Unknown Caller") {
      return extension;
    }

    let cleaned = displayName.replace(/^Extension\s+/i, "");
    cleaned = cleaned.replace(new RegExp(`\\b${extension}\\b`, "g"), "").trim();

    if (!cleaned || cleaned === extension) {
      return extension;
    }

    return cleaned;
  }

  private handleIncomingCall(event: CustomEvent): void {
    const { from, displayName, callInfo } = event.detail;

    const cleanedExtension = this.cleanExtension(from);
    const cleanedDisplayName = this.cleanDisplayName(displayName, cleanedExtension);
    const contact = this.contacts ? getContactByExtension(this.contacts, cleanedExtension) : null;
    const finalCallerName = contact ? contact.name : cleanedDisplayName;

    this.callState = {
      ...this.callState,
      active: true,
      incoming: true,
      outgoing: false,
      callerId: cleanedExtension,
      callerName: finalCallerName,
      status: "ringing",
      duration: 0,
    };

    this.ringtone = playRingtone();

    this.ringTimeout = window.setTimeout(() => {
      if (this.callState.status === "ringing" && this.callState.incoming) {
        this.rejectCall().catch((error) => {
          console.error("Auto-reject failed:", error);
          this.forceCallCleanup();
        });
      }
    }, 30000);

    this.dispatchCallStateUpdate();
  }

  private forceCallCleanup(): void {
    this.stopRinging();
    this.clearRingTimeout();

    // Ensure media tracks are stopped when force cleaning up
    try {
      // The SIP manager should handle this, but we'll make sure
      console.log("Force call cleanup, ensuring media tracks are stopped");
    } catch (error) {
      console.error("Error during force call cleanup:", error);
    }

    this.callState = this.getInitialState();
    this.callState.status = "ended";

    this.dispatchCallStateUpdate();

    setTimeout(() => {
      this.callState.status = "idle";
      this.dispatchCallStateUpdate();
    }, 1000);
  }

  private handleCallStarted(event: CustomEvent): void {
    const { target } = event.detail;

    const cleanedExtension = this.cleanExtension(target);
    const contact = this.contacts ? getContactByExtension(this.contacts, cleanedExtension) : null;
    const finalCallerName = contact ? contact.name : cleanedExtension;

    this.callState = {
      ...this.callState,
      active: true,
      incoming: false,
      outgoing: true,
      callerId: cleanedExtension,
      callerName: finalCallerName,
      status: "connecting",
      duration: 0,
    };

    this.dispatchCallStateUpdate();
  }

  private handleCallAnswered(_event: CustomEvent): void {
    this.stopRinging();
    this.clearRingTimeout();

    this.callState = {
      ...this.callState,
      status: "answered",
      incoming: false,
      outgoing: false,
      duration: 0,
    };

    // FIXED: Update local video state immediately
    const videoState = this.sipManager.getLocalVideoState();
    this.callState.localVideoTransmitting = videoState.transmitting;

    // Check if remote video is available
    setTimeout(() => {
      const remoteVideo = this.sipManager.getRemoteVideo();
      if (remoteVideo && remoteVideo.srcObject) {
        const stream = remoteVideo.srcObject as MediaStream;
        const videoTracks = stream.getVideoTracks();
        this.callState.remoteVideoEnabled = videoTracks.length > 0 && videoTracks.some((track) => track.enabled);
        console.log("Remote video detected in call answered:", {
          videoTracks: videoTracks.length,
          enabled: this.callState.remoteVideoEnabled,
        });
        this.dispatchCallStateUpdate();
      }
    }, 500);

    this.dispatchCallStateUpdate();
  }

  private handleCallEnded(_event: CustomEvent): void {
    this.stopRinging();
    this.clearRingTimeout();

    this.callState = this.getInitialState();
    this.callState.status = "ended";

    this.dispatchCallStateUpdate();

    setTimeout(() => {
      this.callState.status = "idle";
      this.dispatchCallStateUpdate();
    }, 2000);
  }

  private handleCallFailed(_event: CustomEvent): void {
    this.stopRinging();
    this.clearRingTimeout();

    // Ensure media tracks are stopped
    try {
      // The SIP manager should handle this, but we'll make sure
      console.log("Call failed, ensuring media tracks are stopped");
    } catch (error) {
      console.error("Error during call failure cleanup:", error);
    }

    this.callState = this.getInitialState();
    this.callState.status = "error";

    this.dispatchCallStateUpdate();
  }

  private handleCallTimer(_event: CustomEvent): void {
    // This method is intentionally left empty as the timer is handled by the SIP manager
  }

  private handleCallHold(event: CustomEvent): void {
    const { held } = event.detail;
    this.callState.onHold = held;
    this.callState.status = held ? "held" : "answered";
    this.dispatchCallStateUpdate();
  }

  private handleLocalVideoChanged(event: CustomEvent): void {
    const { transmitting } = event.detail;
    this.callState.localVideoTransmitting = transmitting;
    this.dispatchCallStateUpdate();
  }

  private handleRemoteVideoChanged(event: CustomEvent): void {
    const { enabled } = event.detail;
    this.callState.remoteVideoEnabled = enabled;
    this.dispatchCallStateUpdate();
  }

  public async toggleVideo(): Promise<boolean> {
    try {
      const enabled = await this.sipManager.toggleVideo();
      return enabled;
    } catch (error) {
      console.error("Failed to toggle video:", error);
      throw error;
    }
  }

  public async enableVideo(): Promise<void> {
    try {
      await this.sipManager.enableVideo();
      console.log("Video enabled successfully");
    } catch (error) {
      console.error("Failed to enable video:", error);
      throw error;
    }
  }

  public async disableVideo(): Promise<void> {
    try {
      await this.sipManager.disableVideo();
    } catch (error) {
      console.error("Failed to disable video:", error);
      throw error;
    }
  }

  private stopRinging(): void {
    if (this.ringtone) {
      stopRingtone(this.ringtone);
      this.ringtone = null;
    }
  }

  private clearRingTimeout(): void {
    if (this.ringTimeout) {
      clearTimeout(this.ringTimeout);
      this.ringTimeout = null;
    }
  }

  private dispatchCallStateUpdate(): void {
    this.dispatchEvent(
      new CustomEvent("callStateChanged", {
        detail: { callState: { ...this.callState } },
      })
    );
  }

  async makeCall(target: string, includeVideo?: boolean): Promise<void> {
    try {
      await this.sipManager.makeCall(target, includeVideo);
    } catch (error) {
      this.callState.status = "error";
      this.dispatchCallStateUpdate();
      throw error;
    }
  }

  // FIXED: Enhanced answerCall to properly handle video
  async answerCall(withVideo = false): Promise<void> {
    // Prevent multiple simultaneous answer calls
    if (this.isAnsweringCall) {
      console.warn("Call is already being answered, ignoring duplicate request");
      return;
    }

    try {
      this.isAnsweringCall = true;
      
      if (withVideo) {
        console.log("Answering with video - enabling video first");
        await this.sipManager.enableVideo();
      }

      await this.sipManager.answerCall();
      console.log(`Call answered ${withVideo ? "with" : "without"} video`);
    } catch (error) {
      console.error("Failed to answer call:", error);
      this.callState.status = "error";
      this.dispatchCallStateUpdate();
      throw error;
    } finally {
      this.isAnsweringCall = false;
    }
  }

  async rejectCall(): Promise<void> {
    this.stopRinging();
    this.clearRingTimeout();

    try {
      if (this.sipManager && (this.callState.status === "ringing" || this.callState.incoming)) {
        await this.sipManager.rejectCall();
      } else {
        console.warn("Cannot reject call - invalid state:", this.callState.status);
        this.forceCallCleanup();
        return;
      }
    } catch (error) {
      console.error("Reject call failed:", error);
      this.forceCallCleanup();
      throw error;
    }
  }

  async hangupCall(): Promise<void> {
    try {
      await this.sipManager.hangup();
    } catch (error) {
      this.callState = this.getInitialState();
      this.dispatchCallStateUpdate();
      throw error;
    }
  }

  async toggleMute(): Promise<boolean> {
    try {
      if (this.callState.muted) {
        await this.sipManager.unmute();
        this.callState.muted = false;
      } else {
        await this.sipManager.mute();
        this.callState.muted = true;
      }

      this.dispatchCallStateUpdate();
      return this.callState.muted;
    } catch (error) {
      throw error;
    }
  }

  sendDTMF(tone: string): void {
    if (this.callState.active && this.callState.status === "answered") {
      this.sipManager.sendDTMF(tone);
    }
  }

  getCallState(): CallState {
    return { ...this.callState };
  }

  getRemoteVideo(): HTMLVideoElement | null {
    return this.sipManager.getRemoteVideo();
  }

  getCurrentCall(): CallInfo | null {
    return this.sipManager.getCurrentCall();
  }

  getFormattedDuration(): string {
    return formatDuration(this.callState.duration);
  }
}

---

=== Object: 7c80500a885c0003c3401120e6185abe5fa7aafb | Date: 2025-09-23 15:35:25 | Type: blob ===

import { debugLog, errorLog } from "./utils";

type SimpleUser = any;
type SimpleUserOptions = any;
let Web: any = null;

export interface SipConfig {
  server: string;
  username: string;
  password: string;
  domain: string;
  websocket_port: number;
  use_secure: boolean;
  display_name?: string;
  debug?: boolean;
}

export interface CallInfo {
  id: string;
  remoteIdentity: string;
  displayName: string;
  state: "incoming" | "outgoing" | "connected" | "ended";
  startTime?: Date;
  duration: number;
}

export class SipManager extends EventTarget {
  private simpleUser: SimpleUser | null = null;
  private config: SipConfig | null = null;
  private isRegistered = false;
  private isConnected = false;
  private connectionTimer: number | null = null;
  private currentCall: CallInfo | null = null;
  private remoteAudio: HTMLAudioElement | null = null;
  private remoteVideo: HTMLVideoElement | null = null;
  private localVideo: HTMLVideoElement | null = null;
  private localStream: MediaStream | null = null;
  private videoEnabled = false;
  private isInitialized = false;
  private isInitializing = false;
  private lastVideoState = false;
  private isEnablingVideo = false; // Flag to prevent multiple simultaneous enableVideo calls

  constructor() {
    super();
    this.setupMediaElements();
  }

  private setupMediaElements(): void {
    this.remoteAudio = document.createElement("audio");
    this.remoteAudio.autoplay = true;
    this.remoteAudio.style.display = "none";
    document.body.appendChild(this.remoteAudio);

    this.remoteVideo = document.createElement("video");
    this.remoteVideo.autoplay = true;
    this.remoteVideo.playsInline = true;
    this.remoteVideo.style.display = "none";
    document.body.appendChild(this.remoteVideo);

    this.localVideo = document.createElement("video");
    this.localVideo.autoplay = true;
    this.localVideo.muted = true;
    this.localVideo.playsInline = true;
    this.localVideo.style.display = "none";
    document.body.appendChild(this.localVideo);
  }

  private async getUserMedia(includeVideo: boolean = false): Promise<MediaStream> {
    const constraints: MediaStreamConstraints = {
      audio: {
        echoCancellation: true,
        noiseSuppression: true,
        autoGainControl: true,
        sampleRate: 48000,
      },
      video: includeVideo
        ? {
            width: { ideal: 640, min: 320, max: 1280 },
            height: { ideal: 480, min: 240, max: 720 },
            frameRate: { ideal: 30, min: 15, max: 30 },
            facingMode: "user",
          }
        : false,
    };

    return navigator.mediaDevices.getUserMedia(constraints);
  }

  public async enableVideo(): Promise<void> {
    // Prevent multiple simultaneous enableVideo calls
    if (this.isEnablingVideo) {
      debugLog(this.config?.debug || false, "Video is already being enabled, ignoring duplicate request");
      return;
    }

    try {
      this.isEnablingVideo = true;
      
      const stream = await this.getUserMedia(true);

      if (this.localStream) {
        this.localStream.getTracks().forEach((track) => track.stop());
      }

      if (this.localVideo) {
        this.localVideo.srcObject = stream;
      }

      this.localStream = stream;
      this.videoEnabled = true;

      debugLog(this.config?.debug || false, "Local video enabled with new stream:", {
        videoTracks: stream.getVideoTracks().length,
        audioTracks: stream.getAudioTracks().length,
        streamId: stream.id,
      });

      if (this.simpleUser?.session && this.currentCall?.state === "connected") {
        await this.replaceMediaTracks(stream);
      }

      this.dispatchEvent(
        new CustomEvent("localVideoChanged", {
          detail: {
            enabled: true,
            transmitting: stream.getVideoTracks().some((track) => track.enabled && track.readyState === "live"),
          },
        })
      );
    } catch (error) {
      errorLog("Enable video failed", error);
      this.videoEnabled = false;
      throw error;
    } finally {
      this.isEnablingVideo = false;
    }
  }

  public async disableVideo(): Promise<void> {
    try {
      const audioOnlyStream = await this.getUserMedia(false);

      if (this.localVideo) {
        this.localVideo.srcObject = null;
      }

      if (this.localStream) {
        this.localStream.getTracks().forEach((track) => {
          track.stop();
          debugLog(this.config?.debug || false, `Stopped ${track.kind} track:`, track.id);
        });
      }

      this.localStream = audioOnlyStream;
      this.videoEnabled = false;

      debugLog(this.config?.debug || false, "Local video disabled, using audio-only stream:", {
        videoTracks: audioOnlyStream.getVideoTracks().length,
        audioTracks: audioOnlyStream.getAudioTracks().length,
        streamId: audioOnlyStream.id,
      });

      if (this.simpleUser?.session && this.currentCall?.state === "connected") {
        await this.replaceMediaTracks(audioOnlyStream);
      }

      this.dispatchEvent(
        new CustomEvent("localVideoChanged", {
          detail: {
            enabled: false,
            transmitting: false,
          },
        })
      );
    } catch (error) {
      errorLog("Disable video failed", error);
      throw error;
    }
  }

  private async replaceMediaTracks(newStream: MediaStream): Promise<void> {
    try {
      const session = this.simpleUser?.session;
      if (!session || !session.sessionDescriptionHandler) {
        debugLog(this.config?.debug || false, "No active session to replace tracks");
        return;
      }

      const pc = session.sessionDescriptionHandler.peerConnection;
      if (!pc) {
        debugLog(this.config?.debug || false, "No peer connection found");
        return;
      }

      const senders = pc.getSenders();

      const audioTrack = newStream.getAudioTracks()[0];
      const audioSender = senders.find((sender: any) => sender.track && sender.track.kind === "audio");
      if (audioSender && audioTrack) {
        await audioSender.replaceTrack(audioTrack);
        debugLog(this.config?.debug || false, "Audio track replaced successfully");
      }

      const videoTrack = newStream.getVideoTracks()[0] || null;
      const videoSender = senders.find((sender: any) => sender.track && sender.track.kind === "video");

      if (videoSender) {
        await videoSender.replaceTrack(videoTrack);
        debugLog(this.config?.debug || false, videoTrack ? "Video track replaced" : "Video track removed from sender");
      } else if (videoTrack) {
        try {
          pc.addTrack(videoTrack, newStream);
          debugLog(this.config?.debug || false, "Video track added to peer connection");

          if (session.sessionDescriptionHandler && typeof session.sessionDescriptionHandler.sendReinvite === "function") {
            await session.sessionDescriptionHandler.sendReinvite();
            debugLog(this.config?.debug || false, "Session renegotiated for new video track");
          }
        } catch (error) {
          debugLog(this.config?.debug || false, "Failed to add video track:", error);
        }
      }
    } catch (error) {
      debugLog(this.config?.debug || false, "Replace media tracks failed but call continues:", error);
    }
  }

  public async toggleVideo(): Promise<boolean> {
    try {
      if (this.videoEnabled) {
        await this.disableVideo();
        return false;
      } else {
        await this.enableVideo();
        return true;
      }
    } catch (error) {
      errorLog("Toggle video failed", error);
      throw error;
    }
  }

  public getLocalVideoState(): { enabled: boolean; transmitting: boolean } {
    return {
      enabled: this.videoEnabled,
      transmitting: this.localStream ? this.localStream.getVideoTracks().some((track) => track.enabled && track.readyState === "live") : false,
    };
  }

  private setupRemoteStreamHandlers(session: any): void {
    try {
      const sessionDescriptionHandler = session.sessionDescriptionHandler;
      if (!sessionDescriptionHandler) {
        debugLog(this.config?.debug || false, "No session description handler");
        return;
      }

      const pc = sessionDescriptionHandler.peerConnection;
      if (!pc) {
        debugLog(this.config?.debug || false, "No peer connection");
        return;
      }

      debugLog(this.config?.debug || false, "Setting up remote stream handlers for", pc.connectionState);

      pc.ontrack = (event: RTCTrackEvent) => {
        debugLog(this.config?.debug || false, "Remote track received:", {
          kind: event.track.kind,
          readyState: event.track.readyState,
          enabled: event.track.enabled,
          streams: event.streams.length,
          transceiver: event.transceiver.direction,
        });

        const stream = event.streams[0];
        if (!stream) {
          debugLog(this.config?.debug || false, "No stream in track event");
          return;
        }

        if (event.track.kind === "audio") {
          if (this.remoteAudio) {
            this.remoteAudio.srcObject = stream;
            debugLog(this.config?.debug || false, "Remote audio stream attached");
          }
        } else if (event.track.kind === "video") {
          if (this.remoteVideo) {
            this.remoteVideo.srcObject = stream;
            this.remoteVideo.autoplay = true;
            this.remoteVideo.playsInline = true;

            debugLog(this.config?.debug || false, "Remote video stream attached, playing...");

            // Handle video play with better error handling
            if (this.remoteVideo.srcObject) {
              const playPromise = this.remoteVideo.play();
              if (playPromise !== undefined) {
                playPromise
                  .then(() => {
                    debugLog(this.config?.debug || false, "Remote video playing successfully");
                  })
                  .catch((error) => {
                    debugLog(this.config?.debug || false, "Remote video play failed:", error);
                    
                    // Handle specific error types
                    if (error.name === "NotAllowedError") {
                      debugLog(this.config?.debug || false, "Video play not allowed, likely due to autoplay restrictions");
                      
                      // Try to handle autoplay restrictions by muting and retrying
                      if (this.remoteVideo) {
                        this.remoteVideo.muted = true;
                        const retryPromise = this.remoteVideo.play();
                        if (retryPromise !== undefined) {
                          retryPromise.catch((retryError) => {
                            debugLog(this.config?.debug || false, "Muted video play retry failed:", retryError);
                            
                            // Last resort: re-attach the stream
                            if (this.remoteVideo && this.remoteVideo.srcObject) {
                              const currentStream = this.remoteVideo.srcObject;
                              this.remoteVideo.srcObject = null;
                              this.remoteVideo.srcObject = currentStream;
                              setTimeout(() => {
                                if (this.remoteVideo && this.remoteVideo.srcObject) {
                                  this.remoteVideo.muted = true;
                                  const finalPromise = this.remoteVideo.play();
                                  if (finalPromise !== undefined) {
                                    finalPromise.catch((finalError) => {
                                      debugLog(this.config?.debug || false, "Final video play attempt failed:", finalError);
                                    });
                                  }
                                }
                              }, 100);
                            }
                          });
                        }
                      }
                                      } else if (error.name === "AbortError") {
                    debugLog(this.config?.debug || false, "Video play was interrupted, this is normal during stream updates");
                    
                    // Retry after a short delay, but be more careful about the timing
                    setTimeout(() => {
                      if (this.remoteVideo && this.remoteVideo.srcObject) {
                        // Check if the video element is in a playable state
                        if (this.remoteVideo.readyState >= 2) { // HAVE_CURRENT_DATA
                          const retryPromise = this.remoteVideo.play();
                          if (retryPromise !== undefined) {
                            retryPromise.catch((retryError) => {
                              debugLog(this.config?.debug || false, "Video play retry failed:", retryError);
                            });
                          }
                        } else {
                          // If not ready, wait a bit more
                          setTimeout(() => {
                            if (this.remoteVideo && this.remoteVideo.srcObject) {
                              const retryPromise = this.remoteVideo.play();
                              if (retryPromise !== undefined) {
                                retryPromise.catch((retryError) => {
                                  debugLog(this.config?.debug || false, "Delayed video play retry failed:", retryError);
                                });
                              }
                            }
                          }, 200);
                        }
                      }
                    }, 150);
                    } else {
                      // Try to handle other errors by re-attaching the stream
                      if (this.remoteVideo && this.remoteVideo.srcObject) {
                        const currentStream = this.remoteVideo.srcObject;
                        this.remoteVideo.srcObject = null;
                        this.remoteVideo.srcObject = currentStream;
                        setTimeout(() => {
                          if (this.remoteVideo && this.remoteVideo.srcObject) {
                            const retryPromise = this.remoteVideo.play();
                            if (retryPromise !== undefined) {
                              retryPromise.catch((retryError) => {
                                debugLog(this.config?.debug || false, "Remote video play retry failed:", retryError);
                              });
                            }
                          }
                        }, 100);
                      }
                    }
                  });
              }
            }

            const videoTracks = stream.getVideoTracks();
            const hasActiveVideo = videoTracks.length > 0 && videoTracks.some((track) => track.enabled);

            debugLog(this.config?.debug || false, "Video track details:", {
              trackCount: videoTracks.length,
              hasActive: hasActiveVideo,
              trackStates: videoTracks.map((t) => ({
                id: t.id,
                enabled: t.enabled,
                readyState: t.readyState,
                label: t.label,
              })),
            });

            this.lastVideoState = hasActiveVideo;

            this.dispatchEvent(
              new CustomEvent("remoteVideoChanged", {
                detail: {
                  enabled: true,
                  stream: stream,
                  hasVideoTracks: hasActiveVideo,
                },
              })
            );

            setTimeout(() => {
              this.dispatchEvent(
                new CustomEvent("remoteVideoChanged", {
                  detail: {
                    enabled: true,
                    stream: stream,
                    hasVideoTracks: hasActiveVideo,
                  },
                })
              );
            }, 200);
          }
        }
      };

      pc.oniceconnectionstatechange = () => {
        debugLog(this.config?.debug || false, "ICE connection state changed:", pc.iceConnectionState);

        if (pc.iceConnectionState === "failed") {
          errorLog("ICE connection failed - attempting to recover");
          this.handleIceConnectionFailure(pc);
        }
      };

      pc.onicegatheringstatechange = () => {
        debugLog(this.config?.debug || false, "ICE gathering state changed:", pc.iceGatheringState);
      };

      pc.onicecandidate = (event: RTCPeerConnectionIceEvent) => {
        if (event.candidate) {
          debugLog(this.config?.debug || false, "ICE candidate:", event.candidate.type, event.candidate.candidate);
        } else {
          debugLog(this.config?.debug || false, "ICE gathering complete");
        }
      };

      pc.onconnectionstatechange = () => {
        debugLog(this.config?.debug || false, "Connection state changed:", pc.connectionState);

        if (pc.connectionState === "failed") {
          errorLog("Peer connection failed completely");
          this.handleConnectionFailure();
        } else if (pc.connectionState === "connected") {
          setTimeout(() => {
            const transceivers = pc.getTransceivers();
            debugLog(this.config?.debug || false, "Checking transceivers:", transceivers.length);

            transceivers.forEach((transceiver: RTCRtpTransceiver, index: number) => {
              debugLog(this.config?.debug || false, `Transceiver ${index}:`, {
                direction: transceiver.direction,
                kind: transceiver.receiver?.track?.kind,
                trackState: transceiver.receiver?.track?.readyState,
                hasTrack: !!transceiver.receiver?.track,
              });

              if (transceiver.receiver?.track?.kind === "video" && transceiver.receiver.track.readyState === "live") {
                debugLog(this.config?.debug || false, "Found active video transceiver");

                let videoStream: MediaStream;
                if (this.remoteVideo?.srcObject instanceof MediaStream) {
                  videoStream = this.remoteVideo.srcObject;
                } else {
                  videoStream = new MediaStream([transceiver.receiver.track]);
                  if (this.remoteVideo) {
                    this.remoteVideo.srcObject = videoStream;
                  }
                }

                this.dispatchEvent(
                  new CustomEvent("remoteVideoChanged", {
                    detail: {
                      enabled: true,
                      stream: videoStream,
                      hasVideoTracks: true,
                    },
                  })
                );
              }
            });
          }, 500);
        }
      };

      pc.onremovetrack = (event: RTCTrackEvent) => {
        debugLog(this.config?.debug || false, "Remote track removed:", event.track.kind);

        if (event.track.kind === "video" && this.remoteVideo) {
          this.remoteVideo.srcObject = null;
          this.lastVideoState = false;

          this.dispatchEvent(
            new CustomEvent("remoteVideoChanged", {
              detail: {
                enabled: false,
                stream: null,
                hasVideoTracks: false,
              },
            })
          );
        }
      };
    } catch (error) {
      errorLog("Failed to setup remote stream handlers:", error);
    }
  }

  private handleIceConnectionFailure(pc: RTCPeerConnection): void {
    debugLog(this.config?.debug || false, "Attempting ICE restart");

    setTimeout(() => {
      if (pc.iceConnectionState === "failed") {
        try {
          pc.restartIce();
          debugLog(this.config?.debug || false, "ICE restart initiated");
        } catch (error) {
          errorLog("ICE restart failed:", error);
        }
      }
    }, 1000);
  }

  private handleConnectionFailure(): void {
    errorLog("Connection failed - notifying UI");

    this.dispatchEvent(
      new CustomEvent("error", {
        detail: {
          error: "Connection failed - check network and STUN servers",
          type: "connection_failure",
        },
      })
    );
  }

  private async waitForSipLibrary(timeout = 15000): Promise<void> {
    return new Promise<void>(async (resolve, reject) => {
      const startTime = Date.now();
      const timeoutId = setTimeout(() => {
        reject(new Error(`SIP.js library loading timeout after ${timeout}ms`));
      }, timeout);

      const checkLibrary = async () => {
        try {
          if (!Web) {
            const SIP = await import("sip.js");
            Web = (SIP as any).Web || SIP;
          }

          const isFullyLoaded =
            Web &&
            Web.SimpleUser &&
            Web.SimpleUser.prototype &&
            typeof Web.SimpleUser.prototype.register === "function" &&
            typeof Web.SimpleUser.prototype.connect === "function" &&
            typeof Web.SimpleUser.prototype.disconnect === "function";

          if (isFullyLoaded) {
            clearTimeout(timeoutId);
            debugLog(this.config?.debug || false, "SIP.js library fully loaded and verified");
            resolve();
            return;
          }

          if (Date.now() - startTime > timeout) {
            clearTimeout(timeoutId);
            reject(new Error("SIP.js library verification timeout"));
            return;
          }

          setTimeout(checkLibrary, 100);
        } catch (error) {
          setTimeout(checkLibrary, 200);
        }
      };

      checkLibrary();
    });
  }

  private async ensureSipClient(): Promise<void> {
    if (this.isInitialized) return;

    if (this.isInitializing) {
      return new Promise((resolve, reject) => {
        const checkInterval = setInterval(() => {
          if (this.isInitialized) {
            clearInterval(checkInterval);
            resolve();
          } else if (!this.isInitializing) {
            clearInterval(checkInterval);
            reject(new Error("Initialization failed"));
          }
        }, 100);
      });
    }

    if (!this.config) {
      throw new Error("SIP configuration not set");
    }

    await this.initialize(this.config);
  }

  setConfig(config: SipConfig): void {
    this.config = config;
    debugLog(config.debug || false, "SIP configuration set, will initialize on first use");
  }

  async initialize(config: SipConfig): Promise<void> {
    if (this.isInitializing || this.isInitialized) return;

    this.isInitializing = true;
    this.config = config;

    debugLog(config.debug || false, "Starting lazy SIP initialization");

    try {
      await this.waitForSipLibrary();
      await new Promise((resolve) => setTimeout(resolve, 500));

      const wsProtocol = config.use_secure ? "wss" : "ws";
      const wsPort = config.websocket_port || (config.use_secure ? 443 : 80);
      const wsServer = `${wsProtocol}://${config.server}:${wsPort}`;
      const sipAor = `sip:${config.username}@${config.domain}`;

      debugLog(config.debug || false, "WebSocket URL:", wsServer);
      debugLog(config.debug || false, "SIP AOR:", sipAor);

      const getMediaOptions = (includeVideo: boolean = false) => ({
        constraints: includeVideo
          ? {
              audio: {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true,
              },
              video: {
                width: { ideal: 640 },
                height: { ideal: 480 },
                frameRate: { ideal: 30 },
              },
            }
          : {
              audio: {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true,
              },
              video: false,
            },
        remote: {
          audio: this.remoteAudio!,
          video: this.remoteVideo!,
        },
      });

      const options: SimpleUserOptions = {
        aor: sipAor,
        media: getMediaOptions(false),
        userAgentOptions: {
          authorizationUsername: config.username,
          authorizationPassword: config.password,
          displayName: config.display_name || config.username,
          transportOptions: {
            server: wsServer,
            connectionTimeout: 15,
            maxReconnectionAttempts: 3,
            reconnectionTimeout: 4,
          },
          logLevel: config.debug ? "debug" : "error",
          sessionDescriptionHandlerFactoryOptions: {
            constraints: {
              audio: true,
              video: false,
            },
            peerConnectionConfiguration: {
              iceServers: [
                { urls: "stun:stun.l.google.com:19302" },
                { urls: "stun:stun1.l.google.com:19302" },
                { urls: "stun:stun2.l.google.com:19302" },
                { urls: "stun:stun3.l.google.com:19302" },
              ],
              iceCandidatePoolSize: 10,
              iceTransportPolicy: "all",
              bundlePolicy: "balanced",
              rtcpMuxPolicy: "require",
            },
          },
        },
      };

      if (!Web || !Web.SimpleUser) {
        throw new Error("SIP.js Web.SimpleUser not available after loading");
      }

      this.simpleUser = new Web.SimpleUser(wsServer, options);

      if (!this.simpleUser) {
        throw new Error("Failed to create SimpleUser instance");
      }

      if (!this.simpleUser.register || typeof this.simpleUser.register !== "function") {
        throw new Error("SimpleUser register method not available - library incomplete");
      }

      debugLog(config.debug || false, "SimpleUser created and verified successfully");

      this.setupEventHandlers();

      debugLog(config.debug || false, `Connecting to: ${wsServer}`);
      await this.simpleUser.connect();

      this.isConnected = true;
      this.dispatchEvent(new CustomEvent("connected"));
      debugLog(config.debug || false, "Connected to WebSocket server");

      debugLog(config.debug || false, "Registering with SIP server...");
      await this.simpleUser.register();

      this.isRegistered = true;
      this.dispatchEvent(new CustomEvent("registered", { detail: { registered: true } }));

      this.startConnectionMonitoring();

      this.isInitialized = true;
      this.isInitializing = false;

      debugLog(config.debug || false, "SIP client lazy initialization completed successfully");
    } catch (error) {
      this.isInitializing = false;
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      errorLog("SIP lazy initialization failed:", errorMessage);

      this.isConnected = false;
      this.isRegistered = false;

      if (this.simpleUser) {
        try {
          await this.simpleUser.disconnect();
        } catch (cleanupError) {
          debugLog(config.debug || false, "Cleanup error", cleanupError);
        }
        this.simpleUser = null;
      }

      this.dispatchEvent(
        new CustomEvent("error", {
          detail: {
            error: errorMessage,
            type: "initialization",
          },
        })
      );

      throw new Error(`Failed to initialize SIP client: ${errorMessage}`);
    }
  }

  private setupEventHandlers(): void {
    if (!this.simpleUser) {
      errorLog("Cannot setup event handlers: SimpleUser is null");
      return;
    }

    debugLog(this.config?.debug || false, "Setting up event handlers");

    this.simpleUser.delegate = {
      onCallCreated: () => {
        debugLog(this.config?.debug || false, "Call created");
        this.dispatchEvent(new CustomEvent("callCreated"));
      },

      onCallReceived: () => {
        debugLog(this.config?.debug || false, "Incoming call received");

        const session = this.simpleUser?.session;
        if (!session) {
          debugLog(this.config?.debug || false, "No session found for incoming call");
          return;
        }

        let remoteIdentity = "unknown";
        let displayName = "Unknown Caller";

        try {
          debugLog(this.config?.debug || false, "Current session state:", session.state);

          this.setupRemoteStreamHandlers(session);

          if (session.request) {
            const fromHeader = session.request.getHeader("From");
            debugLog(this.config?.debug || false, "From header:", fromHeader);

            if (fromHeader) {
              const uriMatches = fromHeader.match(/<sip:([^@]+)@/) || fromHeader.match(/sip:([^@]+)@/);
              if (uriMatches && uriMatches[1]) {
                remoteIdentity = uriMatches[1];
                debugLog(this.config?.debug || false, "Extracted extension from From:", remoteIdentity);
              }

              const nameMatches = fromHeader.match(/^"([^"]*)"/) || fromHeader.match(/^([^<]*)</);
              if (nameMatches && nameMatches[1] && nameMatches[1].trim()) {
                displayName = nameMatches[1].trim();
                debugLog(this.config?.debug || false, "Extracted display name:", displayName);
              } else if (remoteIdentity !== "unknown") {
                displayName = remoteIdentity;
              }
            }
          }

          if (remoteIdentity === "unknown" && session.remoteIdentity) {
            debugLog(this.config?.debug || false, "Trying session.remoteIdentity:", session.remoteIdentity);

            if (session.remoteIdentity.uri) {
              const uriString = session.remoteIdentity.uri.toString();
              debugLog(this.config?.debug || false, "Remote URI:", uriString);

              const matches = uriString.match(/sip:([^@]+)@/);
              if (matches && matches[1]) {
                remoteIdentity = matches[1];
                debugLog(this.config?.debug || false, "Extracted from remote URI:", remoteIdentity);
              }
            }

            if (session.remoteIdentity.displayName) {
              displayName = session.remoteIdentity.displayName;
              debugLog(this.config?.debug || false, "Remote display name:", displayName);
            } else if (remoteIdentity !== "unknown") {
              displayName = remoteIdentity;
            }
          }
        } catch (error) {
          debugLog(this.config?.debug || false, "Error parsing caller info:", error);
        }

        debugLog(this.config?.debug || false, "Final parsed caller info:", { remoteIdentity, displayName });

        this.currentCall = {
          id: Date.now().toString(),
          remoteIdentity: remoteIdentity,
          displayName: displayName,
          state: "incoming",
          duration: 0,
        };

        this.dispatchEvent(
          new CustomEvent("incomingCall", {
            detail: {
              from: remoteIdentity,
              displayName: displayName,
              callInfo: this.currentCall,
            },
          })
        );
      },

      onCallAnswered: () => {
        if (this.currentCall) {
          this.currentCall.state = "connected";
          this.currentCall.startTime = new Date();
        }

        debugLog(this.config?.debug || false, "Call answered");

        if (this.simpleUser?.session) {
          const session = this.simpleUser.session;
          this.setupRemoteStreamHandlers(session);

          // Set up session state change listener for incoming calls as well
          session.stateChange.addListener((newState: any) => {
            debugLog(this.config?.debug || false, "Incoming session state changed:", newState);

            switch (newState) {
              case "Terminated":
              case "Ended":
                debugLog(this.config?.debug || false, "Incoming call ended");
                // Stop local media tracks to release camera and microphone
                if (this.localStream) {
                  this.localStream.getTracks().forEach((track) => {
                    try {
                      track.stop();
                      debugLog(this.config?.debug || false, `Stopped local media track on incoming call end: ${track.kind}`);
                    } catch (error) {
                      debugLog(this.config?.debug || false, `Failed to stop track on incoming call end: ${track.kind}`, error);
                    }
                  });
                  this.localStream = null;
                }
                this.videoEnabled = false;
                
                if (this.currentCall) {
                  this.currentCall.state = "ended";
                  this.dispatchEvent(
                    new CustomEvent("callEnded", {
                      detail: { callInfo: this.currentCall },
                    })
                  );
                }
                break;
            }
          });

          // FIXED: Force remote video check for outgoing calls after answer
          setTimeout(() => {
            this.forceRemoteVideoCheck(session);
          }, 500);
        }

        this.dispatchEvent(
          new CustomEvent("callAnswered", {
            detail: { callInfo: this.currentCall },
          })
        );

        this.startCallTimer();
      },

      onCallHangup: () => {
        debugLog(this.config?.debug || false, "Call ended");

        // Stop local media tracks to release camera and microphone
        if (this.localStream) {
          this.localStream.getTracks().forEach((track) => {
            try {
              track.stop();
              debugLog(this.config?.debug || false, `Stopped local media track: ${track.kind}`);
            } catch (error) {
              debugLog(this.config?.debug || false, `Failed to stop track: ${track.kind}`, error);
            }
          });
          this.localStream = null;
        }

        if (this.remoteVideo) {
          this.remoteVideo.srcObject = null;
        }

        if (this.currentCall) {
          this.currentCall.state = "ended";
        }

        this.stopCallTimer();
        this.dispatchEvent(
          new CustomEvent("callEnded", {
            detail: { callInfo: this.currentCall },
          })
        );

        this.currentCall = null;
        this.lastVideoState = false;
        this.videoEnabled = false;
      },

      onCallHold: (held: boolean) => {
        debugLog(this.config?.debug || false, "Call hold state changed", held);
        this.dispatchEvent(
          new CustomEvent("callHold", {
            detail: { held, callInfo: this.currentCall },
          })
        );
      },

      onRegistered: () => {
        this.isRegistered = true;
        debugLog(this.config?.debug || false, "Registration successful");
        this.dispatchEvent(new CustomEvent("registered", { detail: { registered: true } }));
      },

      onUnregistered: () => {
        this.isRegistered = false;
        debugLog(this.config?.debug || false, "Unregistered");
        this.dispatchEvent(new CustomEvent("registered", { detail: { registered: false } }));
      },

      onServerConnect: () => {
        this.isConnected = true;
        debugLog(this.config?.debug || false, "Server connected");
        this.dispatchEvent(new CustomEvent("connected"));
      },

      onServerDisconnect: () => {
        this.isConnected = false;
        this.isRegistered = false;
        debugLog(this.config?.debug || false, "Server disconnected");
        this.dispatchEvent(new CustomEvent("disconnected"));
      },
    };
  }

  private callTimer: number | null = null;

  private startCallTimer(): void {
    this.stopCallTimer();
    this.callTimer = window.setInterval(() => {
      if (this.currentCall && this.currentCall.startTime) {
        this.currentCall.duration = Math.floor((Date.now() - this.currentCall.startTime.getTime()) / 1000);
        this.dispatchEvent(
          new CustomEvent("callTimer", {
            detail: { duration: this.currentCall.duration, callInfo: this.currentCall },
          })
        );
      }
    }, 1000);
  }

  private stopCallTimer(): void {
    if (this.callTimer) {
      clearInterval(this.callTimer);
      this.callTimer = null;
    }
  }

  private startConnectionMonitoring(): void {
    this.connectionTimer = window.setInterval(() => {
      const connected = this.simpleUser?.isConnected() || false;

      if (connected !== this.isConnected) {
        this.isConnected = connected;
        this.dispatchEvent(
          new CustomEvent("heartbeat", {
            detail: {
              connected,
              registered: this.isRegistered,
            },
          })
        );
      }
    }, 5000);
  }

  async makeCall(target: string, includeVideo = true): Promise<void> {
    await this.ensureSipClient();

    if (!this.simpleUser || !this.isRegistered) {
      throw new Error("SIP client not registered");
    }

    if (this.currentCall) {
      throw new Error("Another call is already in progress");
    }

    try {
      const targetUri = `sip:${target}@${this.config!.domain}`;
      debugLog(this.config?.debug || false, "Making VIDEO call to", targetUri, "with video:", includeVideo);

      if (!this.videoEnabled) {
        await this.enableVideo();
      }
      const mediaStream = this.localStream!;

      this.currentCall = {
        id: Date.now().toString(),
        remoteIdentity: target,
        displayName: target,
        state: "outgoing",
        duration: 0,
      };

      const callOptions = {
        sessionDescriptionHandlerOptions: {
          constraints: {
            audio: true,
            video: true,
          },
          offerToReceiveAudio: true,
          offerToReceiveVideo: true,

          iceGatheringTimeout: 10000,
          rtcConfiguration: {
            iceServers: [
              { urls: "stun:stun.l.google.com:19302" },
              { urls: "stun:stun1.l.google.com:19302" },
              { urls: "stun:stun2.l.google.com:19302" },
              { urls: "stun:stun3.l.google.com:19302" },
            ],
            iceCandidatePoolSize: 10,
            iceTransportPolicy: "all",
            bundlePolicy: "balanced",
            rtcpMuxPolicy: "require",
          },
        },
        sessionDescriptionHandlerFactory: (session: any, options: any) => {
          options.localStream = mediaStream;
          options.remote = {
            audio: this.remoteAudio,
            video: this.remoteVideo,
          };

          return session.sessionDescriptionHandlerFactory(session, options);
        },
      };

      await this.simpleUser.call(targetUri, callOptions);

      // FIXED: Enhanced outgoing call session handling
      if (this.simpleUser.session) {
        const session = this.simpleUser.session;
        debugLog(this.config?.debug || false, "Outgoing call session created, state:", session.state);

        // FIXED: Set up handlers immediately for outgoing calls
        this.setupRemoteStreamHandlers(session);

        // FIXED: Listen for all session state changes
        session.stateChange.addListener((newState: any) => {
          debugLog(this.config?.debug || false, "Outgoing session state changed:", newState);

          switch (newState) {
            case "Establishing":
              debugLog(this.config?.debug || false, "Call is establishing, setting up stream handlers");
              this.setupRemoteStreamHandlers(session);
              break;

            case "Established":
              debugLog(this.config?.debug || false, "Call established, ensuring stream handlers");
              setTimeout(() => {
                this.setupRemoteStreamHandlers(session);
                this.forceRemoteVideoCheck(session);
              }, 100);
              break;

            case "Terminated":
            case "Ended":
              debugLog(this.config?.debug || false, "Outgoing call ended");
              // Stop local media tracks to release camera and microphone
              if (this.localStream) {
                this.localStream.getTracks().forEach((track) => {
                  try {
                    track.stop();
                    debugLog(this.config?.debug || false, `Stopped local media track on outgoing call end: ${track.kind}`);
                  } catch (error) {
                    debugLog(this.config?.debug || false, `Failed to stop track on outgoing call end: ${track.kind}`, error);
                  }
                });
                this.localStream = null;
              }
              this.videoEnabled = false;
              
              if (this.currentCall) {
                this.currentCall.state = "ended";
                this.dispatchEvent(
                  new CustomEvent("callEnded", {
                    detail: { callInfo: this.currentCall },
                  })
                );
              }
              break;
          }
        });

        // FIXED: Also listen for session description handler changes
        const checkForSDH = () => {
          if (session.sessionDescriptionHandler) {
            debugLog(this.config?.debug || false, "Session description handler available for outgoing call");
            this.setupRemoteStreamHandlers(session);
          } else {
            setTimeout(checkForSDH, 100);
          }
        };
        checkForSDH();
      }

      this.dispatchEvent(
        new CustomEvent("callStarted", {
          detail: {
            target,
            callInfo: this.currentCall,
            videoEnabled: true,
          },
        })
      );
    } catch (error) {
      errorLog("Call failed", error);
      
      // Stop local media tracks to release camera and microphone
      if (this.localStream) {
        this.localStream.getTracks().forEach((track) => {
          try {
            track.stop();
            debugLog(this.config?.debug || false, `Stopped local media track on call failure: ${track.kind}`);
          } catch (trackError) {
            debugLog(this.config?.debug || false, `Failed to stop track on call failure: ${track.kind}`, trackError);
          }
        });
        this.localStream = null;
      }
      
      this.currentCall = null;
      this.dispatchEvent(
        new CustomEvent("callFailed", {
          detail: {
            error: error instanceof Error ? error.message : "Call failed",
            target,
          },
        })
      );
      throw error;
    }
  }

  private forceRemoteVideoCheck(session: any): void {
    try {
      if (!session || !session.sessionDescriptionHandler) {
        debugLog(this.config?.debug || false, "No session description handler for video check");
        return;
      }

      const pc = session.sessionDescriptionHandler.peerConnection;
      if (!pc) {
        debugLog(this.config?.debug || false, "No peer connection for video check");
        return;
      }

      debugLog(this.config?.debug || false, "Forcing remote video check, connection state:", pc.connectionState);

      // Check for remote streams
      const remoteStreams = pc.getRemoteStreams ? pc.getRemoteStreams() : [];
      debugLog(this.config?.debug || false, "Remote streams found:", remoteStreams.length);

      if (remoteStreams.length > 0) {
        const remoteStream = remoteStreams[0];
        const videoTracks = remoteStream.getVideoTracks();

        debugLog(this.config?.debug || false, "Found remote stream with video tracks:", videoTracks.length);

        if (videoTracks.length > 0 && this.remoteVideo) {
          this.remoteVideo.srcObject = remoteStream;
          this.remoteVideo.autoplay = true;
          this.remoteVideo.playsInline = true;

          const playPromise = this.remoteVideo.play();
          if (playPromise !== undefined) {
            playPromise.catch((error) => {
              debugLog(this.config?.debug || false, "Remote video play failed:", error);
              // Try to handle the error by re-attaching the stream
              if (this.remoteVideo && this.remoteVideo.srcObject) {
                const currentStream = this.remoteVideo.srcObject;
                this.remoteVideo.srcObject = null;
                this.remoteVideo.srcObject = currentStream;
                setTimeout(() => {
                  if (this.remoteVideo && this.remoteVideo.srcObject) {
                    const retryPromise = this.remoteVideo.play();
                    if (retryPromise !== undefined) {
                      retryPromise.catch((retryError) => {
                        debugLog(this.config?.debug || false, "Remote video play retry failed:", retryError);
                      });
                    }
                  }
                }, 100);
              }
            });
          }

          const hasActiveVideo = videoTracks.some((track: any) => track.enabled && track.readyState === "live");

          this.dispatchEvent(
            new CustomEvent("remoteVideoChanged", {
              detail: {
                enabled: true,
                stream: remoteStream,
                hasVideoTracks: hasActiveVideo,
              },
            })
          );
        }
      }

      // Also check transceivers
      const transceivers = pc.getTransceivers();
      debugLog(this.config?.debug || false, "Checking transceivers for outgoing call:", transceivers.length);

      transceivers.forEach((transceiver: RTCRtpTransceiver, index: number) => {
        if (transceiver.receiver?.track?.kind === "video" && transceiver.receiver.track.readyState === "live") {
          debugLog(this.config?.debug || false, `Found active video transceiver ${index} for outgoing call`);

          if (this.remoteVideo && !this.remoteVideo.srcObject) {
            const videoStream = new MediaStream([transceiver.receiver.track]);
            this.remoteVideo.srcObject = videoStream;
            this.remoteVideo.autoplay = true;
            this.remoteVideo.playsInline = true;

            // Handle video play with better error handling
            if (this.remoteVideo.srcObject) {
              const playPromise = this.remoteVideo.play();
              if (playPromise !== undefined) {
                playPromise
                  .then(() => {
                    debugLog(this.config?.debug || false, "Transceiver video playing successfully");
                  })
                  .catch((error) => {
                    debugLog(this.config?.debug || false, "Transceiver video play failed:", error);
                    // Try to handle the error by re-attaching the stream
                    if (this.remoteVideo && this.remoteVideo.srcObject) {
                      const currentStream = this.remoteVideo.srcObject;
                      this.remoteVideo.srcObject = null;
                      this.remoteVideo.srcObject = currentStream;
                      // Add a small delay before retrying to avoid race conditions
                      setTimeout(() => {
                        if (this.remoteVideo && this.remoteVideo.srcObject) {
                          // Check if the video element is in a playable state
                          if (this.remoteVideo.readyState >= 2) { // HAVE_CURRENT_DATA
                            const retryPromise = this.remoteVideo.play();
                            if (retryPromise !== undefined) {
                              retryPromise.catch((retryError) => {
                                debugLog(this.config?.debug || false, "Transceiver video play retry failed:", retryError);
                              });
                            }
                          } else {
                            // If not ready, wait a bit more
                            setTimeout(() => {
                              if (this.remoteVideo && this.remoteVideo.srcObject) {
                                const retryPromise = this.remoteVideo.play();
                                if (retryPromise !== undefined) {
                                  retryPromise.catch((retryError) => {
                                    debugLog(this.config?.debug || false, "Delayed transceiver video play retry failed:", retryError);
                                  });
                                }
                              }
                            }, 200);
                          }
                        }
                      }, 150);
                    }
                  });
              }
            }

            this.dispatchEvent(
              new CustomEvent("remoteVideoChanged", {
                detail: {
                  enabled: true,
                  stream: videoStream,
                  hasVideoTracks: true,
                },
              })
            );
          }
        }
      });
    } catch (error) {
      debugLog(this.config?.debug || false, "Force remote video check failed:", error);
    }
  }

  async answerCall(): Promise<void> {
    await this.ensureSipClient();

    if (!this.simpleUser) {
      throw new Error("SIP client not available");
    }

    const session = this.simpleUser.session;
    if (!session) {
      throw new Error("No session available to answer");
    }

    if (!this.currentCall || this.currentCall.state !== "incoming") {
      throw new Error("No incoming call to answer");
    }

    const sessionState = session.state;
    debugLog(this.config?.debug || false, "Attempting to answer call, session state:", sessionState);

    if (sessionState === "Terminated" || sessionState === "Ended") {
      throw new Error("Call has already ended");
    }

    if (sessionState !== "Initial") {
      throw new Error(`Cannot answer call in state: ${sessionState}`);
    }

    try {
      if (!this.videoEnabled) {
        await this.enableVideo();
      }
      const mediaStream = this.localStream!;

      const answerOptions = {
        sessionDescriptionHandlerOptions: {
          constraints: {
            audio: true,
            video: true,
          },
          rtcConfiguration: {
            iceServers: [
              { urls: "stun:stun.l.google.com:19302" },
              { urls: "stun:stun1.l.google.com:19302" },
              { urls: "stun:stun2.l.google.com:19302" },
              { urls: "stun:stun3.l.google.com:19302" },
            ],
            iceCandidatePoolSize: 10,
            iceTransportPolicy: "all",
            bundlePolicy: "balanced",
            rtcpMuxPolicy: "require",
          },
        },
        sessionDescriptionHandlerFactory: (session: any, options: any) => {
          options.localStream = mediaStream;
          return session.sessionDescriptionHandlerFactory(session, options);
        },
      };

      await this.simpleUser.answer(answerOptions);
      debugLog(this.config?.debug || false, "Call answered with video:", this.videoEnabled);

      if (this.simpleUser.session) {
        this.setupRemoteStreamHandlers(this.simpleUser.session);
      }
    } catch (error) {
      errorLog("Answer call failed", error);
      // Stop any media tracks that might have been started during the failed attempt
      if (this.localStream) {
        this.localStream.getTracks().forEach((track) => {
          try {
            track.stop();
            debugLog(this.config?.debug || false, `Stopped local media track on answer failure: ${track.kind}`);
          } catch (trackError) {
            debugLog(this.config?.debug || false, `Failed to stop track on answer failure: ${track.kind}`, trackError);
          }
        });
        this.localStream = null;
      }
      throw error;
    }
  }

  async rejectCall(): Promise<void> {
    await this.ensureSipClient();

    if (!this.simpleUser) {
      throw new Error("SIP client not available");
    }

    try {
      await this.simpleUser.decline();

      if (this.currentCall) {
        this.currentCall.state = "ended";
      }

      this.currentCall = null;
      debugLog(this.config?.debug || false, "Call rejected");
    } catch (error) {
      errorLog("Reject call failed", error);
      throw error;
    }
  }

  async hangup(): Promise<void> {
    if (!this.simpleUser) return;

    try {
      await this.simpleUser.hangup();
      debugLog(this.config?.debug || false, "Call hung up");
    } catch (error) {
      errorLog("Hangup failed", error);
      throw error;
    }
  }

  async mute(): Promise<void> {
    if (!this.simpleUser) return;

    try {
      await this.simpleUser.mute();
      debugLog(this.config?.debug || false, "Call muted");
    } catch (error) {
      errorLog("Mute failed", error);
      throw error;
    }
  }

  async unmute(): Promise<void> {
    if (!this.simpleUser) return;

    try {
      await this.simpleUser.unmute();
      debugLog(this.config?.debug || false, "Call unmuted");
    } catch (error) {
      errorLog("Unmute failed", error);
      throw error;
    }
  }

  sendDTMF(tone: string): void {
    if (!this.simpleUser || !this.currentCall) return;

    try {
      if (typeof this.simpleUser.sendDTMF === "function") {
        this.simpleUser.sendDTMF(tone);
        debugLog(this.config?.debug || false, "DTMF sent", tone);

        this.dispatchEvent(
          new CustomEvent("dtmfSent", {
            detail: { tone, callInfo: this.currentCall },
          })
        );
      }
    } catch (error) {
      errorLog("DTMF send failed", error);
    }
  }

  getRemoteVideo(): HTMLVideoElement | null {
    return this.remoteVideo;
  }

  getRemoteAudio(): HTMLAudioElement | null {
    return this.remoteAudio;
  }

  getCurrentCall(): CallInfo | null {
    return this.currentCall;
  }

  getConnectionStatus(): { connected: boolean; registered: boolean; initialized: boolean } {
    return {
      connected: this.isConnected,
      registered: this.isRegistered,
      initialized: this.isInitialized,
    };
  }

  async connect(): Promise<void> {
    await this.ensureSipClient();
  }

  async disconnect(): Promise<void> {
    if (this.connectionTimer) {
      clearInterval(this.connectionTimer);
      this.connectionTimer = null;
    }

    this.stopCallTimer();

    if (this.simpleUser) {
      try {
        if (this.currentCall) {
          await this.hangup();
        }

        if (this.isRegistered) {
          await this.simpleUser.unregister();
        }

        if (this.isConnected) {
          await this.simpleUser.disconnect();
        }
      } catch (error) {
        errorLog("Disconnect error", error);
      }

      this.simpleUser = null;
    }

    try {
      if (this.localStream) {
        this.localStream.getTracks().forEach((track) => track.stop());
        this.localStream = null;
      }

      if (this.localVideo && this.localVideo.parentNode) {
        this.localVideo.pause();
        this.localVideo.srcObject = null;
        this.localVideo.parentNode.removeChild(this.localVideo);
        this.localVideo = null;
      }

      if (this.remoteVideo && this.remoteVideo.parentNode) {
        this.remoteVideo.pause();
        this.remoteVideo.srcObject = null;
        this.remoteVideo.parentNode.removeChild(this.remoteVideo);
        this.remoteVideo = null;
      }

      this.videoEnabled = false;

      if (this.remoteAudio && this.remoteAudio.parentNode) {
        this.remoteAudio.pause();
        this.remoteAudio.srcObject = null;
        this.remoteAudio.parentNode.removeChild(this.remoteAudio);
        this.remoteAudio = null;
      }
    } catch (error) {
      errorLog("Error cleaning up media resources:", error);
    }

    this.isConnected = false;
    this.isRegistered = false;
    this.isInitialized = false;
    this.isInitializing = false;
    this.currentCall = null;

    debugLog(this.config?.debug || false, "SIP client disconnected");
  }
}

---

=== Object: ae2f332969d290e8701998981441e9c0d6c3ea4f | Date: 2025-09-23 15:32:13 | Type: blob ===

import { debugLog, errorLog } from "./utils";

type SimpleUser = any;
type SimpleUserOptions = any;
let Web: any = null;

export interface SipConfig {
  server: string;
  username: string;
  password: string;
  domain: string;
  websocket_port: number;
  use_secure: boolean;
  display_name?: string;
  debug?: boolean;
}

export interface CallInfo {
  id: string;
  remoteIdentity: string;
  displayName: string;
  state: "incoming" | "outgoing" | "connected" | "ended";
  startTime?: Date;
  duration: number;
}

export class SipManager extends EventTarget {
  private simpleUser: SimpleUser | null = null;
  private config: SipConfig | null = null;
  private isRegistered = false;
  private isConnected = false;
  private connectionTimer: number | null = null;
  private currentCall: CallInfo | null = null;
  private remoteAudio: HTMLAudioElement | null = null;
  private remoteVideo: HTMLVideoElement | null = null;
  private localVideo: HTMLVideoElement | null = null;
  private localStream: MediaStream | null = null;
  private videoEnabled = false;
  private isInitialized = false;
  private isInitializing = false;
  private lastVideoState = false;

  constructor() {
    super();
    this.setupMediaElements();
  }

  private setupMediaElements(): void {
    this.remoteAudio = document.createElement("audio");
    this.remoteAudio.autoplay = true;
    this.remoteAudio.style.display = "none";
    document.body.appendChild(this.remoteAudio);

    this.remoteVideo = document.createElement("video");
    this.remoteVideo.autoplay = true;
    this.remoteVideo.playsInline = true;
    this.remoteVideo.style.display = "none";
    document.body.appendChild(this.remoteVideo);

    this.localVideo = document.createElement("video");
    this.localVideo.autoplay = true;
    this.localVideo.muted = true;
    this.localVideo.playsInline = true;
    this.localVideo.style.display = "none";
    document.body.appendChild(this.localVideo);
  }

  private async getUserMedia(includeVideo: boolean = false): Promise<MediaStream> {
    const constraints: MediaStreamConstraints = {
      audio: {
        echoCancellation: true,
        noiseSuppression: true,
        autoGainControl: true,
        sampleRate: 48000,
      },
      video: includeVideo
        ? {
            width: { ideal: 640, min: 320, max: 1280 },
            height: { ideal: 480, min: 240, max: 720 },
            frameRate: { ideal: 30, min: 15, max: 30 },
            facingMode: "user",
          }
        : false,
    };

    return navigator.mediaDevices.getUserMedia(constraints);
  }

  public async enableVideo(): Promise<void> {
    try {
      const stream = await this.getUserMedia(true);

      if (this.localStream) {
        this.localStream.getTracks().forEach((track) => track.stop());
      }

      if (this.localVideo) {
        this.localVideo.srcObject = stream;
      }

      this.localStream = stream;
      this.videoEnabled = true;

      debugLog(this.config?.debug || false, "Local video enabled with new stream:", {
        videoTracks: stream.getVideoTracks().length,
        audioTracks: stream.getAudioTracks().length,
        streamId: stream.id,
      });

      if (this.simpleUser?.session && this.currentCall?.state === "connected") {
        await this.replaceMediaTracks(stream);
      }

      this.dispatchEvent(
        new CustomEvent("localVideoChanged", {
          detail: {
            enabled: true,
            transmitting: stream.getVideoTracks().some((track) => track.enabled && track.readyState === "live"),
          },
        })
      );
    } catch (error) {
      errorLog("Enable video failed", error);
      this.videoEnabled = false;
      throw error;
    }
  }

  public async disableVideo(): Promise<void> {
    try {
      const audioOnlyStream = await this.getUserMedia(false);

      if (this.localVideo) {
        this.localVideo.srcObject = null;
      }

      if (this.localStream) {
        this.localStream.getTracks().forEach((track) => {
          track.stop();
          debugLog(this.config?.debug || false, `Stopped ${track.kind} track:`, track.id);
        });
      }

      this.localStream = audioOnlyStream;
      this.videoEnabled = false;

      debugLog(this.config?.debug || false, "Local video disabled, using audio-only stream:", {
        videoTracks: audioOnlyStream.getVideoTracks().length,
        audioTracks: audioOnlyStream.getAudioTracks().length,
        streamId: audioOnlyStream.id,
      });

      if (this.simpleUser?.session && this.currentCall?.state === "connected") {
        await this.replaceMediaTracks(audioOnlyStream);
      }

      this.dispatchEvent(
        new CustomEvent("localVideoChanged", {
          detail: {
            enabled: false,
            transmitting: false,
          },
        })
      );
    } catch (error) {
      errorLog("Disable video failed", error);
      throw error;
    }
  }

  private async replaceMediaTracks(newStream: MediaStream): Promise<void> {
    try {
      const session = this.simpleUser?.session;
      if (!session || !session.sessionDescriptionHandler) {
        debugLog(this.config?.debug || false, "No active session to replace tracks");
        return;
      }

      const pc = session.sessionDescriptionHandler.peerConnection;
      if (!pc) {
        debugLog(this.config?.debug || false, "No peer connection found");
        return;
      }

      const senders = pc.getSenders();

      const audioTrack = newStream.getAudioTracks()[0];
      const audioSender = senders.find((sender: any) => sender.track && sender.track.kind === "audio");
      if (audioSender && audioTrack) {
        await audioSender.replaceTrack(audioTrack);
        debugLog(this.config?.debug || false, "Audio track replaced successfully");
      }

      const videoTrack = newStream.getVideoTracks()[0] || null;
      const videoSender = senders.find((sender: any) => sender.track && sender.track.kind === "video");

      if (videoSender) {
        await videoSender.replaceTrack(videoTrack);
        debugLog(this.config?.debug || false, videoTrack ? "Video track replaced" : "Video track removed from sender");
      } else if (videoTrack) {
        try {
          pc.addTrack(videoTrack, newStream);
          debugLog(this.config?.debug || false, "Video track added to peer connection");

          if (session.sessionDescriptionHandler && typeof session.sessionDescriptionHandler.sendReinvite === "function") {
            await session.sessionDescriptionHandler.sendReinvite();
            debugLog(this.config?.debug || false, "Session renegotiated for new video track");
          }
        } catch (error) {
          debugLog(this.config?.debug || false, "Failed to add video track:", error);
        }
      }
    } catch (error) {
      debugLog(this.config?.debug || false, "Replace media tracks failed but call continues:", error);
    }
  }

  public async toggleVideo(): Promise<boolean> {
    try {
      if (this.videoEnabled) {
        await this.disableVideo();
        return false;
      } else {
        await this.enableVideo();
        return true;
      }
    } catch (error) {
      errorLog("Toggle video failed", error);
      throw error;
    }
  }

  public getLocalVideoState(): { enabled: boolean; transmitting: boolean } {
    return {
      enabled: this.videoEnabled,
      transmitting: this.localStream ? this.localStream.getVideoTracks().some((track) => track.enabled && track.readyState === "live") : false,
    };
  }

  private setupRemoteStreamHandlers(session: any): void {
    try {
      const sessionDescriptionHandler = session.sessionDescriptionHandler;
      if (!sessionDescriptionHandler) {
        debugLog(this.config?.debug || false, "No session description handler");
        return;
      }

      const pc = sessionDescriptionHandler.peerConnection;
      if (!pc) {
        debugLog(this.config?.debug || false, "No peer connection");
        return;
      }

      debugLog(this.config?.debug || false, "Setting up remote stream handlers for", pc.connectionState);

      pc.ontrack = (event: RTCTrackEvent) => {
        debugLog(this.config?.debug || false, "Remote track received:", {
          kind: event.track.kind,
          readyState: event.track.readyState,
          enabled: event.track.enabled,
          streams: event.streams.length,
          transceiver: event.transceiver.direction,
        });

        const stream = event.streams[0];
        if (!stream) {
          debugLog(this.config?.debug || false, "No stream in track event");
          return;
        }

        if (event.track.kind === "audio") {
          if (this.remoteAudio) {
            this.remoteAudio.srcObject = stream;
            debugLog(this.config?.debug || false, "Remote audio stream attached");
          }
        } else if (event.track.kind === "video") {
          if (this.remoteVideo) {
            this.remoteVideo.srcObject = stream;
            this.remoteVideo.autoplay = true;
            this.remoteVideo.playsInline = true;

            debugLog(this.config?.debug || false, "Remote video stream attached, playing...");

            // Handle video play with better error handling
            if (this.remoteVideo.srcObject) {
              const playPromise = this.remoteVideo.play();
              if (playPromise !== undefined) {
                playPromise
                  .then(() => {
                    debugLog(this.config?.debug || false, "Remote video playing successfully");
                  })
                  .catch((error) => {
                    debugLog(this.config?.debug || false, "Remote video play failed:", error);
                    
                    // Handle specific error types
                    if (error.name === "NotAllowedError") {
                      debugLog(this.config?.debug || false, "Video play not allowed, likely due to autoplay restrictions");
                      
                      // Try to handle autoplay restrictions by muting and retrying
                      if (this.remoteVideo) {
                        this.remoteVideo.muted = true;
                        const retryPromise = this.remoteVideo.play();
                        if (retryPromise !== undefined) {
                          retryPromise.catch((retryError) => {
                            debugLog(this.config?.debug || false, "Muted video play retry failed:", retryError);
                            
                            // Last resort: re-attach the stream
                            if (this.remoteVideo && this.remoteVideo.srcObject) {
                              const currentStream = this.remoteVideo.srcObject;
                              this.remoteVideo.srcObject = null;
                              this.remoteVideo.srcObject = currentStream;
                              setTimeout(() => {
                                if (this.remoteVideo && this.remoteVideo.srcObject) {
                                  this.remoteVideo.muted = true;
                                  const finalPromise = this.remoteVideo.play();
                                  if (finalPromise !== undefined) {
                                    finalPromise.catch((finalError) => {
                                      debugLog(this.config?.debug || false, "Final video play attempt failed:", finalError);
                                    });
                                  }
                                }
                              }, 100);
                            }
                          });
                        }
                      }
                                      } else if (error.name === "AbortError") {
                    debugLog(this.config?.debug || false, "Video play was interrupted, this is normal during stream updates");
                    
                    // Retry after a short delay, but be more careful about the timing
                    setTimeout(() => {
                      if (this.remoteVideo && this.remoteVideo.srcObject) {
                        // Check if the video element is in a playable state
                        if (this.remoteVideo.readyState >= 2) { // HAVE_CURRENT_DATA
                          const retryPromise = this.remoteVideo.play();
                          if (retryPromise !== undefined) {
                            retryPromise.catch((retryError) => {
                              debugLog(this.config?.debug || false, "Video play retry failed:", retryError);
                            });
                          }
                        } else {
                          // If not ready, wait a bit more
                          setTimeout(() => {
                            if (this.remoteVideo && this.remoteVideo.srcObject) {
                              const retryPromise = this.remoteVideo.play();
                              if (retryPromise !== undefined) {
                                retryPromise.catch((retryError) => {
                                  debugLog(this.config?.debug || false, "Delayed video play retry failed:", retryError);
                                });
                              }
                            }
                          }, 200);
                        }
                      }
                    }, 150);
                    } else {
                      // Try to handle other errors by re-attaching the stream
                      if (this.remoteVideo && this.remoteVideo.srcObject) {
                        const currentStream = this.remoteVideo.srcObject;
                        this.remoteVideo.srcObject = null;
                        this.remoteVideo.srcObject = currentStream;
                        setTimeout(() => {
                          if (this.remoteVideo && this.remoteVideo.srcObject) {
                            const retryPromise = this.remoteVideo.play();
                            if (retryPromise !== undefined) {
                              retryPromise.catch((retryError) => {
                                debugLog(this.config?.debug || false, "Remote video play retry failed:", retryError);
                              });
                            }
                          }
                        }, 100);
                      }
                    }
                  });
              }
            }

            const videoTracks = stream.getVideoTracks();
            const hasActiveVideo = videoTracks.length > 0 && videoTracks.some((track) => track.enabled);

            debugLog(this.config?.debug || false, "Video track details:", {
              trackCount: videoTracks.length,
              hasActive: hasActiveVideo,
              trackStates: videoTracks.map((t) => ({
                id: t.id,
                enabled: t.enabled,
                readyState: t.readyState,
                label: t.label,
              })),
            });

            this.lastVideoState = hasActiveVideo;

            this.dispatchEvent(
              new CustomEvent("remoteVideoChanged", {
                detail: {
                  enabled: true,
                  stream: stream,
                  hasVideoTracks: hasActiveVideo,
                },
              })
            );

            setTimeout(() => {
              this.dispatchEvent(
                new CustomEvent("remoteVideoChanged", {
                  detail: {
                    enabled: true,
                    stream: stream,
                    hasVideoTracks: hasActiveVideo,
                  },
                })
              );
            }, 200);
          }
        }
      };

      pc.oniceconnectionstatechange = () => {
        debugLog(this.config?.debug || false, "ICE connection state changed:", pc.iceConnectionState);

        if (pc.iceConnectionState === "failed") {
          errorLog("ICE connection failed - attempting to recover");
          this.handleIceConnectionFailure(pc);
        }
      };

      pc.onicegatheringstatechange = () => {
        debugLog(this.config?.debug || false, "ICE gathering state changed:", pc.iceGatheringState);
      };

      pc.onicecandidate = (event: RTCPeerConnectionIceEvent) => {
        if (event.candidate) {
          debugLog(this.config?.debug || false, "ICE candidate:", event.candidate.type, event.candidate.candidate);
        } else {
          debugLog(this.config?.debug || false, "ICE gathering complete");
        }
      };

      pc.onconnectionstatechange = () => {
        debugLog(this.config?.debug || false, "Connection state changed:", pc.connectionState);

        if (pc.connectionState === "failed") {
          errorLog("Peer connection failed completely");
          this.handleConnectionFailure();
        } else if (pc.connectionState === "connected") {
          setTimeout(() => {
            const transceivers = pc.getTransceivers();
            debugLog(this.config?.debug || false, "Checking transceivers:", transceivers.length);

            transceivers.forEach((transceiver: RTCRtpTransceiver, index: number) => {
              debugLog(this.config?.debug || false, `Transceiver ${index}:`, {
                direction: transceiver.direction,
                kind: transceiver.receiver?.track?.kind,
                trackState: transceiver.receiver?.track?.readyState,
                hasTrack: !!transceiver.receiver?.track,
              });

              if (transceiver.receiver?.track?.kind === "video" && transceiver.receiver.track.readyState === "live") {
                debugLog(this.config?.debug || false, "Found active video transceiver");

                let videoStream: MediaStream;
                if (this.remoteVideo?.srcObject instanceof MediaStream) {
                  videoStream = this.remoteVideo.srcObject;
                } else {
                  videoStream = new MediaStream([transceiver.receiver.track]);
                  if (this.remoteVideo) {
                    this.remoteVideo.srcObject = videoStream;
                  }
                }

                this.dispatchEvent(
                  new CustomEvent("remoteVideoChanged", {
                    detail: {
                      enabled: true,
                      stream: videoStream,
                      hasVideoTracks: true,
                    },
                  })
                );
              }
            });
          }, 500);
        }
      };

      pc.onremovetrack = (event: RTCTrackEvent) => {
        debugLog(this.config?.debug || false, "Remote track removed:", event.track.kind);

        if (event.track.kind === "video" && this.remoteVideo) {
          this.remoteVideo.srcObject = null;
          this.lastVideoState = false;

          this.dispatchEvent(
            new CustomEvent("remoteVideoChanged", {
              detail: {
                enabled: false,
                stream: null,
                hasVideoTracks: false,
              },
            })
          );
        }
      };
    } catch (error) {
      errorLog("Failed to setup remote stream handlers:", error);
    }
  }

  private handleIceConnectionFailure(pc: RTCPeerConnection): void {
    debugLog(this.config?.debug || false, "Attempting ICE restart");

    setTimeout(() => {
      if (pc.iceConnectionState === "failed") {
        try {
          pc.restartIce();
          debugLog(this.config?.debug || false, "ICE restart initiated");
        } catch (error) {
          errorLog("ICE restart failed:", error);
        }
      }
    }, 1000);
  }

  private handleConnectionFailure(): void {
    errorLog("Connection failed - notifying UI");

    this.dispatchEvent(
      new CustomEvent("error", {
        detail: {
          error: "Connection failed - check network and STUN servers",
          type: "connection_failure",
        },
      })
    );
  }

  private async waitForSipLibrary(timeout = 15000): Promise<void> {
    return new Promise<void>(async (resolve, reject) => {
      const startTime = Date.now();
      const timeoutId = setTimeout(() => {
        reject(new Error(`SIP.js library loading timeout after ${timeout}ms`));
      }, timeout);

      const checkLibrary = async () => {
        try {
          if (!Web) {
            const SIP = await import("sip.js");
            Web = (SIP as any).Web || SIP;
          }

          const isFullyLoaded =
            Web &&
            Web.SimpleUser &&
            Web.SimpleUser.prototype &&
            typeof Web.SimpleUser.prototype.register === "function" &&
            typeof Web.SimpleUser.prototype.connect === "function" &&
            typeof Web.SimpleUser.prototype.disconnect === "function";

          if (isFullyLoaded) {
            clearTimeout(timeoutId);
            debugLog(this.config?.debug || false, "SIP.js library fully loaded and verified");
            resolve();
            return;
          }

          if (Date.now() - startTime > timeout) {
            clearTimeout(timeoutId);
            reject(new Error("SIP.js library verification timeout"));
            return;
          }

          setTimeout(checkLibrary, 100);
        } catch (error) {
          setTimeout(checkLibrary, 200);
        }
      };

      checkLibrary();
    });
  }

  private async ensureSipClient(): Promise<void> {
    if (this.isInitialized) return;

    if (this.isInitializing) {
      return new Promise((resolve, reject) => {
        const checkInterval = setInterval(() => {
          if (this.isInitialized) {
            clearInterval(checkInterval);
            resolve();
          } else if (!this.isInitializing) {
            clearInterval(checkInterval);
            reject(new Error("Initialization failed"));
          }
        }, 100);
      });
    }

    if (!this.config) {
      throw new Error("SIP configuration not set");
    }

    await this.initialize(this.config);
  }

  setConfig(config: SipConfig): void {
    this.config = config;
    debugLog(config.debug || false, "SIP configuration set, will initialize on first use");
  }

  async initialize(config: SipConfig): Promise<void> {
    if (this.isInitializing || this.isInitialized) return;

    this.isInitializing = true;
    this.config = config;

    debugLog(config.debug || false, "Starting lazy SIP initialization");

    try {
      await this.waitForSipLibrary();
      await new Promise((resolve) => setTimeout(resolve, 500));

      const wsProtocol = config.use_secure ? "wss" : "ws";
      const wsPort = config.websocket_port || (config.use_secure ? 443 : 80);
      const wsServer = `${wsProtocol}://${config.server}:${wsPort}`;
      const sipAor = `sip:${config.username}@${config.domain}`;

      debugLog(config.debug || false, "WebSocket URL:", wsServer);
      debugLog(config.debug || false, "SIP AOR:", sipAor);

      const getMediaOptions = (includeVideo: boolean = false) => ({
        constraints: includeVideo
          ? {
              audio: {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true,
              },
              video: {
                width: { ideal: 640 },
                height: { ideal: 480 },
                frameRate: { ideal: 30 },
              },
            }
          : {
              audio: {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true,
              },
              video: false,
            },
        remote: {
          audio: this.remoteAudio!,
          video: this.remoteVideo!,
        },
      });

      const options: SimpleUserOptions = {
        aor: sipAor,
        media: getMediaOptions(false),
        userAgentOptions: {
          authorizationUsername: config.username,
          authorizationPassword: config.password,
          displayName: config.display_name || config.username,
          transportOptions: {
            server: wsServer,
            connectionTimeout: 15,
            maxReconnectionAttempts: 3,
            reconnectionTimeout: 4,
          },
          logLevel: config.debug ? "debug" : "error",
          sessionDescriptionHandlerFactoryOptions: {
            constraints: {
              audio: true,
              video: false,
            },
            peerConnectionConfiguration: {
              iceServers: [
                { urls: "stun:stun.l.google.com:19302" },
                { urls: "stun:stun1.l.google.com:19302" },
                { urls: "stun:stun2.l.google.com:19302" },
                { urls: "stun:stun3.l.google.com:19302" },
              ],
              iceCandidatePoolSize: 10,
              iceTransportPolicy: "all",
              bundlePolicy: "balanced",
              rtcpMuxPolicy: "require",
            },
          },
        },
      };

      if (!Web || !Web.SimpleUser) {
        throw new Error("SIP.js Web.SimpleUser not available after loading");
      }

      this.simpleUser = new Web.SimpleUser(wsServer, options);

      if (!this.simpleUser) {
        throw new Error("Failed to create SimpleUser instance");
      }

      if (!this.simpleUser.register || typeof this.simpleUser.register !== "function") {
        throw new Error("SimpleUser register method not available - library incomplete");
      }

      debugLog(config.debug || false, "SimpleUser created and verified successfully");

      this.setupEventHandlers();

      debugLog(config.debug || false, `Connecting to: ${wsServer}`);
      await this.simpleUser.connect();

      this.isConnected = true;
      this.dispatchEvent(new CustomEvent("connected"));
      debugLog(config.debug || false, "Connected to WebSocket server");

      debugLog(config.debug || false, "Registering with SIP server...");
      await this.simpleUser.register();

      this.isRegistered = true;
      this.dispatchEvent(new CustomEvent("registered", { detail: { registered: true } }));

      this.startConnectionMonitoring();

      this.isInitialized = true;
      this.isInitializing = false;

      debugLog(config.debug || false, "SIP client lazy initialization completed successfully");
    } catch (error) {
      this.isInitializing = false;
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      errorLog("SIP lazy initialization failed:", errorMessage);

      this.isConnected = false;
      this.isRegistered = false;

      if (this.simpleUser) {
        try {
          await this.simpleUser.disconnect();
        } catch (cleanupError) {
          debugLog(config.debug || false, "Cleanup error", cleanupError);
        }
        this.simpleUser = null;
      }

      this.dispatchEvent(
        new CustomEvent("error", {
          detail: {
            error: errorMessage,
            type: "initialization",
          },
        })
      );

      throw new Error(`Failed to initialize SIP client: ${errorMessage}`);
    }
  }

  private setupEventHandlers(): void {
    if (!this.simpleUser) {
      errorLog("Cannot setup event handlers: SimpleUser is null");
      return;
    }

    debugLog(this.config?.debug || false, "Setting up event handlers");

    this.simpleUser.delegate = {
      onCallCreated: () => {
        debugLog(this.config?.debug || false, "Call created");
        this.dispatchEvent(new CustomEvent("callCreated"));
      },

      onCallReceived: () => {
        debugLog(this.config?.debug || false, "Incoming call received");

        const session = this.simpleUser?.session;
        if (!session) {
          debugLog(this.config?.debug || false, "No session found for incoming call");
          return;
        }

        let remoteIdentity = "unknown";
        let displayName = "Unknown Caller";

        try {
          debugLog(this.config?.debug || false, "Current session state:", session.state);

          this.setupRemoteStreamHandlers(session);

          if (session.request) {
            const fromHeader = session.request.getHeader("From");
            debugLog(this.config?.debug || false, "From header:", fromHeader);

            if (fromHeader) {
              const uriMatches = fromHeader.match(/<sip:([^@]+)@/) || fromHeader.match(/sip:([^@]+)@/);
              if (uriMatches && uriMatches[1]) {
                remoteIdentity = uriMatches[1];
                debugLog(this.config?.debug || false, "Extracted extension from From:", remoteIdentity);
              }

              const nameMatches = fromHeader.match(/^"([^"]*)"/) || fromHeader.match(/^([^<]*)</);
              if (nameMatches && nameMatches[1] && nameMatches[1].trim()) {
                displayName = nameMatches[1].trim();
                debugLog(this.config?.debug || false, "Extracted display name:", displayName);
              } else if (remoteIdentity !== "unknown") {
                displayName = remoteIdentity;
              }
            }
          }

          if (remoteIdentity === "unknown" && session.remoteIdentity) {
            debugLog(this.config?.debug || false, "Trying session.remoteIdentity:", session.remoteIdentity);

            if (session.remoteIdentity.uri) {
              const uriString = session.remoteIdentity.uri.toString();
              debugLog(this.config?.debug || false, "Remote URI:", uriString);

              const matches = uriString.match(/sip:([^@]+)@/);
              if (matches && matches[1]) {
                remoteIdentity = matches[1];
                debugLog(this.config?.debug || false, "Extracted from remote URI:", remoteIdentity);
              }
            }

            if (session.remoteIdentity.displayName) {
              displayName = session.remoteIdentity.displayName;
              debugLog(this.config?.debug || false, "Remote display name:", displayName);
            } else if (remoteIdentity !== "unknown") {
              displayName = remoteIdentity;
            }
          }
        } catch (error) {
          debugLog(this.config?.debug || false, "Error parsing caller info:", error);
        }

        debugLog(this.config?.debug || false, "Final parsed caller info:", { remoteIdentity, displayName });

        this.currentCall = {
          id: Date.now().toString(),
          remoteIdentity: remoteIdentity,
          displayName: displayName,
          state: "incoming",
          duration: 0,
        };

        this.dispatchEvent(
          new CustomEvent("incomingCall", {
            detail: {
              from: remoteIdentity,
              displayName: displayName,
              callInfo: this.currentCall,
            },
          })
        );
      },

      onCallAnswered: () => {
        if (this.currentCall) {
          this.currentCall.state = "connected";
          this.currentCall.startTime = new Date();
        }

        debugLog(this.config?.debug || false, "Call answered");

        if (this.simpleUser?.session) {
          const session = this.simpleUser.session;
          this.setupRemoteStreamHandlers(session);

          // Set up session state change listener for incoming calls as well
          session.stateChange.addListener((newState: any) => {
            debugLog(this.config?.debug || false, "Incoming session state changed:", newState);

            switch (newState) {
              case "Terminated":
              case "Ended":
                debugLog(this.config?.debug || false, "Incoming call ended");
                // Stop local media tracks to release camera and microphone
                if (this.localStream) {
                  this.localStream.getTracks().forEach((track) => {
                    try {
                      track.stop();
                      debugLog(this.config?.debug || false, `Stopped local media track on incoming call end: ${track.kind}`);
                    } catch (error) {
                      debugLog(this.config?.debug || false, `Failed to stop track on incoming call end: ${track.kind}`, error);
                    }
                  });
                  this.localStream = null;
                }
                this.videoEnabled = false;
                
                if (this.currentCall) {
                  this.currentCall.state = "ended";
                  this.dispatchEvent(
                    new CustomEvent("callEnded", {
                      detail: { callInfo: this.currentCall },
                    })
                  );
                }
                break;
            }
          });

          // FIXED: Force remote video check for outgoing calls after answer
          setTimeout(() => {
            this.forceRemoteVideoCheck(session);
          }, 500);
        }

        this.dispatchEvent(
          new CustomEvent("callAnswered", {
            detail: { callInfo: this.currentCall },
          })
        );

        this.startCallTimer();
      },

      onCallHangup: () => {
        debugLog(this.config?.debug || false, "Call ended");

        // Stop local media tracks to release camera and microphone
        if (this.localStream) {
          this.localStream.getTracks().forEach((track) => {
            try {
              track.stop();
              debugLog(this.config?.debug || false, `Stopped local media track: ${track.kind}`);
            } catch (error) {
              debugLog(this.config?.debug || false, `Failed to stop track: ${track.kind}`, error);
            }
          });
          this.localStream = null;
        }

        if (this.remoteVideo) {
          this.remoteVideo.srcObject = null;
        }

        if (this.currentCall) {
          this.currentCall.state = "ended";
        }

        this.stopCallTimer();
        this.dispatchEvent(
          new CustomEvent("callEnded", {
            detail: { callInfo: this.currentCall },
          })
        );

        this.currentCall = null;
        this.lastVideoState = false;
        this.videoEnabled = false;
      },

      onCallHold: (held: boolean) => {
        debugLog(this.config?.debug || false, "Call hold state changed", held);
        this.dispatchEvent(
          new CustomEvent("callHold", {
            detail: { held, callInfo: this.currentCall },
          })
        );
      },

      onRegistered: () => {
        this.isRegistered = true;
        debugLog(this.config?.debug || false, "Registration successful");
        this.dispatchEvent(new CustomEvent("registered", { detail: { registered: true } }));
      },

      onUnregistered: () => {
        this.isRegistered = false;
        debugLog(this.config?.debug || false, "Unregistered");
        this.dispatchEvent(new CustomEvent("registered", { detail: { registered: false } }));
      },

      onServerConnect: () => {
        this.isConnected = true;
        debugLog(this.config?.debug || false, "Server connected");
        this.dispatchEvent(new CustomEvent("connected"));
      },

      onServerDisconnect: () => {
        this.isConnected = false;
        this.isRegistered = false;
        debugLog(this.config?.debug || false, "Server disconnected");
        this.dispatchEvent(new CustomEvent("disconnected"));
      },
    };
  }

  private callTimer: number | null = null;

  private startCallTimer(): void {
    this.stopCallTimer();
    this.callTimer = window.setInterval(() => {
      if (this.currentCall && this.currentCall.startTime) {
        this.currentCall.duration = Math.floor((Date.now() - this.currentCall.startTime.getTime()) / 1000);
        this.dispatchEvent(
          new CustomEvent("callTimer", {
            detail: { duration: this.currentCall.duration, callInfo: this.currentCall },
          })
        );
      }
    }, 1000);
  }

  private stopCallTimer(): void {
    if (this.callTimer) {
      clearInterval(this.callTimer);
      this.callTimer = null;
    }
  }

  private startConnectionMonitoring(): void {
    this.connectionTimer = window.setInterval(() => {
      const connected = this.simpleUser?.isConnected() || false;

      if (connected !== this.isConnected) {
        this.isConnected = connected;
        this.dispatchEvent(
          new CustomEvent("heartbeat", {
            detail: {
              connected,
              registered: this.isRegistered,
            },
          })
        );
      }
    }, 5000);
  }

  async makeCall(target: string, includeVideo = true): Promise<void> {
    await this.ensureSipClient();

    if (!this.simpleUser || !this.isRegistered) {
      throw new Error("SIP client not registered");
    }

    if (this.currentCall) {
      throw new Error("Another call is already in progress");
    }

    try {
      const targetUri = `sip:${target}@${this.config!.domain}`;
      debugLog(this.config?.debug || false, "Making VIDEO call to", targetUri, "with video:", includeVideo);

      if (!this.videoEnabled) {
        await this.enableVideo();
      }
      const mediaStream = this.localStream!;

      this.currentCall = {
        id: Date.now().toString(),
        remoteIdentity: target,
        displayName: target,
        state: "outgoing",
        duration: 0,
      };

      const callOptions = {
        sessionDescriptionHandlerOptions: {
          constraints: {
            audio: true,
            video: true,
          },
          offerToReceiveAudio: true,
          offerToReceiveVideo: true,

          iceGatheringTimeout: 10000,
          rtcConfiguration: {
            iceServers: [
              { urls: "stun:stun.l.google.com:19302" },
              { urls: "stun:stun1.l.google.com:19302" },
              { urls: "stun:stun2.l.google.com:19302" },
              { urls: "stun:stun3.l.google.com:19302" },
            ],
            iceCandidatePoolSize: 10,
            iceTransportPolicy: "all",
            bundlePolicy: "balanced",
            rtcpMuxPolicy: "require",
          },
        },
        sessionDescriptionHandlerFactory: (session: any, options: any) => {
          options.localStream = mediaStream;
          options.remote = {
            audio: this.remoteAudio,
            video: this.remoteVideo,
          };

          return session.sessionDescriptionHandlerFactory(session, options);
        },
      };

      await this.simpleUser.call(targetUri, callOptions);

      // FIXED: Enhanced outgoing call session handling
      if (this.simpleUser.session) {
        const session = this.simpleUser.session;
        debugLog(this.config?.debug || false, "Outgoing call session created, state:", session.state);

        // FIXED: Set up handlers immediately for outgoing calls
        this.setupRemoteStreamHandlers(session);

        // FIXED: Listen for all session state changes
        session.stateChange.addListener((newState: any) => {
          debugLog(this.config?.debug || false, "Outgoing session state changed:", newState);

          switch (newState) {
            case "Establishing":
              debugLog(this.config?.debug || false, "Call is establishing, setting up stream handlers");
              this.setupRemoteStreamHandlers(session);
              break;

            case "Established":
              debugLog(this.config?.debug || false, "Call established, ensuring stream handlers");
              setTimeout(() => {
                this.setupRemoteStreamHandlers(session);
                this.forceRemoteVideoCheck(session);
              }, 100);
              break;

            case "Terminated":
            case "Ended":
              debugLog(this.config?.debug || false, "Outgoing call ended");
              // Stop local media tracks to release camera and microphone
              if (this.localStream) {
                this.localStream.getTracks().forEach((track) => {
                  try {
                    track.stop();
                    debugLog(this.config?.debug || false, `Stopped local media track on outgoing call end: ${track.kind}`);
                  } catch (error) {
                    debugLog(this.config?.debug || false, `Failed to stop track on outgoing call end: ${track.kind}`, error);
                  }
                });
                this.localStream = null;
              }
              this.videoEnabled = false;
              
              if (this.currentCall) {
                this.currentCall.state = "ended";
                this.dispatchEvent(
                  new CustomEvent("callEnded", {
                    detail: { callInfo: this.currentCall },
                  })
                );
              }
              break;
          }
        });

        // FIXED: Also listen for session description handler changes
        const checkForSDH = () => {
          if (session.sessionDescriptionHandler) {
            debugLog(this.config?.debug || false, "Session description handler available for outgoing call");
            this.setupRemoteStreamHandlers(session);
          } else {
            setTimeout(checkForSDH, 100);
          }
        };
        checkForSDH();
      }

      this.dispatchEvent(
        new CustomEvent("callStarted", {
          detail: {
            target,
            callInfo: this.currentCall,
            videoEnabled: true,
          },
        })
      );
    } catch (error) {
      errorLog("Call failed", error);
      
      // Stop local media tracks to release camera and microphone
      if (this.localStream) {
        this.localStream.getTracks().forEach((track) => {
          try {
            track.stop();
            debugLog(this.config?.debug || false, `Stopped local media track on call failure: ${track.kind}`);
          } catch (trackError) {
            debugLog(this.config?.debug || false, `Failed to stop track on call failure: ${track.kind}`, trackError);
          }
        });
        this.localStream = null;
      }
      
      this.currentCall = null;
      this.dispatchEvent(
        new CustomEvent("callFailed", {
          detail: {
            error: error instanceof Error ? error.message : "Call failed",
            target,
          },
        })
      );
      throw error;
    }
  }

  private forceRemoteVideoCheck(session: any): void {
    try {
      if (!session || !session.sessionDescriptionHandler) {
        debugLog(this.config?.debug || false, "No session description handler for video check");
        return;
      }

      const pc = session.sessionDescriptionHandler.peerConnection;
      if (!pc) {
        debugLog(this.config?.debug || false, "No peer connection for video check");
        return;
      }

      debugLog(this.config?.debug || false, "Forcing remote video check, connection state:", pc.connectionState);

      // Check for remote streams
      const remoteStreams = pc.getRemoteStreams ? pc.getRemoteStreams() : [];
      debugLog(this.config?.debug || false, "Remote streams found:", remoteStreams.length);

      if (remoteStreams.length > 0) {
        const remoteStream = remoteStreams[0];
        const videoTracks = remoteStream.getVideoTracks();

        debugLog(this.config?.debug || false, "Found remote stream with video tracks:", videoTracks.length);

        if (videoTracks.length > 0 && this.remoteVideo) {
          this.remoteVideo.srcObject = remoteStream;
          this.remoteVideo.autoplay = true;
          this.remoteVideo.playsInline = true;

          const playPromise = this.remoteVideo.play();
          if (playPromise !== undefined) {
            playPromise.catch((error) => {
              debugLog(this.config?.debug || false, "Remote video play failed:", error);
              // Try to handle the error by re-attaching the stream
              if (this.remoteVideo && this.remoteVideo.srcObject) {
                const currentStream = this.remoteVideo.srcObject;
                this.remoteVideo.srcObject = null;
                this.remoteVideo.srcObject = currentStream;
                setTimeout(() => {
                  if (this.remoteVideo && this.remoteVideo.srcObject) {
                    const retryPromise = this.remoteVideo.play();
                    if (retryPromise !== undefined) {
                      retryPromise.catch((retryError) => {
                        debugLog(this.config?.debug || false, "Remote video play retry failed:", retryError);
                      });
                    }
                  }
                }, 100);
              }
            });
          }

          const hasActiveVideo = videoTracks.some((track: any) => track.enabled && track.readyState === "live");

          this.dispatchEvent(
            new CustomEvent("remoteVideoChanged", {
              detail: {
                enabled: true,
                stream: remoteStream,
                hasVideoTracks: hasActiveVideo,
              },
            })
          );
        }
      }

      // Also check transceivers
      const transceivers = pc.getTransceivers();
      debugLog(this.config?.debug || false, "Checking transceivers for outgoing call:", transceivers.length);

      transceivers.forEach((transceiver: RTCRtpTransceiver, index: number) => {
        if (transceiver.receiver?.track?.kind === "video" && transceiver.receiver.track.readyState === "live") {
          debugLog(this.config?.debug || false, `Found active video transceiver ${index} for outgoing call`);

          if (this.remoteVideo && !this.remoteVideo.srcObject) {
            const videoStream = new MediaStream([transceiver.receiver.track]);
            this.remoteVideo.srcObject = videoStream;
            this.remoteVideo.autoplay = true;
            this.remoteVideo.playsInline = true;

            // Handle video play with better error handling
            if (this.remoteVideo.srcObject) {
              const playPromise = this.remoteVideo.play();
              if (playPromise !== undefined) {
                playPromise
                  .then(() => {
                    debugLog(this.config?.debug || false, "Transceiver video playing successfully");
                  })
                  .catch((error) => {
                    debugLog(this.config?.debug || false, "Transceiver video play failed:", error);
                    // Try to handle the error by re-attaching the stream
                    if (this.remoteVideo && this.remoteVideo.srcObject) {
                      const currentStream = this.remoteVideo.srcObject;
                      this.remoteVideo.srcObject = null;
                      this.remoteVideo.srcObject = currentStream;
                      // Add a small delay before retrying to avoid race conditions
                      setTimeout(() => {
                        if (this.remoteVideo && this.remoteVideo.srcObject) {
                          // Check if the video element is in a playable state
                          if (this.remoteVideo.readyState >= 2) { // HAVE_CURRENT_DATA
                            const retryPromise = this.remoteVideo.play();
                            if (retryPromise !== undefined) {
                              retryPromise.catch((retryError) => {
                                debugLog(this.config?.debug || false, "Transceiver video play retry failed:", retryError);
                              });
                            }
                          } else {
                            // If not ready, wait a bit more
                            setTimeout(() => {
                              if (this.remoteVideo && this.remoteVideo.srcObject) {
                                const retryPromise = this.remoteVideo.play();
                                if (retryPromise !== undefined) {
                                  retryPromise.catch((retryError) => {
                                    debugLog(this.config?.debug || false, "Delayed transceiver video play retry failed:", retryError);
                                  });
                                }
                              }
                            }, 200);
                          }
                        }
                      }, 150);
                    }
                  });
              }
            }

            this.dispatchEvent(
              new CustomEvent("remoteVideoChanged", {
                detail: {
                  enabled: true,
                  stream: videoStream,
                  hasVideoTracks: true,
                },
              })
            );
          }
        }
      });
    } catch (error) {
      debugLog(this.config?.debug || false, "Force remote video check failed:", error);
    }
  }

  async answerCall(): Promise<void> {
    await this.ensureSipClient();

    if (!this.simpleUser) {
      throw new Error("SIP client not available");
    }

    const session = this.simpleUser.session;
    if (!session) {
      throw new Error("No session available to answer");
    }

    if (!this.currentCall || this.currentCall.state !== "incoming") {
      throw new Error("No incoming call to answer");
    }

    const sessionState = session.state;
    debugLog(this.config?.debug || false, "Attempting to answer call, session state:", sessionState);

    if (sessionState === "Terminated" || sessionState === "Ended") {
      throw new Error("Call has already ended");
    }

    if (sessionState !== "Initial") {
      throw new Error(`Cannot answer call in state: ${sessionState}`);
    }

    try {
      if (!this.videoEnabled) {
        await this.enableVideo();
      }
      const mediaStream = this.localStream!;

      const answerOptions = {
        sessionDescriptionHandlerOptions: {
          constraints: {
            audio: true,
            video: true,
          },
          rtcConfiguration: {
            iceServers: [
              { urls: "stun:stun.l.google.com:19302" },
              { urls: "stun:stun1.l.google.com:19302" },
              { urls: "stun:stun2.l.google.com:19302" },
              { urls: "stun:stun3.l.google.com:19302" },
            ],
            iceCandidatePoolSize: 10,
            iceTransportPolicy: "all",
            bundlePolicy: "balanced",
            rtcpMuxPolicy: "require",
          },
        },
        sessionDescriptionHandlerFactory: (session: any, options: any) => {
          options.localStream = mediaStream;
          return session.sessionDescriptionHandlerFactory(session, options);
        },
      };

      await this.simpleUser.answer(answerOptions);
      debugLog(this.config?.debug || false, "Call answered with video:", this.videoEnabled);

      if (this.simpleUser.session) {
        this.setupRemoteStreamHandlers(this.simpleUser.session);
      }
    } catch (error) {
      errorLog("Answer call failed", error);
      // Stop any media tracks that might have been started during the failed attempt
      if (this.localStream) {
        this.localStream.getTracks().forEach((track) => {
          try {
            track.stop();
            debugLog(this.config?.debug || false, `Stopped local media track on answer failure: ${track.kind}`);
          } catch (trackError) {
            debugLog(this.config?.debug || false, `Failed to stop track on answer failure: ${track.kind}`, trackError);
          }
        });
        this.localStream = null;
      }
      throw error;
    }
  }

  async rejectCall(): Promise<void> {
    await this.ensureSipClient();

    if (!this.simpleUser) {
      throw new Error("SIP client not available");
    }

    try {
      await this.simpleUser.decline();

      if (this.currentCall) {
        this.currentCall.state = "ended";
      }

      this.currentCall = null;
      debugLog(this.config?.debug || false, "Call rejected");
    } catch (error) {
      errorLog("Reject call failed", error);
      throw error;
    }
  }

  async hangup(): Promise<void> {
    if (!this.simpleUser) return;

    try {
      await this.simpleUser.hangup();
      debugLog(this.config?.debug || false, "Call hung up");
    } catch (error) {
      errorLog("Hangup failed", error);
      throw error;
    }
  }

  async mute(): Promise<void> {
    if (!this.simpleUser) return;

    try {
      await this.simpleUser.mute();
      debugLog(this.config?.debug || false, "Call muted");
    } catch (error) {
      errorLog("Mute failed", error);
      throw error;
    }
  }

  async unmute(): Promise<void> {
    if (!this.simpleUser) return;

    try {
      await this.simpleUser.unmute();
      debugLog(this.config?.debug || false, "Call unmuted");
    } catch (error) {
      errorLog("Unmute failed", error);
      throw error;
    }
  }

  sendDTMF(tone: string): void {
    if (!this.simpleUser || !this.currentCall) return;

    try {
      if (typeof this.simpleUser.sendDTMF === "function") {
        this.simpleUser.sendDTMF(tone);
        debugLog(this.config?.debug || false, "DTMF sent", tone);

        this.dispatchEvent(
          new CustomEvent("dtmfSent", {
            detail: { tone, callInfo: this.currentCall },
          })
        );
      }
    } catch (error) {
      errorLog("DTMF send failed", error);
    }
  }

  getRemoteVideo(): HTMLVideoElement | null {
    return this.remoteVideo;
  }

  getRemoteAudio(): HTMLAudioElement | null {
    return this.remoteAudio;
  }

  getCurrentCall(): CallInfo | null {
    return this.currentCall;
  }

  getConnectionStatus(): { connected: boolean; registered: boolean; initialized: boolean } {
    return {
      connected: this.isConnected,
      registered: this.isRegistered,
      initialized: this.isInitialized,
    };
  }

  async connect(): Promise<void> {
    await this.ensureSipClient();
  }

  async disconnect(): Promise<void> {
    if (this.connectionTimer) {
      clearInterval(this.connectionTimer);
      this.connectionTimer = null;
    }

    this.stopCallTimer();

    if (this.simpleUser) {
      try {
        if (this.currentCall) {
          await this.hangup();
        }

        if (this.isRegistered) {
          await this.simpleUser.unregister();
        }

        if (this.isConnected) {
          await this.simpleUser.disconnect();
        }
      } catch (error) {
        errorLog("Disconnect error", error);
      }

      this.simpleUser = null;
    }

    try {
      if (this.localStream) {
        this.localStream.getTracks().forEach((track) => track.stop());
        this.localStream = null;
      }

      if (this.localVideo && this.localVideo.parentNode) {
        this.localVideo.pause();
        this.localVideo.srcObject = null;
        this.localVideo.parentNode.removeChild(this.localVideo);
        this.localVideo = null;
      }

      if (this.remoteVideo && this.remoteVideo.parentNode) {
        this.remoteVideo.pause();
        this.remoteVideo.srcObject = null;
        this.remoteVideo.parentNode.removeChild(this.remoteVideo);
        this.remoteVideo = null;
      }

      this.videoEnabled = false;

      if (this.remoteAudio && this.remoteAudio.parentNode) {
        this.remoteAudio.pause();
        this.remoteAudio.srcObject = null;
        this.remoteAudio.parentNode.removeChild(this.remoteAudio);
        this.remoteAudio = null;
      }
    } catch (error) {
      errorLog("Error cleaning up media resources:", error);
    }

    this.isConnected = false;
    this.isRegistered = false;
    this.isInitialized = false;
    this.isInitializing = false;
    this.currentCall = null;

    debugLog(this.config?.debug || false, "SIP client disconnected");
  }
}

---

=== Object: 9351024f58df05c1281e1e9f327f273a88553ceb | Date: 2025-09-23 15:32:13 | Type: blob ===

import { LitElement, html, css, type CSSResultGroup, type TemplateResult } from "lit";
import { customElement, property, state, query } from "lit/decorators.js";
import type { HomeAssistant, SIPCardConfig, SIPContact } from "./types";
import { SipManager, type SipConfig } from "./sip-manager";
import { CallManager, type CallState } from "./call-manager";
import { sharedStyles } from "./styles";
import { CARD_VERSION, DEFAULT_CONFIG, DTMF_KEYS } from "./constants";
import { mergeConfig, validateConfig, formatPhoneNumber, sanitizeExtension } from "./utils";

@customElement("ha-webrtc-sip-card")
export class WebRTCSipCard extends LitElement {
  @property({ attribute: false }) public hass!: HomeAssistant;
  @state() private config!: SIPCardConfig;
  @state() private connected = false;
  @state() private registered = false;
  @state() private error: string | null = null;
  @state() private callState!: CallState;
  @state() private showKeypad = false;
  @state() private currentInput = "";
  @state() private callDuration = "00:00";
  @state() private remoteVideoAvailable = false;
  @state() private connectionAttempts = 0;
  @state() private isRetrying = false;

  @query("#remote-video") private remoteVideoElement?: HTMLVideoElement;

  private sipManager: SipManager | null = null;
  private callManager: CallManager | null = null;
  private remoteVideoCheckInterval: number | null = null;
  private remoteVideoUpdateTimeout: number | null = null;
  private connectionRetryTimeout: number | null = null;

  private readonly MAX_RETRY_ATTEMPTS = 5;
  private readonly RETRY_DELAYS = [2000, 5000, 10000, 20000, 30000];

  public static getConfigElement() {
    return document.createElement("ha-webrtc-sip-card-editor");
  }

  public static getStubConfig(): SIPCardConfig {
    return { ...DEFAULT_CONFIG };
  }

  public setConfig(config: SIPCardConfig): void {
    try {
      validateConfig(config);
      this.config = mergeConfig(config);
      this.connectionAttempts = 0;
      this.initializeSipClient();
    } catch (error) {
      this.error = error instanceof Error ? error.message : "Invalid configuration";
      throw new Error(this.error);
    }
  }

  public getCardSize(): number {
    return this.callState && this.callState.active ? 6 : 4;
  }

  private async initializeSipClient(): Promise<void> {
    try {
      if (this.sipManager) {
        await this.sipManager.disconnect();
      }

      this.error = null;
      this.connected = false;
      this.registered = false;
      this.isRetrying = false;

      const sipConfig: SipConfig = {
        server: this.config.server_url.replace(/^wss?:\/\//, "").replace(/:\d+$/, ""),
        username: this.config.username,
        password: this.config.password,
        domain: this.config.domain || this.config.server_url.replace(/^wss?:\/\//, "").replace(/:\d+$/, ""),
        websocket_port: this.config.websocket_port ? Number(this.config.websocket_port) : this.config.server_url.includes("wss://") ? 443 : 80,
        use_secure: this.config.server_url.startsWith("wss://"),
        display_name: this.config.display_name,
        debug: this.config.debug,
      };

      this.sipManager = new SipManager();
      this.callManager = new CallManager(this.sipManager, this.config.contacts);

      this.setupEventHandlers();
      this.callState = this.callManager.getCallState();
      this.sipManager.setConfig(sipConfig);

      this.attemptConnection();
    } catch (error) {
      this.error = error instanceof Error ? error.message : "Configuration failed";
      this.connected = false;
      this.registered = false;
      console.error("SIP configuration failed:", error);
    }
  }

  private async attemptConnection(): Promise<void> {
    if (this.connectionAttempts >= this.MAX_RETRY_ATTEMPTS) {
      this.error = "Failed to connect after multiple attempts. Please check server configuration and network connectivity.";
      this.isRetrying = false;
      this.requestUpdate();
      return;
    }

    if (this.connectionRetryTimeout) {
      clearTimeout(this.connectionRetryTimeout);
      this.connectionRetryTimeout = null;
    }

    try {
      this.isRetrying = this.connectionAttempts > 0;
      this.requestUpdate();

      console.log(`Connection attempt ${this.connectionAttempts + 1}/${this.MAX_RETRY_ATTEMPTS}`);

      await this.sipManager!.connect();

      this.connectionAttempts = 0;
      this.isRetrying = false;
      this.error = null;
      console.log("SIP client connected successfully");
      this.requestUpdate();
    } catch (error) {
      this.connectionAttempts++;
      const errorMessage = error instanceof Error ? error.message : "Connection failed";

      console.error(`Connection attempt ${this.connectionAttempts} failed:`, errorMessage);

      if (this.connectionAttempts < this.MAX_RETRY_ATTEMPTS) {
        const delay = this.RETRY_DELAYS[this.connectionAttempts - 1] || this.RETRY_DELAYS[this.RETRY_DELAYS.length - 1];

        this.error = `Connection failed. Retrying in ${Math.ceil(delay / 1000)} seconds... (${this.connectionAttempts}/${this.MAX_RETRY_ATTEMPTS})`;
        this.isRetrying = true;
        this.requestUpdate();

        this.connectionRetryTimeout = window.setTimeout(() => {
          this.attemptConnection();
        }, delay);
      } else {
        let detailedError = "Connection failed";
        if (errorMessage.includes("1006")) {
          detailedError =
            "WebSocket connection failed (1006). Check:\n Server is running and accessible\n Correct WebSocket URL and port\n Network/firewall allows WebSocket connections\n SSL certificate valid (for wss://)";
        } else if (errorMessage.includes("timeout")) {
          detailedError = "Connection timeout. Server may be unreachable or overloaded.";
        } else if (errorMessage.includes("refused")) {
          detailedError = "Connection refused. Check server URL and port.";
        }

        this.error = detailedError;
        this.isRetrying = false;
        this.connected = false;
        this.registered = false;
        this.requestUpdate();
      }
    }
  }

  private setupEventHandlers(): void {
    if (!this.sipManager || !this.callManager) return;

    this.sipManager.addEventListener("connected", () => {
      this.connected = true;
      this.connectionAttempts = 0;
      this.isRetrying = false;
      this.error = null;
      this.requestUpdate();
    });

    this.sipManager.addEventListener("disconnected", () => {
      this.connected = false;
      this.registered = false;
      if (!this.isRetrying && this.connectionAttempts === 0) {
        this.error = "Disconnected from server";
        this.scheduleReconnect();
      }
      this.requestUpdate();
    });

    this.sipManager.addEventListener("registered", (event: any) => {
      this.registered = event.detail.registered;
      if (this.registered) {
        this.error = null;
        this.connectionAttempts = 0;
        this.isRetrying = false;
      }
      this.requestUpdate();
    });

    this.sipManager.addEventListener("error", (event: any) => {
      const errorDetail = event.detail.error;
      console.error("SIP Manager error:", errorDetail);

      if (errorDetail.includes("WebSocket closed") || errorDetail.includes("1006")) {
        if (!this.isRetrying) {
          this.scheduleReconnect();
        }
      } else {
        this.error = errorDetail;
        this.connected = false;
        this.registered = false;
        this.requestUpdate();
      }
    });

    this.sipManager.addEventListener("localVideoChanged", (event: any) => {
      this.callState = this.callManager?.getCallState() || this.callState;
      this.requestUpdate();
    });

    this.sipManager.addEventListener("remoteVideoChanged", (event: any) => {
      console.log("Remote video changed:", event.detail);
      this.remoteVideoAvailable = event.detail.enabled && event.detail.hasVideoTracks;
      this.callState = this.callManager?.getCallState() || this.callState;
      this.callState.remoteVideoEnabled = this.remoteVideoAvailable;

      this.updateComplete.then(() => {
        this.debouncedUpdateRemoteVideo();
      });

      this.requestUpdate();
    });

    this.callManager.addEventListener("callStateChanged", (event: any) => {
      const wasActive = this.callState?.active;
      this.callState = event.detail.callState;

      if (this.callState.active && !wasActive) {
        this.startRemoteVideoMonitoring();
      } else if (!this.callState.active && wasActive) {
        this.stopRemoteVideoMonitoring();
        this.remoteVideoAvailable = false;
      }

      this.updateComplete.then(() => {
        this.debouncedUpdateRemoteVideo();
      });

      this.requestUpdate();
    });

    this.callManager.addEventListener("callTimerUpdate", (event: any) => {
      this.callDuration = event.detail.formattedDuration;
    });
  }

  private scheduleReconnect(): void {
    if (this.isRetrying || this.connectionRetryTimeout) return;

    console.log("Scheduling reconnection...");
    this.connectionAttempts = 0;

    this.connectionRetryTimeout = window.setTimeout(() => {
      this.attemptConnection();
    }, 3000);
  }

  private debouncedUpdateRemoteVideo(): void {
    if (this.remoteVideoUpdateTimeout) {
      clearTimeout(this.remoteVideoUpdateTimeout);
    }

    this.remoteVideoUpdateTimeout = window.setTimeout(() => {
      this.updateRemoteVideo();
      this.remoteVideoUpdateTimeout = null;
    }, 50);
  }

  private startRemoteVideoMonitoring(): void {
    this.stopRemoteVideoMonitoring();

    this.remoteVideoCheckInterval = window.setInterval(() => {
      const remoteVideo = this.callManager?.getRemoteVideo();
      if (remoteVideo && remoteVideo.srcObject) {
        const stream = remoteVideo.srcObject as MediaStream;
        const hasVideoTracks = stream.getVideoTracks().length > 0;

        if (hasVideoTracks !== this.remoteVideoAvailable) {
          this.remoteVideoAvailable = hasVideoTracks;
          this.callState.remoteVideoEnabled = hasVideoTracks;

          console.log("Remote video monitoring detected change:", {
            hasVideoTracks,
            streamId: stream.id,
          });

          this.updateRemoteVideo();
          this.requestUpdate();
        }
      }
    }, 1000);
  }

  private stopRemoteVideoMonitoring(): void {
    if (this.remoteVideoCheckInterval) {
      clearInterval(this.remoteVideoCheckInterval);
      this.remoteVideoCheckInterval = null;
    }
  }

  private updateRemoteVideo(): void {
    if (this.callState.active && this.remoteVideoElement) {
      const remoteVideo = this.callManager?.getRemoteVideo();
      if (remoteVideo && remoteVideo.srcObject) {
        console.log("Updating remote video element:", {
          hasStream: !!remoteVideo.srcObject,
          videoTracks: (remoteVideo.srcObject as MediaStream)?.getVideoTracks().length || 0,
        });

        const updateVideoStream = async () => {
          try {
            if (this.remoteVideoElement!.srcObject !== remoteVideo.srcObject) {
              if (!this.remoteVideoElement!.paused) {
                this.remoteVideoElement!.pause();
              }

              this.remoteVideoElement!.srcObject = remoteVideo.srcObject;
              this.remoteVideoElement!.autoplay = true;
              this.remoteVideoElement!.playsInline = true;
              this.remoteVideoElement!.muted = false;

              const playPromise = this.remoteVideoElement!.play();

              if (playPromise !== undefined) {
                playPromise
                  .then(() => {
                    console.log("Remote video playback started successfully");
                  })
                  .catch((error) => {
                    console.warn("Remote video playback failed:", error);
                  });
              }
            }
          } catch (error: any) {
            if (error.name === "AbortError") {
              console.log("Video play was interrupted, this is normal during stream updates");

              // Don't immediately retry, wait for a more stable state
              setTimeout(() => {
                if (this.remoteVideoElement && this.remoteVideoElement.srcObject) {
                  // Check if the element is still in a playable state
                  if (this.remoteVideoElement.readyState >= 2) { // HAVE_CURRENT_DATA
                    const retryPromise = this.remoteVideoElement.play();
                    if (retryPromise !== undefined) {
                      retryPromise.catch(() => {
                        console.log("Secondary play attempt failed, ignoring");
                      });
                    }
                  } else {
                    // If not ready, wait a bit more and try again
                    setTimeout(() => {
                      if (this.remoteVideoElement && this.remoteVideoElement.srcObject) {
                        const retryPromise = this.remoteVideoElement.play();
                        if (retryPromise !== undefined) {
                          retryPromise.catch(() => {
                            console.log("Delayed play attempt failed, ignoring");
                          });
                        }
                      }
                    }, 200);
                  }
                }
              }, 150);
            } else if (error.name === "NotAllowedError") {
              console.log("Video play not allowed, likely due to autoplay restrictions");

              // Try to handle autoplay restrictions by re-attaching the stream
              if (this.remoteVideoElement) {
                const currentStream = this.remoteVideoElement.srcObject;
                this.remoteVideoElement.srcObject = null;
                this.remoteVideoElement.srcObject = currentStream;
                setTimeout(() => {
                  if (this.remoteVideoElement && this.remoteVideoElement.srcObject) {
                    this.remoteVideoElement.muted = true;
                    const retryPromise = this.remoteVideoElement.play();
                    if (retryPromise !== undefined) {
                      retryPromise.catch((retryError) => {
                        console.log("Retry play attempt failed:", retryError);
                        
                        // Last resort: try to re-attach the stream again
                        if (this.remoteVideoElement && this.remoteVideoElement.srcObject) {
                          const currentStream = this.remoteVideoElement.srcObject;
                          this.remoteVideoElement.srcObject = null;
                          this.remoteVideoElement.srcObject = currentStream;
                          setTimeout(() => {
                            if (this.remoteVideoElement && this.remoteVideoElement.srcObject) {
                              this.remoteVideoElement.muted = true;
                              const finalPromise = this.remoteVideoElement.play();
                              if (finalPromise !== undefined) {
                                finalPromise.catch((finalError) => {
                                  console.log("Final play attempt failed:", finalError);
                                });
                              }
                            }
                          }, 100);
                        }
                      });
                    }
                  }
                }, 100);
              }
            } else {
              console.warn("Video play failed:", error);
            }
          }
        };

        updateVideoStream();

        if (!this.remoteVideoAvailable) {
          const stream = remoteVideo.srcObject as MediaStream;
          this.remoteVideoAvailable = stream.getVideoTracks().length > 0;
          this.requestUpdate();
        }
      }
    }
  }

  connectedCallback() {
    super.connectedCallback();
    if (this.config) {
      this.initializeSipClient();
    }
  }

  disconnectedCallback() {
    super.disconnectedCallback();

    if (this.connectionRetryTimeout) {
      clearTimeout(this.connectionRetryTimeout);
      this.connectionRetryTimeout = null;
    }

    if (this.remoteVideoUpdateTimeout) {
      clearTimeout(this.remoteVideoUpdateTimeout);
      this.remoteVideoUpdateTimeout = null;
    }

    this.stopRemoteVideoMonitoring();
    if (this.sipManager) {
      this.sipManager.disconnect().catch(console.error);
    }
  }

  protected render(): TemplateResult {
    if (!this.config) {
      return html`<ha-card><div class="error">Configuration required</div></ha-card>`;
    }

    return html` <ha-card> ${this.renderStatusBar()} ${this.renderError()} ${this.renderContent()} ${this.renderIncomingCallModal()} </ha-card> `;
  }

  private renderStatusBar(): TemplateResult {
    const statusClass = this.registered ? "connected" : this.connected ? "connecting" : this.isRetrying ? "retrying" : "disconnected";

    let statusText = "Disconnected";
    if (this.registered) {
      statusText = "Connected";
    } else if (this.connected) {
      statusText = "Registering...";
    } else if (this.isRetrying) {
      statusText = `Retrying... (${this.connectionAttempts}/${this.MAX_RETRY_ATTEMPTS})`;
    }

    return html`
      <div class="status-bar">
        <div class="status-indicator">
          <div class="status-dot ${statusClass}"></div>
          <span>${statusText}</span>
          ${this.isRetrying ? html`<ha-circular-progress size="small" indeterminate></ha-circular-progress>` : ""}
        </div>
        <div class="card-title">${this.config.title || "WebRTC SIP Phone"}</div>
        ${!this.registered && !this.isRetrying
          ? html` <ha-icon-button @click=${this.manualRetry} icon="mdi:refresh" title="Retry connection"></ha-icon-button> `
          : ""}
      </div>
    `;
  }

  private renderError(): TemplateResult {
    if (!this.error) return html``;

    const isMultiLine = this.error.includes("\n");

    return html`
      <div class="error-message ${isMultiLine ? "multiline" : ""}">
        <ha-icon icon="mdi:alert-circle"></ha-icon>
        <div class="error-text">${isMultiLine ? this.error.split("\n").map((line) => html`<div>${line}</div>`) : this.error}</div>
      </div>
    `;
  }

  private renderContent(): TemplateResult {
    if (this.callState.active) {
      return this.renderActiveCall();
    }

    return html` <div class="card-content">${this.renderContacts()} ${this.renderManualDial()} ${this.showKeypad ? this.renderKeypad() : ""}</div> `;
  }

  private renderContacts(): TemplateResult {
    if (!this.config.contacts.length) {
      return html`
        <div class="no-contacts">
          <ha-icon icon="mdi:account-plus-outline"></ha-icon>
          <div class="no-contacts-text">No contacts configured</div>
          <div class="no-contacts-subtitle">Add contacts in card configuration</div>
        </div>
      `;
    }

    return html`
      <div class="contacts-section">
        <div class="section-header">
          <ha-icon icon="mdi:contacts"></ha-icon>
          <h3>Quick Dial</h3>
          <div class="contact-count">${this.config.contacts.length}</div>
        </div>
        <div class="contacts-list">${this.config.contacts.map((contact) => this.renderContact(contact))}</div>
      </div>
    `;
  }

  private renderContact(contact: SIPContact): TemplateResult {
    return html`
      <div class="contact-item" ?disabled=${!this.registered}>
        <div class="contact-avatar">
          <ha-icon icon=${contact.icon || "mdi:account"}></ha-icon>
        </div>

        <div class="contact-info">
          <div class="contact-name">${contact.name}</div>
          <div class="contact-details">
            <span class="contact-extension">${formatPhoneNumber(contact.extension)}</span>
            <span class="video-badge">Video</span>
          </div>
        </div>

        <div class="contact-actions">
          <button class="action-btn video-btn" @click=${() => this.callContact(contact, true)} ?disabled=${!this.registered} title="Video call">
            <ha-icon icon="mdi:video"></ha-icon>
          </button>
        </div>
      </div>
    `;
  }

  private renderManualDial(): TemplateResult {
    return html`
      <div class="manual-dial">
        <div class="dial-input-container">
          <ha-textfield .value=${this.currentInput} @input=${this.handleInputChange} placeholder="Enter number..." ?disabled=${!this.registered}></ha-textfield>
          <ha-icon-button @click=${this.toggleKeypad} icon="mdi:dialpad" ?disabled=${!this.registered}></ha-icon-button>
        </div>
        <div class="dial-actions">
          <ha-button @click=${() => this.makeVideoCall()} ?disabled=${!this.registered || !this.currentInput.trim()} class="video-call">
            <ha-icon icon="mdi:video" slot="icon"></ha-icon> Video Call
          </ha-button>
          <ha-button @click=${this.clearInput} ?disabled=${!this.currentInput.length}> Clear </ha-button>
        </div>
      </div>
    `;
  }

  private renderKeypad(): TemplateResult {
    return html`
      <div class="keypad">
        ${DTMF_KEYS.flat().map((key) => html` <button class="keypad-button" @click=${() => this.handleKeypadPress(key)}>${key}</button> `)}
      </div>
    `;
  }

  private renderActiveCall(): TemplateResult {
    const isIncoming = this.callState.incoming && this.callState.status === "ringing";
    const isActive = this.callState.status === "answered";

    return html`
      <div class="active-call">
        ${this.renderCallInfo()} ${this.renderVideoStatus()} ${this.renderVideoArea()} ${isIncoming ? this.renderIncomingCallControls() : ""}
        ${isActive ? this.renderCallControls() : ""} ${isActive && !this.config.hide_keypad ? this.renderInCallKeypad() : ""}
      </div>
    `;
  }

  private renderCallInfo(): TemplateResult {
    return html`
      <div class="call-info">
        <div class="caller-name">${this.callState.callerName || "Unknown"}</div>
        <div class="caller-number">${formatPhoneNumber(this.callState.callerId || "")}</div>
        <div class="call-status">${this.getCallStatusText()}</div>
        ${this.callState.status === "answered" ? html`<div class="call-duration">${this.callDuration}</div>` : ""}
      </div>
    `;
  }

  private renderVideoStatus(): TemplateResult {
    return html`
      <div class="video-status">
        <div class="video-indicator active">
          <ha-icon icon="mdi:video"></ha-icon>
          <span>Camera On</span>
        </div>

        <div class="video-indicator ${this.remoteVideoAvailable ? "active" : "inactive"}">
          <ha-icon icon=${this.remoteVideoAvailable ? "mdi:video" : "mdi:video-off"}></ha-icon>
          <span>${this.remoteVideoAvailable ? "Remote Video" : "No Remote Video"}</span>
        </div>
      </div>
    `;
  }

  private renderVideoArea(): TemplateResult {
    return html`
      <div class="video-container ${this.remoteVideoAvailable ? "has-video" : "no-video"}">
        <video id="remote-video" autoplay playsinline ?muted=${false}></video>
        ${!this.remoteVideoAvailable
          ? html`
              <div class="video-overlay">
                <ha-icon icon="mdi:video-off"></ha-icon>
                <div>No remote video</div>
              </div>
            `
          : ""}
      </div>
    `;
  }

  private renderIncomingCallControls(): TemplateResult {
    const isAnswering = this.isAnsweringCall;
    
    return html`
      <div class="call-controls">
        <button class="control-button video" @click=${() => this.answerCall(true)} ?disabled=${isAnswering}>
          <ha-icon icon="mdi:video"></ha-icon>
        </button>
        <button class="control-button danger" @click=${this.rejectCall} ?disabled=${isAnswering}>
          <ha-icon icon="mdi:phone-hangup"></ha-icon>
        </button>
      </div>
    `;
  }

  private renderCallControls(): TemplateResult {
    return html`
      <div class="call-controls">
        <button class="control-button ${this.callState.muted ? "danger" : "secondary"}" @click=${this.toggleMute}>
          <ha-icon icon=${this.callState.muted ? "mdi:microphone-off" : "mdi:microphone"}></ha-icon>
        </button>

        <button class="control-button danger" @click=${this.hangupCall}>
          <ha-icon icon="mdi:phone-hangup"></ha-icon>
        </button>

        <button class="control-button secondary" @click=${() => (this.showKeypad = !this.showKeypad)}>
          <ha-icon icon="mdi:dialpad"></ha-icon>
        </button>
      </div>
    `;
  }

  private renderInCallKeypad(): TemplateResult {
    if (!this.showKeypad) return html``;

    return html`
      <div class="in-call-keypad">
        <div class="keypad">${DTMF_KEYS.flat().map((key) => html` <button class="keypad-button" @click=${() => this.sendDTMF(key)}>${key}</button> `)}</div>
      </div>
    `;
  }

  private renderIncomingCallModal(): TemplateResult {
    if (!this.callState.incoming || this.callState.status !== "ringing") {
      return html``;
    }

    const isAnswering = this.isAnsweringCall;

    return html`
      <div class="incoming-call-modal">
        <div class="incoming-call-content">
          <div class="incoming-call-avatar">
            <ha-icon icon="mdi:account"></ha-icon>
          </div>
          <div class="caller-name">${this.callState.callerName || "Unknown Caller"}</div>
          <div class="caller-number">${formatPhoneNumber(this.callState.callerId || "")}</div>
          <div class="incoming-call-actions">
            <button class="video-answer-button" @click=${() => this.answerCall(true)} ?disabled=${isAnswering}>
              <ha-icon icon="mdi:video"></ha-icon>
            </button>
            <button class="reject-button" @click=${this.rejectCall} ?disabled=${isAnswering}>
              <ha-icon icon="mdi:phone-hangup"></ha-icon>
            </button>
          </div>
        </div>
      </div>
    `;
  }

  private getCallStatusText(): string {
    switch (this.callState.status) {
      case "connecting":
        return "Connecting...";
      case "ringing":
        return this.callState.incoming ? "Incoming call" : "Ringing...";
      case "answered":
        return "Connected";
      case "ended":
        return "Call ended";
      case "error":
        return "Call failed";
      default:
        return "";
    }
  }

  private handleInputChange(event: Event): void {
    const target = event.target as HTMLInputElement;
    this.currentInput = sanitizeExtension(target.value);
  }

  private handleKeypadPress(key: string): void {
    this.currentInput += key;
    this.requestUpdate();
  }

  private toggleKeypad(): void {
    this.showKeypad = !this.showKeypad;
  }

  private clearInput(): void {
    this.currentInput = "";
  }

  private async manualRetry(): Promise<void> {
    this.connectionAttempts = 0;
    this.error = null;
    await this.attemptConnection();
  }

  private async callContact(contact: SIPContact, withVideo = true): Promise<void> {
    if (!this.callManager || !this.registered) return;

    try {
      await this.callManager.makeCall(contact.extension, withVideo);
      console.log(`Video call started to ${contact.name}`);
    } catch (error) {
      console.error("Failed to call contact:", error);
      this.error = `Failed to call ${contact.name}`;
    }
  }

  private async makeVideoCall(): Promise<void> {
    if (!this.callManager || !this.registered || !this.currentInput.trim()) return;

    try {
      await this.callManager.makeCall(this.currentInput.trim(), true);
      this.currentInput = "";
      this.showKeypad = false;
    } catch (error) {
      console.error("Failed to make video call:", error);
      this.error = "Failed to make video call";
    }
  }

  private isAnsweringCall = false; // Flag to prevent multiple simultaneous answer calls

  private async answerCall(withVideo = true): Promise<void> {
    if (!this.callManager) return;

    // Prevent multiple simultaneous answer calls
    if (this.isAnsweringCall) {
      console.warn("Call is already being answered, ignoring duplicate request");
      return;
    }

    try {
      this.isAnsweringCall = true;
      
      if (withVideo) {
        await this.callManager.enableVideo();
      }
      await this.callManager.answerCall();
    } catch (error) {
      console.error("Failed to answer call:", error);
      this.error = "Failed to answer call";
    } finally {
      this.isAnsweringCall = false;
    }
  }

  private async rejectCall(): Promise<void> {
    if (!this.callManager) return;

    try {
      await this.callManager.rejectCall();
    } catch (error) {
      console.error("Failed to reject call:", error);
    }
  }

  private async hangupCall(): Promise<void> {
    if (!this.callManager) return;

    try {
      await this.callManager.hangupCall();
      this.showKeypad = false;
    } catch (error) {
      console.error("Failed to hangup call:", error);
    }
  }

  private async toggleMute(): Promise<void> {
    if (!this.callManager) return;

    try {
      await this.callManager.toggleMute();
    } catch (error) {
      console.error("Failed to toggle mute:", error);
      this.error = "Failed to toggle mute";
    }
  }

  private sendDTMF(tone: string): void {
    if (!this.callManager) return;
    this.callManager.sendDTMF(tone);
  }

  static get styles(): CSSResultGroup {
    return [
      sharedStyles,
      css`
        .card-title {
          font-weight: 500;
          font-size: 16px;
        }

        .status-bar {
          display: flex;
          align-items: center;
          justify-content: space-between;
          padding: 12px 16px;
          border-bottom: 1px solid var(--divider-color);
        }

        .status-indicator {
          display: flex;
          align-items: center;
          gap: 8px;
        }

        .status-dot {
          width: 8px;
          height: 8px;
          border-radius: 50%;
          animation: pulse 2s infinite;
        }

        .status-dot.connected {
          background: var(--success-color, #4caf50);
          animation: none;
        }

        .status-dot.connecting {
          background: var(--warning-color, #ff9800);
        }

        .status-dot.retrying {
          background: var(--info-color, #2196f3);
        }

        .status-dot.disconnected {
          background: var(--error-color, #f44336);
        }

        @keyframes pulse {
          0%,
          100% {
            opacity: 1;
          }
          50% {
            opacity: 0.5;
          }
        }

        .error-message {
          display: flex;
          align-items: flex-start;
          gap: 12px;
          padding: 16px;
          margin: 16px;
          background: rgba(var(--error-color-rgb, 244, 67, 54), 0.1);
          border: 1px solid var(--error-color, #f44336);
          border-radius: 8px;
          color: var(--error-color, #f44336);
        }

        .error-message.multiline {
          align-items: flex-start;
        }

        .error-message ha-icon {
          flex-shrink: 0;
          margin-top: 2px;
        }

        .error-text div {
          margin: 2px 0;
          font-size: 13px;
        }

        .contacts-section {
          margin-bottom: 24px;
        }

        .section-header {
          display: flex;
          align-items: center;
          gap: 12px;
          margin-bottom: 16px;
          padding: 0 4px;
        }

        .section-header ha-icon {
          color: var(--primary-color);
          font-size: 20px;
        }

        .section-header h3 {
          margin: 0;
          font-size: 16px;
          font-weight: 500;
          color: var(--primary-text-color);
          flex: 1;
        }

        .contact-count {
          background: var(--primary-color);
          color: white;
          font-size: 12px;
          font-weight: 500;
          padding: 2px 8px;
          border-radius: 12px;
          min-width: 16px;
          text-align: center;
        }

        .no-contacts {
          display: flex;
          flex-direction: column;
          align-items: center;
          padding: 48px 16px;
          text-align: center;
          background: var(--card-background-color);
          border: 2px dashed var(--divider-color);
          border-radius: 16px;
          margin-bottom: 24px;
        }

        .no-contacts ha-icon {
          font-size: 48px;
          color: var(--disabled-text-color);
          margin-bottom: 16px;
        }

        .no-contacts-text {
          font-size: 16px;
          font-weight: 500;
          color: var(--primary-text-color);
          margin-bottom: 4px;
        }

        .no-contacts-subtitle {
          font-size: 14px;
          color: var(--secondary-text-color);
        }

        .contacts-list {
          display: flex;
          flex-direction: column;
          gap: 8px;
        }

        .contact-item {
          display: flex;
          align-items: center;
          padding: 16px;
          background: var(--card-background-color);
          border: 1px solid var(--divider-color);
          border-radius: 16px;
          transition: all 0.2s ease;
          position: relative;
          overflow: hidden;
        }

        .contact-item::before {
          content: "";
          position: absolute;
          left: 0;
          top: 0;
          bottom: 0;
          width: 4px;
          background: var(--primary-color);
          transform: scaleY(0);
          transition: transform 0.2s ease;
        }

        .contact-item:hover:not([disabled]) {
          border-color: var(--primary-color);
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
          transform: translateY(-2px);
        }

        .contact-item:hover:not([disabled])::before {
          transform: scaleY(1);
        }

        .contact-item[disabled] {
          opacity: 0.6;
          cursor: not-allowed;
        }

        .contact-item[disabled] .action-btn {
          pointer-events: none;
        }

        .contact-avatar {
          width: 48px;
          height: 48px;
          border-radius: 50%;
          background: linear-gradient(135deg, var(--primary-color), var(--accent-color, var(--primary-color)));
          display: flex;
          align-items: center;
          justify-content: center;
          margin-right: 16px;
          flex-shrink: 0;
        }

        .contact-avatar ha-icon {
          font-size: 24px;
          color: white;
        }

        .contact-info {
          flex: 1;
          min-width: 0;
        }

        .contact-name {
          font-size: 16px;
          font-weight: 500;
          color: var(--primary-text-color);
          margin-bottom: 4px;
          white-space: nowrap;
          overflow: hidden;
          text-overflow: ellipsis;
        }

        .contact-details {
          display: flex;
          align-items: center;
          gap: 8px;
        }

        .contact-extension {
          font-size: 14px;
          color: var(--secondary-text-color);
          font-family: var(--code-font-family, monospace);
          background: var(--secondary-background-color);
          padding: 2px 6px;
          border-radius: 4px;
        }

        .video-badge {
          font-size: 11px;
          font-weight: 500;
          color: var(--primary-color);
          background: rgba(var(--primary-color-rgb, 33, 150, 243), 0.1);
          padding: 2px 6px;
          border-radius: 8px;
          text-transform: uppercase;
          letter-spacing: 0.5px;
        }

        .contact-actions {
          display: flex;
          gap: 8px;
          flex-shrink: 0;
        }

        .action-btn {
          width: 44px;
          height: 44px;
          border: none;
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
          cursor: pointer;
          transition: all 0.2s ease;
          position: relative;
          overflow: hidden;
        }

        .action-btn::before {
          content: "";
          position: absolute;
          inset: 0;
          background: currentColor;
          opacity: 0;
          transition: opacity 0.2s ease;
        }

        .action-btn:hover::before {
          opacity: 0.1;
        }

        .action-btn:active {
          transform: scale(0.95);
        }

        .action-btn ha-icon {
          font-size: 20px;
          z-index: 1;
        }

        .video-btn {
          background: var(--primary-color);
          color: white;
          box-shadow: 0 2px 4px rgba(var(--primary-color-rgb, 33, 150, 243), 0.3);
        }

        .video-btn:hover {
          box-shadow: 0 4px 12px rgba(var(--primary-color-rgb, 33, 150, 243), 0.4);
          transform: translateY(-2px);
        }

        .action-btn:disabled {
          opacity: 0.5;
          cursor: not-allowed;
          transform: none !important;
          box-shadow: none !important;
        }

        .manual-dial {
          margin-top: 24px;
          padding-top: 24px;
          border-top: 1px solid var(--sip-divider-color);
        }

        .dial-input-container {
          display: flex;
          gap: 8px;
          margin-bottom: 16px;
        }

        .dial-input-container ha-textfield {
          flex: 1;
        }

        .dial-actions {
          display: flex;
          gap: 12px;
          justify-content: center;
          flex-wrap: wrap;
        }

        .active-call {
          padding: 16px;
        }

        .call-status {
          font-size: 14px;
          color: var(--sip-text-secondary-color);
          margin-bottom: 8px;
        }

        .in-call-keypad {
          margin-top: 16px;
          padding-top: 16px;
          border-top: 1px solid var(--sip-divider-color);
        }

        .video-container {
          position: relative;
          width: 100%;
          height: 240px;
          background: #000;
          border-radius: 12px;
          overflow: hidden;
          margin-bottom: 16px;
          display: flex;
          align-items: center;
          justify-content: center;
        }

        .video-container video {
          width: 100%;
          height: 100%;
          object-fit: contain;
          background: #000;
          border-radius: 12px;
        }

        .video-container.has-video video {
          opacity: 1;
        }

        .video-container.no-video video {
          opacity: 0;
        }

        .video-overlay {
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          text-align: center;
          color: var(--primary-text-color);
          opacity: 0.7;
        }

        .video-overlay ha-icon {
          font-size: 48px;
          margin-bottom: 8px;
        }

        .video-status {
          display: flex;
          justify-content: center;
          gap: 16px;
          padding: 8px 16px;
          background: var(--secondary-background-color);
          border-radius: 8px;
          margin-bottom: 16px;
        }

        .video-indicator {
          display: flex;
          align-items: center;
          gap: 8px;
          padding: 4px 12px;
          border-radius: 16px;
          font-size: 12px;
          font-weight: 500;
          transition: all 0.2s ease;
        }

        .video-indicator.active {
          background: rgba(var(--success-color-rgb, 76, 175, 80), 0.1);
          color: var(--success-color, #4caf50);
        }

        .video-indicator.active ha-icon {
          color: var(--success-color, #4caf50);
        }

        .video-indicator.inactive {
          background: rgba(var(--disabled-text-color-rgb, 128, 128, 128), 0.1);
          color: var(--disabled-text-color, #808080);
        }

        .video-indicator.inactive ha-icon {
          color: var(--disabled-text-color, #808080);
        }

        .control-button.primary {
          background: var(--sip-success-color);
          color: white;
        }

        .control-button.video {
          background: var(--primary-color);
          color: white;
        }

        .control-button.secondary {
          background: var(--secondary-background-color);
          color: var(--primary-text-color);
        }

        .control-button.danger {
          background: var(--sip-danger-color);
          color: white;
        }

        .incoming-call-actions {
          display: flex;
          justify-content: center;
          gap: 24px;
        }

        .video-answer-button {
          background: var(--primary-color);
          border: none;
          border-radius: 50%;
          width: 64px;
          height: 64px;
          color: white;
          font-size: 24px;
          cursor: pointer;
          transition: all 0.2s ease;
        }

        .video-answer-button:hover {
          transform: scale(1.1);
        }

        ha-button.video-call {
          --mdc-theme-primary: var(--primary-color);
        }

        ha-textfield {
          width: 100%;
        }

        ha-icon-button {
          --mdc-icon-button-size: 40px;
        }

        @media (max-width: 600px) {
          .contact-item {
            padding: 12px;
          }

          .contact-avatar {
            width: 40px;
            height: 40px;
            margin-right: 12px;
          }

          .contact-avatar ha-icon {
            font-size: 20px;
          }

          .action-btn {
            width: 40px;
            height: 40px;
          }

          .action-btn ha-icon {
            font-size: 18px;
          }

          .contact-name {
            font-size: 15px;
          }

          .contact-extension {
            font-size: 13px;
          }

          .video-container {
            height: 200px;
          }
        }

        @media (max-width: 400px) {
          .section-header {
            margin-bottom: 12px;
          }

          .contacts-list {
            gap: 6px;
          }

          .contact-item {
            padding: 10px;
          }

          .contact-actions {
            gap: 6px;
          }

          .video-container {
            height: 160px;
          }
        }
      `,
    ];
  }
}

declare global {
  interface HTMLElementTagNameMap {
    "ha-webrtc-sip-card": WebRTCSipCard;
  }
}

(window as any).customCards = (window as any).customCards || [];
(window as any).customCards.push({
  type: "ha-webrtc-sip-card",
  name: "WebRTC SIP Card",
  description: "A modern WebRTC SIP client card for Home Assistant",
  version: CARD_VERSION,
});

console.info(
  `%c HA-WEBRTC-SIP-CARD %c ${CARD_VERSION} `,
  "color: white; background: #03a9f4; font-weight: bold;",
  "color: #03a9f4; background: white; font-weight: bold;"
);

---

=== Object: 6179d941a2a8a7ec99990675a1677c043f13ab52 | Date: 2025-09-23 15:28:55 | Type: blob ===

import { debugLog, errorLog } from "./utils";

type SimpleUser = any;
type SimpleUserOptions = any;
let Web: any = null;

export interface SipConfig {
  server: string;
  username: string;
  password: string;
  domain: string;
  websocket_port: number;
  use_secure: boolean;
  display_name?: string;
  debug?: boolean;
}

export interface CallInfo {
  id: string;
  remoteIdentity: string;
  displayName: string;
  state: "incoming" | "outgoing" | "connected" | "ended";
  startTime?: Date;
  duration: number;
}

export class SipManager extends EventTarget {
  private simpleUser: SimpleUser | null = null;
  private config: SipConfig | null = null;
  private isRegistered = false;
  private isConnected = false;
  private connectionTimer: number | null = null;
  private currentCall: CallInfo | null = null;
  private remoteAudio: HTMLAudioElement | null = null;
  private remoteVideo: HTMLVideoElement | null = null;
  private localVideo: HTMLVideoElement | null = null;
  private localStream: MediaStream | null = null;
  private videoEnabled = false;
  private isInitialized = false;
  private isInitializing = false;
  private lastVideoState = false;

  constructor() {
    super();
    this.setupMediaElements();
  }

  private setupMediaElements(): void {
    this.remoteAudio = document.createElement("audio");
    this.remoteAudio.autoplay = true;
    this.remoteAudio.style.display = "none";
    document.body.appendChild(this.remoteAudio);

    this.remoteVideo = document.createElement("video");
    this.remoteVideo.autoplay = true;
    this.remoteVideo.playsInline = true;
    this.remoteVideo.style.display = "none";
    document.body.appendChild(this.remoteVideo);

    this.localVideo = document.createElement("video");
    this.localVideo.autoplay = true;
    this.localVideo.muted = true;
    this.localVideo.playsInline = true;
    this.localVideo.style.display = "none";
    document.body.appendChild(this.localVideo);
  }

  private async getUserMedia(includeVideo: boolean = false): Promise<MediaStream> {
    const constraints: MediaStreamConstraints = {
      audio: {
        echoCancellation: true,
        noiseSuppression: true,
        autoGainControl: true,
        sampleRate: 48000,
      },
      video: includeVideo
        ? {
            width: { ideal: 640, min: 320, max: 1280 },
            height: { ideal: 480, min: 240, max: 720 },
            frameRate: { ideal: 30, min: 15, max: 30 },
            facingMode: "user",
          }
        : false,
    };

    return navigator.mediaDevices.getUserMedia(constraints);
  }

  public async enableVideo(): Promise<void> {
    try {
      const stream = await this.getUserMedia(true);

      if (this.localStream) {
        this.localStream.getTracks().forEach((track) => track.stop());
      }

      if (this.localVideo) {
        this.localVideo.srcObject = stream;
      }

      this.localStream = stream;
      this.videoEnabled = true;

      debugLog(this.config?.debug || false, "Local video enabled with new stream:", {
        videoTracks: stream.getVideoTracks().length,
        audioTracks: stream.getAudioTracks().length,
        streamId: stream.id,
      });

      if (this.simpleUser?.session && this.currentCall?.state === "connected") {
        await this.replaceMediaTracks(stream);
      }

      this.dispatchEvent(
        new CustomEvent("localVideoChanged", {
          detail: {
            enabled: true,
            transmitting: stream.getVideoTracks().some((track) => track.enabled && track.readyState === "live"),
          },
        })
      );
    } catch (error) {
      errorLog("Enable video failed", error);
      this.videoEnabled = false;
      throw error;
    }
  }

  public async disableVideo(): Promise<void> {
    try {
      const audioOnlyStream = await this.getUserMedia(false);

      if (this.localVideo) {
        this.localVideo.srcObject = null;
      }

      if (this.localStream) {
        this.localStream.getTracks().forEach((track) => {
          track.stop();
          debugLog(this.config?.debug || false, `Stopped ${track.kind} track:`, track.id);
        });
      }

      this.localStream = audioOnlyStream;
      this.videoEnabled = false;

      debugLog(this.config?.debug || false, "Local video disabled, using audio-only stream:", {
        videoTracks: audioOnlyStream.getVideoTracks().length,
        audioTracks: audioOnlyStream.getAudioTracks().length,
        streamId: audioOnlyStream.id,
      });

      if (this.simpleUser?.session && this.currentCall?.state === "connected") {
        await this.replaceMediaTracks(audioOnlyStream);
      }

      this.dispatchEvent(
        new CustomEvent("localVideoChanged", {
          detail: {
            enabled: false,
            transmitting: false,
          },
        })
      );
    } catch (error) {
      errorLog("Disable video failed", error);
      throw error;
    }
  }

  private async replaceMediaTracks(newStream: MediaStream): Promise<void> {
    try {
      const session = this.simpleUser?.session;
      if (!session || !session.sessionDescriptionHandler) {
        debugLog(this.config?.debug || false, "No active session to replace tracks");
        return;
      }

      const pc = session.sessionDescriptionHandler.peerConnection;
      if (!pc) {
        debugLog(this.config?.debug || false, "No peer connection found");
        return;
      }

      const senders = pc.getSenders();

      const audioTrack = newStream.getAudioTracks()[0];
      const audioSender = senders.find((sender: any) => sender.track && sender.track.kind === "audio");
      if (audioSender && audioTrack) {
        await audioSender.replaceTrack(audioTrack);
        debugLog(this.config?.debug || false, "Audio track replaced successfully");
      }

      const videoTrack = newStream.getVideoTracks()[0] || null;
      const videoSender = senders.find((sender: any) => sender.track && sender.track.kind === "video");

      if (videoSender) {
        await videoSender.replaceTrack(videoTrack);
        debugLog(this.config?.debug || false, videoTrack ? "Video track replaced" : "Video track removed from sender");
      } else if (videoTrack) {
        try {
          pc.addTrack(videoTrack, newStream);
          debugLog(this.config?.debug || false, "Video track added to peer connection");

          if (session.sessionDescriptionHandler && typeof session.sessionDescriptionHandler.sendReinvite === "function") {
            await session.sessionDescriptionHandler.sendReinvite();
            debugLog(this.config?.debug || false, "Session renegotiated for new video track");
          }
        } catch (error) {
          debugLog(this.config?.debug || false, "Failed to add video track:", error);
        }
      }
    } catch (error) {
      debugLog(this.config?.debug || false, "Replace media tracks failed but call continues:", error);
    }
  }

  public async toggleVideo(): Promise<boolean> {
    try {
      if (this.videoEnabled) {
        await this.disableVideo();
        return false;
      } else {
        await this.enableVideo();
        return true;
      }
    } catch (error) {
      errorLog("Toggle video failed", error);
      throw error;
    }
  }

  public getLocalVideoState(): { enabled: boolean; transmitting: boolean } {
    return {
      enabled: this.videoEnabled,
      transmitting: this.localStream ? this.localStream.getVideoTracks().some((track) => track.enabled && track.readyState === "live") : false,
    };
  }

  private setupRemoteStreamHandlers(session: any): void {
    try {
      const sessionDescriptionHandler = session.sessionDescriptionHandler;
      if (!sessionDescriptionHandler) {
        debugLog(this.config?.debug || false, "No session description handler");
        return;
      }

      const pc = sessionDescriptionHandler.peerConnection;
      if (!pc) {
        debugLog(this.config?.debug || false, "No peer connection");
        return;
      }

      debugLog(this.config?.debug || false, "Setting up remote stream handlers for", pc.connectionState);

      pc.ontrack = (event: RTCTrackEvent) => {
        debugLog(this.config?.debug || false, "Remote track received:", {
          kind: event.track.kind,
          readyState: event.track.readyState,
          enabled: event.track.enabled,
          streams: event.streams.length,
          transceiver: event.transceiver.direction,
        });

        const stream = event.streams[0];
        if (!stream) {
          debugLog(this.config?.debug || false, "No stream in track event");
          return;
        }

        if (event.track.kind === "audio") {
          if (this.remoteAudio) {
            this.remoteAudio.srcObject = stream;
            debugLog(this.config?.debug || false, "Remote audio stream attached");
          }
        } else if (event.track.kind === "video") {
          if (this.remoteVideo) {
            this.remoteVideo.srcObject = stream;
            this.remoteVideo.autoplay = true;
            this.remoteVideo.playsInline = true;

            debugLog(this.config?.debug || false, "Remote video stream attached, playing...");

            // Handle video play with better error handling
            if (this.remoteVideo.srcObject) {
              const playPromise = this.remoteVideo.play();
              if (playPromise !== undefined) {
                playPromise
                  .then(() => {
                    debugLog(this.config?.debug || false, "Remote video playing successfully");
                  })
                  .catch((error) => {
                    debugLog(this.config?.debug || false, "Remote video play failed:", error);
                    
                    // Handle specific error types
                    if (error.name === "NotAllowedError") {
                      debugLog(this.config?.debug || false, "Video play not allowed, likely due to autoplay restrictions");
                      
                      // Try to handle autoplay restrictions by muting and retrying
                      if (this.remoteVideo) {
                        this.remoteVideo.muted = true;
                        const retryPromise = this.remoteVideo.play();
                        if (retryPromise !== undefined) {
                          retryPromise.catch((retryError) => {
                            debugLog(this.config?.debug || false, "Muted video play retry failed:", retryError);
                            
                            // Last resort: re-attach the stream
                            if (this.remoteVideo && this.remoteVideo.srcObject) {
                              const currentStream = this.remoteVideo.srcObject;
                              this.remoteVideo.srcObject = null;
                              this.remoteVideo.srcObject = currentStream;
                              setTimeout(() => {
                                if (this.remoteVideo && this.remoteVideo.srcObject) {
                                  this.remoteVideo.muted = true;
                                  const finalPromise = this.remoteVideo.play();
                                  if (finalPromise !== undefined) {
                                    finalPromise.catch((finalError) => {
                                      debugLog(this.config?.debug || false, "Final video play attempt failed:", finalError);
                                    });
                                  }
                                }
                              }, 100);
                            }
                          });
                        }
                      }
                                      } else if (error.name === "AbortError") {
                    debugLog(this.config?.debug || false, "Video play was interrupted, this is normal during stream updates");
                    
                    // Retry after a short delay, but be more careful about the timing
                    setTimeout(() => {
                      if (this.remoteVideo && this.remoteVideo.srcObject) {
                        // Check if the video element is in a playable state
                        if (this.remoteVideo.readyState >= 2) { // HAVE_CURRENT_DATA
                          const retryPromise = this.remoteVideo.play();
                          if (retryPromise !== undefined) {
                            retryPromise.catch((retryError) => {
                              debugLog(this.config?.debug || false, "Video play retry failed:", retryError);
                            });
                          }
                        } else {
                          // If not ready, wait a bit more
                          setTimeout(() => {
                            if (this.remoteVideo && this.remoteVideo.srcObject) {
                              const retryPromise = this.remoteVideo.play();
                              if (retryPromise !== undefined) {
                                retryPromise.catch((retryError) => {
                                  debugLog(this.config?.debug || false, "Delayed video play retry failed:", retryError);
                                });
                              }
                            }
                          }, 200);
                        }
                      }
                    }, 150);
                    } else {
                      // Try to handle other errors by re-attaching the stream
                      if (this.remoteVideo && this.remoteVideo.srcObject) {
                        const currentStream = this.remoteVideo.srcObject;
                        this.remoteVideo.srcObject = null;
                        this.remoteVideo.srcObject = currentStream;
                        setTimeout(() => {
                          if (this.remoteVideo && this.remoteVideo.srcObject) {
                            const retryPromise = this.remoteVideo.play();
                            if (retryPromise !== undefined) {
                              retryPromise.catch((retryError) => {
                                debugLog(this.config?.debug || false, "Remote video play retry failed:", retryError);
                              });
                            }
                          }
                        }, 100);
                      }
                    }
                  });
              }
            }

            const videoTracks = stream.getVideoTracks();
            const hasActiveVideo = videoTracks.length > 0 && videoTracks.some((track) => track.enabled);

            debugLog(this.config?.debug || false, "Video track details:", {
              trackCount: videoTracks.length,
              hasActive: hasActiveVideo,
              trackStates: videoTracks.map((t) => ({
                id: t.id,
                enabled: t.enabled,
                readyState: t.readyState,
                label: t.label,
              })),
            });

            this.lastVideoState = hasActiveVideo;

            this.dispatchEvent(
              new CustomEvent("remoteVideoChanged", {
                detail: {
                  enabled: true,
                  stream: stream,
                  hasVideoTracks: hasActiveVideo,
                },
              })
            );

            setTimeout(() => {
              this.dispatchEvent(
                new CustomEvent("remoteVideoChanged", {
                  detail: {
                    enabled: true,
                    stream: stream,
                    hasVideoTracks: hasActiveVideo,
                  },
                })
              );
            }, 200);
          }
        }
      };

      pc.oniceconnectionstatechange = () => {
        debugLog(this.config?.debug || false, "ICE connection state changed:", pc.iceConnectionState);

        if (pc.iceConnectionState === "failed") {
          errorLog("ICE connection failed - attempting to recover");
          this.handleIceConnectionFailure(pc);
        }
      };

      pc.onicegatheringstatechange = () => {
        debugLog(this.config?.debug || false, "ICE gathering state changed:", pc.iceGatheringState);
      };

      pc.onicecandidate = (event: RTCPeerConnectionIceEvent) => {
        if (event.candidate) {
          debugLog(this.config?.debug || false, "ICE candidate:", event.candidate.type, event.candidate.candidate);
        } else {
          debugLog(this.config?.debug || false, "ICE gathering complete");
        }
      };

      pc.onconnectionstatechange = () => {
        debugLog(this.config?.debug || false, "Connection state changed:", pc.connectionState);

        if (pc.connectionState === "failed") {
          errorLog("Peer connection failed completely");
          this.handleConnectionFailure();
        } else if (pc.connectionState === "connected") {
          setTimeout(() => {
            const transceivers = pc.getTransceivers();
            debugLog(this.config?.debug || false, "Checking transceivers:", transceivers.length);

            transceivers.forEach((transceiver: RTCRtpTransceiver, index: number) => {
              debugLog(this.config?.debug || false, `Transceiver ${index}:`, {
                direction: transceiver.direction,
                kind: transceiver.receiver?.track?.kind,
                trackState: transceiver.receiver?.track?.readyState,
                hasTrack: !!transceiver.receiver?.track,
              });

              if (transceiver.receiver?.track?.kind === "video" && transceiver.receiver.track.readyState === "live") {
                debugLog(this.config?.debug || false, "Found active video transceiver");

                let videoStream: MediaStream;
                if (this.remoteVideo?.srcObject instanceof MediaStream) {
                  videoStream = this.remoteVideo.srcObject;
                } else {
                  videoStream = new MediaStream([transceiver.receiver.track]);
                  if (this.remoteVideo) {
                    this.remoteVideo.srcObject = videoStream;
                  }
                }

                this.dispatchEvent(
                  new CustomEvent("remoteVideoChanged", {
                    detail: {
                      enabled: true,
                      stream: videoStream,
                      hasVideoTracks: true,
                    },
                  })
                );
              }
            });
          }, 500);
        }
      };

      pc.onremovetrack = (event: RTCTrackEvent) => {
        debugLog(this.config?.debug || false, "Remote track removed:", event.track.kind);

        if (event.track.kind === "video" && this.remoteVideo) {
          this.remoteVideo.srcObject = null;
          this.lastVideoState = false;

          this.dispatchEvent(
            new CustomEvent("remoteVideoChanged", {
              detail: {
                enabled: false,
                stream: null,
                hasVideoTracks: false,
              },
            })
          );
        }
      };
    } catch (error) {
      errorLog("Failed to setup remote stream handlers:", error);
    }
  }

  private handleIceConnectionFailure(pc: RTCPeerConnection): void {
    debugLog(this.config?.debug || false, "Attempting ICE restart");

    setTimeout(() => {
      if (pc.iceConnectionState === "failed") {
        try {
          pc.restartIce();
          debugLog(this.config?.debug || false, "ICE restart initiated");
        } catch (error) {
          errorLog("ICE restart failed:", error);
        }
      }
    }, 1000);
  }

  private handleConnectionFailure(): void {
    errorLog("Connection failed - notifying UI");

    this.dispatchEvent(
      new CustomEvent("error", {
        detail: {
          error: "Connection failed - check network and STUN servers",
          type: "connection_failure",
        },
      })
    );
  }

  private async waitForSipLibrary(timeout = 15000): Promise<void> {
    return new Promise<void>(async (resolve, reject) => {
      const startTime = Date.now();
      const timeoutId = setTimeout(() => {
        reject(new Error(`SIP.js library loading timeout after ${timeout}ms`));
      }, timeout);

      const checkLibrary = async () => {
        try {
          if (!Web) {
            const SIP = await import("sip.js");
            Web = (SIP as any).Web || SIP;
          }

          const isFullyLoaded =
            Web &&
            Web.SimpleUser &&
            Web.SimpleUser.prototype &&
            typeof Web.SimpleUser.prototype.register === "function" &&
            typeof Web.SimpleUser.prototype.connect === "function" &&
            typeof Web.SimpleUser.prototype.disconnect === "function";

          if (isFullyLoaded) {
            clearTimeout(timeoutId);
            debugLog(this.config?.debug || false, "SIP.js library fully loaded and verified");
            resolve();
            return;
          }

          if (Date.now() - startTime > timeout) {
            clearTimeout(timeoutId);
            reject(new Error("SIP.js library verification timeout"));
            return;
          }

          setTimeout(checkLibrary, 100);
        } catch (error) {
          setTimeout(checkLibrary, 200);
        }
      };

      checkLibrary();
    });
  }

  private async ensureSipClient(): Promise<void> {
    if (this.isInitialized) return;

    if (this.isInitializing) {
      return new Promise((resolve, reject) => {
        const checkInterval = setInterval(() => {
          if (this.isInitialized) {
            clearInterval(checkInterval);
            resolve();
          } else if (!this.isInitializing) {
            clearInterval(checkInterval);
            reject(new Error("Initialization failed"));
          }
        }, 100);
      });
    }

    if (!this.config) {
      throw new Error("SIP configuration not set");
    }

    await this.initialize(this.config);
  }

  setConfig(config: SipConfig): void {
    this.config = config;
    debugLog(config.debug || false, "SIP configuration set, will initialize on first use");
  }

  async initialize(config: SipConfig): Promise<void> {
    if (this.isInitializing || this.isInitialized) return;

    this.isInitializing = true;
    this.config = config;

    debugLog(config.debug || false, "Starting lazy SIP initialization");

    try {
      await this.waitForSipLibrary();
      await new Promise((resolve) => setTimeout(resolve, 500));

      const wsProtocol = config.use_secure ? "wss" : "ws";
      const wsPort = config.websocket_port || (config.use_secure ? 443 : 80);
      const wsServer = `${wsProtocol}://${config.server}:${wsPort}`;
      const sipAor = `sip:${config.username}@${config.domain}`;

      debugLog(config.debug || false, "WebSocket URL:", wsServer);
      debugLog(config.debug || false, "SIP AOR:", sipAor);

      const getMediaOptions = (includeVideo: boolean = false) => ({
        constraints: includeVideo
          ? {
              audio: {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true,
              },
              video: {
                width: { ideal: 640 },
                height: { ideal: 480 },
                frameRate: { ideal: 30 },
              },
            }
          : {
              audio: {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true,
              },
              video: false,
            },
        remote: {
          audio: this.remoteAudio!,
          video: this.remoteVideo!,
        },
      });

      const options: SimpleUserOptions = {
        aor: sipAor,
        media: getMediaOptions(false),
        userAgentOptions: {
          authorizationUsername: config.username,
          authorizationPassword: config.password,
          displayName: config.display_name || config.username,
          transportOptions: {
            server: wsServer,
            connectionTimeout: 15,
            maxReconnectionAttempts: 3,
            reconnectionTimeout: 4,
          },
          logLevel: config.debug ? "debug" : "error",
          sessionDescriptionHandlerFactoryOptions: {
            constraints: {
              audio: true,
              video: false,
            },
            peerConnectionConfiguration: {
              iceServers: [
                { urls: "stun:stun.l.google.com:19302" },
                { urls: "stun:stun1.l.google.com:19302" },
                { urls: "stun:stun2.l.google.com:19302" },
                { urls: "stun:stun3.l.google.com:19302" },
              ],
              iceCandidatePoolSize: 10,
              iceTransportPolicy: "all",
              bundlePolicy: "balanced",
              rtcpMuxPolicy: "require",
            },
          },
        },
      };

      if (!Web || !Web.SimpleUser) {
        throw new Error("SIP.js Web.SimpleUser not available after loading");
      }

      this.simpleUser = new Web.SimpleUser(wsServer, options);

      if (!this.simpleUser) {
        throw new Error("Failed to create SimpleUser instance");
      }

      if (!this.simpleUser.register || typeof this.simpleUser.register !== "function") {
        throw new Error("SimpleUser register method not available - library incomplete");
      }

      debugLog(config.debug || false, "SimpleUser created and verified successfully");

      this.setupEventHandlers();

      debugLog(config.debug || false, `Connecting to: ${wsServer}`);
      await this.simpleUser.connect();

      this.isConnected = true;
      this.dispatchEvent(new CustomEvent("connected"));
      debugLog(config.debug || false, "Connected to WebSocket server");

      debugLog(config.debug || false, "Registering with SIP server...");
      await this.simpleUser.register();

      this.isRegistered = true;
      this.dispatchEvent(new CustomEvent("registered", { detail: { registered: true } }));

      this.startConnectionMonitoring();

      this.isInitialized = true;
      this.isInitializing = false;

      debugLog(config.debug || false, "SIP client lazy initialization completed successfully");
    } catch (error) {
      this.isInitializing = false;
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      errorLog("SIP lazy initialization failed:", errorMessage);

      this.isConnected = false;
      this.isRegistered = false;

      if (this.simpleUser) {
        try {
          await this.simpleUser.disconnect();
        } catch (cleanupError) {
          debugLog(config.debug || false, "Cleanup error", cleanupError);
        }
        this.simpleUser = null;
      }

      this.dispatchEvent(
        new CustomEvent("error", {
          detail: {
            error: errorMessage,
            type: "initialization",
          },
        })
      );

      throw new Error(`Failed to initialize SIP client: ${errorMessage}`);
    }
  }

  private setupEventHandlers(): void {
    if (!this.simpleUser) {
      errorLog("Cannot setup event handlers: SimpleUser is null");
      return;
    }

    debugLog(this.config?.debug || false, "Setting up event handlers");

    this.simpleUser.delegate = {
      onCallCreated: () => {
        debugLog(this.config?.debug || false, "Call created");
        this.dispatchEvent(new CustomEvent("callCreated"));
      },

      onCallReceived: () => {
        debugLog(this.config?.debug || false, "Incoming call received");

        const session = this.simpleUser?.session;
        if (!session) {
          debugLog(this.config?.debug || false, "No session found for incoming call");
          return;
        }

        let remoteIdentity = "unknown";
        let displayName = "Unknown Caller";

        try {
          debugLog(this.config?.debug || false, "Current session state:", session.state);

          this.setupRemoteStreamHandlers(session);

          if (session.request) {
            const fromHeader = session.request.getHeader("From");
            debugLog(this.config?.debug || false, "From header:", fromHeader);

            if (fromHeader) {
              const uriMatches = fromHeader.match(/<sip:([^@]+)@/) || fromHeader.match(/sip:([^@]+)@/);
              if (uriMatches && uriMatches[1]) {
                remoteIdentity = uriMatches[1];
                debugLog(this.config?.debug || false, "Extracted extension from From:", remoteIdentity);
              }

              const nameMatches = fromHeader.match(/^"([^"]*)"/) || fromHeader.match(/^([^<]*)</);
              if (nameMatches && nameMatches[1] && nameMatches[1].trim()) {
                displayName = nameMatches[1].trim();
                debugLog(this.config?.debug || false, "Extracted display name:", displayName);
              } else if (remoteIdentity !== "unknown") {
                displayName = remoteIdentity;
              }
            }
          }

          if (remoteIdentity === "unknown" && session.remoteIdentity) {
            debugLog(this.config?.debug || false, "Trying session.remoteIdentity:", session.remoteIdentity);

            if (session.remoteIdentity.uri) {
              const uriString = session.remoteIdentity.uri.toString();
              debugLog(this.config?.debug || false, "Remote URI:", uriString);

              const matches = uriString.match(/sip:([^@]+)@/);
              if (matches && matches[1]) {
                remoteIdentity = matches[1];
                debugLog(this.config?.debug || false, "Extracted from remote URI:", remoteIdentity);
              }
            }

            if (session.remoteIdentity.displayName) {
              displayName = session.remoteIdentity.displayName;
              debugLog(this.config?.debug || false, "Remote display name:", displayName);
            } else if (remoteIdentity !== "unknown") {
              displayName = remoteIdentity;
            }
          }
        } catch (error) {
          debugLog(this.config?.debug || false, "Error parsing caller info:", error);
        }

        debugLog(this.config?.debug || false, "Final parsed caller info:", { remoteIdentity, displayName });

        this.currentCall = {
          id: Date.now().toString(),
          remoteIdentity: remoteIdentity,
          displayName: displayName,
          state: "incoming",
          duration: 0,
        };

        this.dispatchEvent(
          new CustomEvent("incomingCall", {
            detail: {
              from: remoteIdentity,
              displayName: displayName,
              callInfo: this.currentCall,
            },
          })
        );
      },

      onCallAnswered: () => {
        if (this.currentCall) {
          this.currentCall.state = "connected";
          this.currentCall.startTime = new Date();
        }

        debugLog(this.config?.debug || false, "Call answered");

        if (this.simpleUser?.session) {
          const session = this.simpleUser.session;
          this.setupRemoteStreamHandlers(session);

          // Set up session state change listener for incoming calls as well
          session.stateChange.addListener((newState: any) => {
            debugLog(this.config?.debug || false, "Incoming session state changed:", newState);

            switch (newState) {
              case "Terminated":
              case "Ended":
                debugLog(this.config?.debug || false, "Incoming call ended");
                // Stop local media tracks to release camera and microphone
                if (this.localStream) {
                  this.localStream.getTracks().forEach((track) => {
                    try {
                      track.stop();
                      debugLog(this.config?.debug || false, `Stopped local media track on incoming call end: ${track.kind}`);
                    } catch (error) {
                      debugLog(this.config?.debug || false, `Failed to stop track on incoming call end: ${track.kind}`, error);
                    }
                  });
                  this.localStream = null;
                }
                this.videoEnabled = false;
                
                if (this.currentCall) {
                  this.currentCall.state = "ended";
                  this.dispatchEvent(
                    new CustomEvent("callEnded", {
                      detail: { callInfo: this.currentCall },
                    })
                  );
                }
                break;
            }
          });

          // FIXED: Force remote video check for outgoing calls after answer
          setTimeout(() => {
            this.forceRemoteVideoCheck(session);
          }, 500);
        }

        this.dispatchEvent(
          new CustomEvent("callAnswered", {
            detail: { callInfo: this.currentCall },
          })
        );

        this.startCallTimer();
      },

      onCallHangup: () => {
        debugLog(this.config?.debug || false, "Call ended");

        // Stop local media tracks to release camera and microphone
        if (this.localStream) {
          this.localStream.getTracks().forEach((track) => {
            try {
              track.stop();
              debugLog(this.config?.debug || false, `Stopped local media track: ${track.kind}`);
            } catch (error) {
              debugLog(this.config?.debug || false, `Failed to stop track: ${track.kind}`, error);
            }
          });
          this.localStream = null;
        }

        if (this.remoteVideo) {
          this.remoteVideo.srcObject = null;
        }

        if (this.currentCall) {
          this.currentCall.state = "ended";
        }

        this.stopCallTimer();
        this.dispatchEvent(
          new CustomEvent("callEnded", {
            detail: { callInfo: this.currentCall },
          })
        );

        this.currentCall = null;
        this.lastVideoState = false;
        this.videoEnabled = false;
      },

      onCallHold: (held: boolean) => {
        debugLog(this.config?.debug || false, "Call hold state changed", held);
        this.dispatchEvent(
          new CustomEvent("callHold", {
            detail: { held, callInfo: this.currentCall },
          })
        );
      },

      onRegistered: () => {
        this.isRegistered = true;
        debugLog(this.config?.debug || false, "Registration successful");
        this.dispatchEvent(new CustomEvent("registered", { detail: { registered: true } }));
      },

      onUnregistered: () => {
        this.isRegistered = false;
        debugLog(this.config?.debug || false, "Unregistered");
        this.dispatchEvent(new CustomEvent("registered", { detail: { registered: false } }));
      },

      onServerConnect: () => {
        this.isConnected = true;
        debugLog(this.config?.debug || false, "Server connected");
        this.dispatchEvent(new CustomEvent("connected"));
      },

      onServerDisconnect: () => {
        this.isConnected = false;
        this.isRegistered = false;
        debugLog(this.config?.debug || false, "Server disconnected");
        this.dispatchEvent(new CustomEvent("disconnected"));
      },
    };
  }

  private callTimer: number | null = null;

  private startCallTimer(): void {
    this.stopCallTimer();
    this.callTimer = window.setInterval(() => {
      if (this.currentCall && this.currentCall.startTime) {
        this.currentCall.duration = Math.floor((Date.now() - this.currentCall.startTime.getTime()) / 1000);
        this.dispatchEvent(
          new CustomEvent("callTimer", {
            detail: { duration: this.currentCall.duration, callInfo: this.currentCall },
          })
        );
      }
    }, 1000);
  }

  private stopCallTimer(): void {
    if (this.callTimer) {
      clearInterval(this.callTimer);
      this.callTimer = null;
    }
  }

  private startConnectionMonitoring(): void {
    this.connectionTimer = window.setInterval(() => {
      const connected = this.simpleUser?.isConnected() || false;

      if (connected !== this.isConnected) {
        this.isConnected = connected;
        this.dispatchEvent(
          new CustomEvent("heartbeat", {
            detail: {
              connected,
              registered: this.isRegistered,
            },
          })
        );
      }
    }, 5000);
  }

  async makeCall(target: string, includeVideo = true): Promise<void> {
    await this.ensureSipClient();

    if (!this.simpleUser || !this.isRegistered) {
      throw new Error("SIP client not registered");
    }

    if (this.currentCall) {
      throw new Error("Another call is already in progress");
    }

    try {
      const targetUri = `sip:${target}@${this.config!.domain}`;
      debugLog(this.config?.debug || false, "Making VIDEO call to", targetUri, "with video:", includeVideo);

      if (!this.videoEnabled) {
        await this.enableVideo();
      }
      const mediaStream = this.localStream!;

      this.currentCall = {
        id: Date.now().toString(),
        remoteIdentity: target,
        displayName: target,
        state: "outgoing",
        duration: 0,
      };

      const callOptions = {
        sessionDescriptionHandlerOptions: {
          constraints: {
            audio: true,
            video: true,
          },
          offerToReceiveAudio: true,
          offerToReceiveVideo: true,

          iceGatheringTimeout: 10000,
          rtcConfiguration: {
            iceServers: [
              { urls: "stun:stun.l.google.com:19302" },
              { urls: "stun:stun1.l.google.com:19302" },
              { urls: "stun:stun2.l.google.com:19302" },
              { urls: "stun:stun3.l.google.com:19302" },
            ],
            iceCandidatePoolSize: 10,
            iceTransportPolicy: "all",
            bundlePolicy: "balanced",
            rtcpMuxPolicy: "require",
          },
        },
        sessionDescriptionHandlerFactory: (session: any, options: any) => {
          options.localStream = mediaStream;
          options.remote = {
            audio: this.remoteAudio,
            video: this.remoteVideo,
          };

          return session.sessionDescriptionHandlerFactory(session, options);
        },
      };

      await this.simpleUser.call(targetUri, callOptions);

      // FIXED: Enhanced outgoing call session handling
      if (this.simpleUser.session) {
        const session = this.simpleUser.session;
        debugLog(this.config?.debug || false, "Outgoing call session created, state:", session.state);

        // FIXED: Set up handlers immediately for outgoing calls
        this.setupRemoteStreamHandlers(session);

        // FIXED: Listen for all session state changes
        session.stateChange.addListener((newState: any) => {
          debugLog(this.config?.debug || false, "Outgoing session state changed:", newState);

          switch (newState) {
            case "Establishing":
              debugLog(this.config?.debug || false, "Call is establishing, setting up stream handlers");
              this.setupRemoteStreamHandlers(session);
              break;

            case "Established":
              debugLog(this.config?.debug || false, "Call established, ensuring stream handlers");
              setTimeout(() => {
                this.setupRemoteStreamHandlers(session);
                this.forceRemoteVideoCheck(session);
              }, 100);
              break;

            case "Terminated":
            case "Ended":
              debugLog(this.config?.debug || false, "Outgoing call ended");
              // Stop local media tracks to release camera and microphone
              if (this.localStream) {
                this.localStream.getTracks().forEach((track) => {
                  try {
                    track.stop();
                    debugLog(this.config?.debug || false, `Stopped local media track on outgoing call end: ${track.kind}`);
                  } catch (error) {
                    debugLog(this.config?.debug || false, `Failed to stop track on outgoing call end: ${track.kind}`, error);
                  }
                });
                this.localStream = null;
              }
              this.videoEnabled = false;
              
              if (this.currentCall) {
                this.currentCall.state = "ended";
                this.dispatchEvent(
                  new CustomEvent("callEnded", {
                    detail: { callInfo: this.currentCall },
                  })
                );
              }
              break;
          }
        });

        // FIXED: Also listen for session description handler changes
        const checkForSDH = () => {
          if (session.sessionDescriptionHandler) {
            debugLog(this.config?.debug || false, "Session description handler available for outgoing call");
            this.setupRemoteStreamHandlers(session);
          } else {
            setTimeout(checkForSDH, 100);
          }
        };
        checkForSDH();
      }

      this.dispatchEvent(
        new CustomEvent("callStarted", {
          detail: {
            target,
            callInfo: this.currentCall,
            videoEnabled: true,
          },
        })
      );
    } catch (error) {
      errorLog("Call failed", error);
      
      // Stop local media tracks to release camera and microphone
      if (this.localStream) {
        this.localStream.getTracks().forEach((track) => {
          try {
            track.stop();
            debugLog(this.config?.debug || false, `Stopped local media track on call failure: ${track.kind}`);
          } catch (trackError) {
            debugLog(this.config?.debug || false, `Failed to stop track on call failure: ${track.kind}`, trackError);
          }
        });
        this.localStream = null;
      }
      
      this.currentCall = null;
      this.dispatchEvent(
        new CustomEvent("callFailed", {
          detail: {
            error: error instanceof Error ? error.message : "Call failed",
            target,
          },
        })
      );
      throw error;
    }
  }

  private forceRemoteVideoCheck(session: any): void {
    try {
      if (!session || !session.sessionDescriptionHandler) {
        debugLog(this.config?.debug || false, "No session description handler for video check");
        return;
      }

      const pc = session.sessionDescriptionHandler.peerConnection;
      if (!pc) {
        debugLog(this.config?.debug || false, "No peer connection for video check");
        return;
      }

      debugLog(this.config?.debug || false, "Forcing remote video check, connection state:", pc.connectionState);

      // Check for remote streams
      const remoteStreams = pc.getRemoteStreams ? pc.getRemoteStreams() : [];
      debugLog(this.config?.debug || false, "Remote streams found:", remoteStreams.length);

      if (remoteStreams.length > 0) {
        const remoteStream = remoteStreams[0];
        const videoTracks = remoteStream.getVideoTracks();

        debugLog(this.config?.debug || false, "Found remote stream with video tracks:", videoTracks.length);

        if (videoTracks.length > 0 && this.remoteVideo) {
          this.remoteVideo.srcObject = remoteStream;
          this.remoteVideo.autoplay = true;
          this.remoteVideo.playsInline = true;

          const playPromise = this.remoteVideo.play();
          if (playPromise !== undefined) {
            playPromise.catch((error) => {
              debugLog(this.config?.debug || false, "Remote video play failed:", error);
              // Try to handle the error by re-attaching the stream
              if (this.remoteVideo && this.remoteVideo.srcObject) {
                const currentStream = this.remoteVideo.srcObject;
                this.remoteVideo.srcObject = null;
                this.remoteVideo.srcObject = currentStream;
                setTimeout(() => {
                  if (this.remoteVideo && this.remoteVideo.srcObject) {
                    const retryPromise = this.remoteVideo.play();
                    if (retryPromise !== undefined) {
                      retryPromise.catch((retryError) => {
                        debugLog(this.config?.debug || false, "Remote video play retry failed:", retryError);
                      });
                    }
                  }
                }, 100);
              }
            });
          }

          const hasActiveVideo = videoTracks.some((track: any) => track.enabled && track.readyState === "live");

          this.dispatchEvent(
            new CustomEvent("remoteVideoChanged", {
              detail: {
                enabled: true,
                stream: remoteStream,
                hasVideoTracks: hasActiveVideo,
              },
            })
          );
        }
      }

      // Also check transceivers
      const transceivers = pc.getTransceivers();
      debugLog(this.config?.debug || false, "Checking transceivers for outgoing call:", transceivers.length);

      transceivers.forEach((transceiver: RTCRtpTransceiver, index: number) => {
        if (transceiver.receiver?.track?.kind === "video" && transceiver.receiver.track.readyState === "live") {
          debugLog(this.config?.debug || false, `Found active video transceiver ${index} for outgoing call`);

          if (this.remoteVideo && !this.remoteVideo.srcObject) {
            const videoStream = new MediaStream([transceiver.receiver.track]);
            this.remoteVideo.srcObject = videoStream;
            this.remoteVideo.autoplay = true;
            this.remoteVideo.playsInline = true;

            // Handle video play with better error handling
            if (this.remoteVideo.srcObject) {
              const playPromise = this.remoteVideo.play();
              if (playPromise !== undefined) {
                playPromise
                  .then(() => {
                    debugLog(this.config?.debug || false, "Transceiver video playing successfully");
                  })
                  .catch((error) => {
                    debugLog(this.config?.debug || false, "Transceiver video play failed:", error);
                    // Try to handle the error by re-attaching the stream
                    if (this.remoteVideo && this.remoteVideo.srcObject) {
                      const currentStream = this.remoteVideo.srcObject;
                      this.remoteVideo.srcObject = null;
                      this.remoteVideo.srcObject = currentStream;
                      // Add a small delay before retrying to avoid race conditions
                      setTimeout(() => {
                        if (this.remoteVideo && this.remoteVideo.srcObject) {
                          // Check if the video element is in a playable state
                          if (this.remoteVideo.readyState >= 2) { // HAVE_CURRENT_DATA
                            const retryPromise = this.remoteVideo.play();
                            if (retryPromise !== undefined) {
                              retryPromise.catch((retryError) => {
                                debugLog(this.config?.debug || false, "Transceiver video play retry failed:", retryError);
                              });
                            }
                          } else {
                            // If not ready, wait a bit more
                            setTimeout(() => {
                              if (this.remoteVideo && this.remoteVideo.srcObject) {
                                const retryPromise = this.remoteVideo.play();
                                if (retryPromise !== undefined) {
                                  retryPromise.catch((retryError) => {
                                    debugLog(this.config?.debug || false, "Delayed transceiver video play retry failed:", retryError);
                                  });
                                }
                              }
                            }, 200);
                          }
                        }
                      }, 150);
                    }
                  });
              }
            }

            this.dispatchEvent(
              new CustomEvent("remoteVideoChanged", {
                detail: {
                  enabled: true,
                  stream: videoStream,
                  hasVideoTracks: true,
                },
              })
            );
          }
        }
      });
    } catch (error) {
      debugLog(this.config?.debug || false, "Force remote video check failed:", error);
    }
  }

  async answerCall(): Promise<void> {
    await this.ensureSipClient();

    if (!this.simpleUser) {
      throw new Error("SIP client not available");
    }

    const session = this.simpleUser.session;
    if (!session) {
      throw new Error("No session available to answer");
    }

    if (!this.currentCall || this.currentCall.state !== "incoming") {
      throw new Error("No incoming call to answer");
    }

    const sessionState = session.state;
    debugLog(this.config?.debug || false, "Attempting to answer call, session state:", sessionState);

    if (sessionState === "Terminated" || sessionState === "Ended") {
      throw new Error("Call has already ended");
    }

    if (sessionState !== "Initial") {
      throw new Error(`Cannot answer call in state: ${sessionState}`);
    }

    try {
      if (!this.videoEnabled) {
        await this.enableVideo();
      }
      const mediaStream = this.localStream!;

      const answerOptions = {
        sessionDescriptionHandlerOptions: {
          constraints: {
            audio: true,
            video: true,
          },
          rtcConfiguration: {
            iceServers: [
              { urls: "stun:stun.l.google.com:19302" },
              { urls: "stun:stun1.l.google.com:19302" },
              { urls: "stun:stun2.l.google.com:19302" },
              { urls: "stun:stun3.l.google.com:19302" },
            ],
            iceCandidatePoolSize: 10,
            iceTransportPolicy: "all",
            bundlePolicy: "balanced",
            rtcpMuxPolicy: "require",
          },
        },
        sessionDescriptionHandlerFactory: (session: any, options: any) => {
          options.localStream = mediaStream;
          return session.sessionDescriptionHandlerFactory(session, options);
        },
      };

      await this.simpleUser.answer(answerOptions);
      debugLog(this.config?.debug || false, "Call answered with video:", this.videoEnabled);

      if (this.simpleUser.session) {
        this.setupRemoteStreamHandlers(this.simpleUser.session);
      }
    } catch (error) {
      errorLog("Answer call failed", error);
      throw error;
    }
  }

  async rejectCall(): Promise<void> {
    await this.ensureSipClient();

    if (!this.simpleUser) {
      throw new Error("SIP client not available");
    }

    try {
      await this.simpleUser.decline();

      if (this.currentCall) {
        this.currentCall.state = "ended";
      }

      this.currentCall = null;
      debugLog(this.config?.debug || false, "Call rejected");
    } catch (error) {
      errorLog("Reject call failed", error);
      throw error;
    }
  }

  async hangup(): Promise<void> {
    if (!this.simpleUser) return;

    try {
      await this.simpleUser.hangup();
      debugLog(this.config?.debug || false, "Call hung up");
    } catch (error) {
      errorLog("Hangup failed", error);
      throw error;
    }
  }

  async mute(): Promise<void> {
    if (!this.simpleUser) return;

    try {
      await this.simpleUser.mute();
      debugLog(this.config?.debug || false, "Call muted");
    } catch (error) {
      errorLog("Mute failed", error);
      throw error;
    }
  }

  async unmute(): Promise<void> {
    if (!this.simpleUser) return;

    try {
      await this.simpleUser.unmute();
      debugLog(this.config?.debug || false, "Call unmuted");
    } catch (error) {
      errorLog("Unmute failed", error);
      throw error;
    }
  }

  sendDTMF(tone: string): void {
    if (!this.simpleUser || !this.currentCall) return;

    try {
      if (typeof this.simpleUser.sendDTMF === "function") {
        this.simpleUser.sendDTMF(tone);
        debugLog(this.config?.debug || false, "DTMF sent", tone);

        this.dispatchEvent(
          new CustomEvent("dtmfSent", {
            detail: { tone, callInfo: this.currentCall },
          })
        );
      }
    } catch (error) {
      errorLog("DTMF send failed", error);
    }
  }

  getRemoteVideo(): HTMLVideoElement | null {
    return this.remoteVideo;
  }

  getRemoteAudio(): HTMLAudioElement | null {
    return this.remoteAudio;
  }

  getCurrentCall(): CallInfo | null {
    return this.currentCall;
  }

  getConnectionStatus(): { connected: boolean; registered: boolean; initialized: boolean } {
    return {
      connected: this.isConnected,
      registered: this.isRegistered,
      initialized: this.isInitialized,
    };
  }

  async connect(): Promise<void> {
    await this.ensureSipClient();
  }

  async disconnect(): Promise<void> {
    if (this.connectionTimer) {
      clearInterval(this.connectionTimer);
      this.connectionTimer = null;
    }

    this.stopCallTimer();

    if (this.simpleUser) {
      try {
        if (this.currentCall) {
          await this.hangup();
        }

        if (this.isRegistered) {
          await this.simpleUser.unregister();
        }

        if (this.isConnected) {
          await this.simpleUser.disconnect();
        }
      } catch (error) {
        errorLog("Disconnect error", error);
      }

      this.simpleUser = null;
    }

    try {
      if (this.localStream) {
        this.localStream.getTracks().forEach((track) => track.stop());
        this.localStream = null;
      }

      if (this.localVideo && this.localVideo.parentNode) {
        this.localVideo.pause();
        this.localVideo.srcObject = null;
        this.localVideo.parentNode.removeChild(this.localVideo);
        this.localVideo = null;
      }

      if (this.remoteVideo && this.remoteVideo.parentNode) {
        this.remoteVideo.pause();
        this.remoteVideo.srcObject = null;
        this.remoteVideo.parentNode.removeChild(this.remoteVideo);
        this.remoteVideo = null;
      }

      this.videoEnabled = false;

      if (this.remoteAudio && this.remoteAudio.parentNode) {
        this.remoteAudio.pause();
        this.remoteAudio.srcObject = null;
        this.remoteAudio.parentNode.removeChild(this.remoteAudio);
        this.remoteAudio = null;
      }
    } catch (error) {
      errorLog("Error cleaning up media resources:", error);
    }

    this.isConnected = false;
    this.isRegistered = false;
    this.isInitialized = false;
    this.isInitializing = false;
    this.currentCall = null;

    debugLog(this.config?.debug || false, "SIP client disconnected");
  }
}

---

=== Object: ec7d6bfd281fe52e7a938345f204341ee962e38b | Date: 2025-09-23 15:23:51 | Type: blob ===

import { defineConfig } from 'vite';
import { resolve } from 'path';

export default defineConfig({
  build: {
    sourcemap: false, // Disable source maps
    lib: {
      entry: {
        "ha-webrtc-sip-card": "./src/card.ts",
        "ha-webrtc-sip-card-editor": "./src/editor.ts",
      },
      formats: ["es"],
      fileName: (format, entryName) => `${entryName}.js`,
    },
    outDir: "./dist",
    emptyOutDir: true,
    rollupOptions: {
      external: [],
      output: {
        // Ensure each entry is a separate file
        manualChunks: undefined,
        format: "es",
      },
    },
    target: "es2017",
    minify: false,
  },
  define: {
    __DEV__: JSON.stringify(process.env.NODE_ENV === "development"),
    __VERSION__: JSON.stringify(process.env.npm_package_version || "1.0.0"),
  },
});

---

=== Object: cce888cd1328552109bec0b0e681fe07894410c2 | Date: 2025-09-23 15:23:51 | Type: blob ===

{
  "name": "ha-webrtc-sip-card",
  "version": "1.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "ha-webrtc-sip-card",
      "version": "1.0.0",
      "license": "MIT",
      "dependencies": {
        "custom-card-helpers": "^1.9.0",
        "lit": "^3.1.2",
        "sip.js": "^0.21.2"
      },
      "devDependencies": {
        "@types/node": "^24.5.2",
        "@typescript-eslint/eslint-plugin": "^6.21.0",
        "@typescript-eslint/parser": "^6.21.0",
        "eslint": "^8.57.0",
        "typescript": "^5.4.3",
        "vite": "^5.2.8"
      }
    },
    "node_modules/@esbuild/aix-ppc64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/aix-ppc64/-/aix-ppc64-0.21.5.tgz",
      "integrity": "sha512-1SDgH6ZSPTlggy1yI6+Dbkiz8xzpHJEVAlF/AM1tHPLsf5STom9rwtjE4hKAF20FfXXNTFqEYXyJNWh1GiZedQ==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "aix"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/android-arm": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/android-arm/-/android-arm-0.21.5.tgz",
      "integrity": "sha512-vCPvzSjpPHEi1siZdlvAlsPxXl7WbOVUBBAowWug4rJHb68Ox8KualB+1ocNvT5fjv6wpkX6o/iEpbDrf68zcg==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/android-arm64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/android-arm64/-/android-arm64-0.21.5.tgz",
      "integrity": "sha512-c0uX9VAUBQ7dTDCjq+wdyGLowMdtR/GoC2U5IYk/7D1H1JYC0qseD7+11iMP2mRLN9RcCMRcjC4YMclCzGwS/A==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/android-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/android-x64/-/android-x64-0.21.5.tgz",
      "integrity": "sha512-D7aPRUUNHRBwHxzxRvp856rjUHRFW1SdQATKXH2hqA0kAZb1hKmi02OpYRacl0TxIGz/ZmXWlbZgjwWYaCakTA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/darwin-arm64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/darwin-arm64/-/darwin-arm64-0.21.5.tgz",
      "integrity": "sha512-DwqXqZyuk5AiWWf3UfLiRDJ5EDd49zg6O9wclZ7kUMv2WRFr4HKjXp/5t8JZ11QbQfUS6/cRCKGwYhtNAY88kQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/darwin-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/darwin-x64/-/darwin-x64-0.21.5.tgz",
      "integrity": "sha512-se/JjF8NlmKVG4kNIuyWMV/22ZaerB+qaSi5MdrXtd6R08kvs2qCN4C09miupktDitvh8jRFflwGFBQcxZRjbw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/freebsd-arm64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/freebsd-arm64/-/freebsd-arm64-0.21.5.tgz",
      "integrity": "sha512-5JcRxxRDUJLX8JXp/wcBCy3pENnCgBR9bN6JsY4OmhfUtIHe3ZW0mawA7+RDAcMLrMIZaf03NlQiX9DGyB8h4g==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/freebsd-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/freebsd-x64/-/freebsd-x64-0.21.5.tgz",
      "integrity": "sha512-J95kNBj1zkbMXtHVH29bBriQygMXqoVQOQYA+ISs0/2l3T9/kj42ow2mpqerRBxDJnmkUDCaQT/dfNXWX/ZZCQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-arm": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-arm/-/linux-arm-0.21.5.tgz",
      "integrity": "sha512-bPb5AHZtbeNGjCKVZ9UGqGwo8EUu4cLq68E95A53KlxAPRmUyYv2D6F0uUI65XisGOL1hBP5mTronbgo+0bFcA==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-arm64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-arm64/-/linux-arm64-0.21.5.tgz",
      "integrity": "sha512-ibKvmyYzKsBeX8d8I7MH/TMfWDXBF3db4qM6sy+7re0YXya+K1cem3on9XgdT2EQGMu4hQyZhan7TeQ8XkGp4Q==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-ia32": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-ia32/-/linux-ia32-0.21.5.tgz",
      "integrity": "sha512-YvjXDqLRqPDl2dvRODYmmhz4rPeVKYvppfGYKSNGdyZkA01046pLWyRKKI3ax8fbJoK5QbxblURkwK/MWY18Tg==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-loong64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-loong64/-/linux-loong64-0.21.5.tgz",
      "integrity": "sha512-uHf1BmMG8qEvzdrzAqg2SIG/02+4/DHB6a9Kbya0XDvwDEKCoC8ZRWI5JJvNdUjtciBGFQ5PuBlpEOXQj+JQSg==",
      "cpu": [
        "loong64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-mips64el": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-mips64el/-/linux-mips64el-0.21.5.tgz",
      "integrity": "sha512-IajOmO+KJK23bj52dFSNCMsz1QP1DqM6cwLUv3W1QwyxkyIWecfafnI555fvSGqEKwjMXVLokcV5ygHW5b3Jbg==",
      "cpu": [
        "mips64el"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-ppc64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-ppc64/-/linux-ppc64-0.21.5.tgz",
      "integrity": "sha512-1hHV/Z4OEfMwpLO8rp7CvlhBDnjsC3CttJXIhBi+5Aj5r+MBvy4egg7wCbe//hSsT+RvDAG7s81tAvpL2XAE4w==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-riscv64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-riscv64/-/linux-riscv64-0.21.5.tgz",
      "integrity": "sha512-2HdXDMd9GMgTGrPWnJzP2ALSokE/0O5HhTUvWIbD3YdjME8JwvSCnNGBnTThKGEB91OZhzrJ4qIIxk/SBmyDDA==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-s390x": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-s390x/-/linux-s390x-0.21.5.tgz",
      "integrity": "sha512-zus5sxzqBJD3eXxwvjN1yQkRepANgxE9lgOW2qLnmr8ikMTphkjgXu1HR01K4FJg8h1kEEDAqDcZQtbrRnB41A==",
      "cpu": [
        "s390x"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-x64/-/linux-x64-0.21.5.tgz",
      "integrity": "sha512-1rYdTpyv03iycF1+BhzrzQJCdOuAOtaqHTWJZCWvijKD2N5Xu0TtVC8/+1faWqcP9iBCWOmjmhoH94dH82BxPQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/netbsd-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/netbsd-x64/-/netbsd-x64-0.21.5.tgz",
      "integrity": "sha512-Woi2MXzXjMULccIwMnLciyZH4nCIMpWQAs049KEeMvOcNADVxo0UBIQPfSmxB3CWKedngg7sWZdLvLczpe0tLg==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "netbsd"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/openbsd-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/openbsd-x64/-/openbsd-x64-0.21.5.tgz",
      "integrity": "sha512-HLNNw99xsvx12lFBUwoT8EVCsSvRNDVxNpjZ7bPn947b8gJPzeHWyNVhFsaerc0n3TsbOINvRP2byTZ5LKezow==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openbsd"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/sunos-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/sunos-x64/-/sunos-x64-0.21.5.tgz",
      "integrity": "sha512-6+gjmFpfy0BHU5Tpptkuh8+uw3mnrvgs+dSPQXQOv3ekbordwnzTVEb4qnIvQcYXq6gzkyTnoZ9dZG+D4garKg==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "sunos"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/win32-arm64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-arm64/-/win32-arm64-0.21.5.tgz",
      "integrity": "sha512-Z0gOTd75VvXqyq7nsl93zwahcTROgqvuAcYDUr+vOv8uHhNSKROyU961kgtCD1e95IqPKSQKH7tBTslnS3tA8A==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/win32-ia32": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-ia32/-/win32-ia32-0.21.5.tgz",
      "integrity": "sha512-SWXFF1CL2RVNMaVs+BBClwtfZSvDgtL//G/smwAc5oVK/UPu2Gu9tIaRgFmYFFKrmg3SyAjSrElf0TiJ1v8fYA==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/win32-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-x64/-/win32-x64-0.21.5.tgz",
      "integrity": "sha512-tQd/1efJuzPC6rCFwEvLtci/xNFcTZknmXs98FYDfGE4wP9ClFV98nyKrzJKVPMhdDnjzLhdUyMX4PsQAPjwIw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@eslint-community/eslint-utils": {
      "version": "4.9.0",
      "resolved": "https://registry.npmjs.org/@eslint-community/eslint-utils/-/eslint-utils-4.9.0.tgz",
      "integrity": "sha512-ayVFHdtZ+hsq1t2Dy24wCmGXGe4q9Gu3smhLYALJrr473ZH27MsnSL+LKUlimp4BWJqMDMLmPpx/Q9R3OAlL4g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "eslint-visitor-keys": "^3.4.3"
      },
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      },
      "peerDependencies": {
        "eslint": "^6.0.0 || ^7.0.0 || >=8.0.0"
      }
    },
    "node_modules/@eslint-community/regexpp": {
      "version": "4.12.1",
      "resolved": "https://registry.npmjs.org/@eslint-community/regexpp/-/regexpp-4.12.1.tgz",
      "integrity": "sha512-CCZCDJuduB9OUkFkY2IgppNZMi2lBQgD2qzwXkEia16cge2pijY/aXi96CJMquDMn3nJdlPV1A5KrJEXwfLNzQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^12.0.0 || ^14.0.0 || >=16.0.0"
      }
    },
    "node_modules/@eslint/eslintrc": {
      "version": "2.1.4",
      "resolved": "https://registry.npmjs.org/@eslint/eslintrc/-/eslintrc-2.1.4.tgz",
      "integrity": "sha512-269Z39MS6wVJtsoUl10L60WdkhJVdPG24Q4eZTH3nnF6lpvSShEK3wQjDX9JRWAUPvPh7COouPpU9IrqaZFvtQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ajv": "^6.12.4",
        "debug": "^4.3.2",
        "espree": "^9.6.0",
        "globals": "^13.19.0",
        "ignore": "^5.2.0",
        "import-fresh": "^3.2.1",
        "js-yaml": "^4.1.0",
        "minimatch": "^3.1.2",
        "strip-json-comments": "^3.1.1"
      },
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/@eslint/eslintrc/node_modules/brace-expansion": {
      "version": "1.1.12",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.12.tgz",
      "integrity": "sha512-9T9UjW3r0UW5c1Q7GTwllptXwhvYmEzFhzMfZ9H7FQWt+uZePjZPjBP/W1ZEyZ1twGWom5/56TF4lPcqjnDHcg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "balanced-match": "^1.0.0",
        "concat-map": "0.0.1"
      }
    },
    "node_modules/@eslint/eslintrc/node_modules/minimatch": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz",
      "integrity": "sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "brace-expansion": "^1.1.7"
      },
      "engines": {
        "node": "*"
      }
    },
    "node_modules/@eslint/js": {
      "version": "8.57.1",
      "resolved": "https://registry.npmjs.org/@eslint/js/-/js-8.57.1.tgz",
      "integrity": "sha512-d9zaMRSTIKDLhctzH12MtXvJKSSUhaHcjV+2Z+GK+EEY7XKpP5yR4x+N3TAcHTcu963nIr+TMcCb4DBCYX1z6Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      }
    },
    "node_modules/@formatjs/ecma402-abstract": {
      "version": "1.11.4",
      "resolved": "https://registry.npmjs.org/@formatjs/ecma402-abstract/-/ecma402-abstract-1.11.4.tgz",
      "integrity": "sha512-EBikYFp2JCdIfGEb5G9dyCkTGDmC57KSHhRQOC3aYxoPWVZvfWCDjZwkGYHN7Lis/fmuWl906bnNTJifDQ3sXw==",
      "license": "MIT",
      "dependencies": {
        "@formatjs/intl-localematcher": "0.2.25",
        "tslib": "^2.1.0"
      }
    },
    "node_modules/@formatjs/fast-memoize": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/@formatjs/fast-memoize/-/fast-memoize-1.2.1.tgz",
      "integrity": "sha512-Rg0e76nomkz3vF9IPlKeV+Qynok0r7YZjL6syLz4/urSg0IbjPZCB/iYUMNsYA643gh4mgrX3T7KEIFIxJBQeg==",
      "license": "MIT",
      "dependencies": {
        "tslib": "^2.1.0"
      }
    },
    "node_modules/@formatjs/icu-messageformat-parser": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/@formatjs/icu-messageformat-parser/-/icu-messageformat-parser-2.1.0.tgz",
      "integrity": "sha512-Qxv/lmCN6hKpBSss2uQ8IROVnta2r9jd3ymUEIjm2UyIkUCHVcbUVRGL/KS/wv7876edvsPe+hjHVJ4z8YuVaw==",
      "license": "MIT",
      "dependencies": {
        "@formatjs/ecma402-abstract": "1.11.4",
        "@formatjs/icu-skeleton-parser": "1.3.6",
        "tslib": "^2.1.0"
      }
    },
    "node_modules/@formatjs/icu-skeleton-parser": {
      "version": "1.3.6",
      "resolved": "https://registry.npmjs.org/@formatjs/icu-skeleton-parser/-/icu-skeleton-parser-1.3.6.tgz",
      "integrity": "sha512-I96mOxvml/YLrwU2Txnd4klA7V8fRhb6JG/4hm3VMNmeJo1F03IpV2L3wWt7EweqNLES59SZ4d6hVOPCSf80Bg==",
      "license": "MIT",
      "dependencies": {
        "@formatjs/ecma402-abstract": "1.11.4",
        "tslib": "^2.1.0"
      }
    },
    "node_modules/@formatjs/intl-localematcher": {
      "version": "0.2.25",
      "resolved": "https://registry.npmjs.org/@formatjs/intl-localematcher/-/intl-localematcher-0.2.25.tgz",
      "integrity": "sha512-YmLcX70BxoSopLFdLr1Ds99NdlTI2oWoLbaUW2M406lxOIPzE1KQhRz2fPUkq34xVZQaihCoU29h0KK7An3bhA==",
      "license": "MIT",
      "dependencies": {
        "tslib": "^2.1.0"
      }
    },
    "node_modules/@formatjs/intl-utils": {
      "version": "3.8.4",
      "resolved": "https://registry.npmjs.org/@formatjs/intl-utils/-/intl-utils-3.8.4.tgz",
      "integrity": "sha512-j5C6NyfKevIxsfLK8KwO1C0vvP7k1+h4A9cFpc+cr6mEwCc1sPkr17dzh0Ke6k9U5pQccAQoXdcNBl3IYa4+ZQ==",
      "deprecated": "the package is rather renamed to @formatjs/ecma-abstract with some changes in functionality (primarily selectUnit is removed and we don't plan to make any further changes to this package",
      "license": "MIT",
      "dependencies": {
        "emojis-list": "^3.0.0"
      }
    },
    "node_modules/@humanwhocodes/config-array": {
      "version": "0.13.0",
      "resolved": "https://registry.npmjs.org/@humanwhocodes/config-array/-/config-array-0.13.0.tgz",
      "integrity": "sha512-DZLEEqFWQFiyK6h5YIeynKx7JlvCYWL0cImfSRXZ9l4Sg2efkFGTuFf6vzXjK1cq6IYkU+Eg/JizXw+TD2vRNw==",
      "deprecated": "Use @eslint/config-array instead",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@humanwhocodes/object-schema": "^2.0.3",
        "debug": "^4.3.1",
        "minimatch": "^3.0.5"
      },
      "engines": {
        "node": ">=10.10.0"
      }
    },
    "node_modules/@humanwhocodes/config-array/node_modules/brace-expansion": {
      "version": "1.1.12",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.12.tgz",
      "integrity": "sha512-9T9UjW3r0UW5c1Q7GTwllptXwhvYmEzFhzMfZ9H7FQWt+uZePjZPjBP/W1ZEyZ1twGWom5/56TF4lPcqjnDHcg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "balanced-match": "^1.0.0",
        "concat-map": "0.0.1"
      }
    },
    "node_modules/@humanwhocodes/config-array/node_modules/minimatch": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz",
      "integrity": "sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "brace-expansion": "^1.1.7"
      },
      "engines": {
        "node": "*"
      }
    },
    "node_modules/@humanwhocodes/module-importer": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/@humanwhocodes/module-importer/-/module-importer-1.0.1.tgz",
      "integrity": "sha512-bxveV4V8v5Yb4ncFTT3rPSgZBOpCkjfK0y4oVVVJwIuDVBRMDXrPyXRL988i5ap9m9bnyEEjWfm5WkBmtffLfA==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">=12.22"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/nzakas"
      }
    },
    "node_modules/@humanwhocodes/object-schema": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/@humanwhocodes/object-schema/-/object-schema-2.0.3.tgz",
      "integrity": "sha512-93zYdMES/c1D69yZiKDBj0V24vqNzB/koF26KPaagAfd3P/4gUlh3Dys5ogAK+Exi9QyzlD8x/08Zt7wIKcDcA==",
      "deprecated": "Use @eslint/object-schema instead",
      "dev": true,
      "license": "BSD-3-Clause"
    },
    "node_modules/@lit-labs/ssr-dom-shim": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/@lit-labs/ssr-dom-shim/-/ssr-dom-shim-1.4.0.tgz",
      "integrity": "sha512-ficsEARKnmmW5njugNYKipTm4SFnbik7CXtoencDZzmzo/dQ+2Q0bgkzJuoJP20Aj0F+izzJjOqsnkd6F/o1bw==",
      "license": "BSD-3-Clause"
    },
    "node_modules/@lit/reactive-element": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/@lit/reactive-element/-/reactive-element-2.1.1.tgz",
      "integrity": "sha512-N+dm5PAYdQ8e6UlywyyrgI2t++wFGXfHx+dSJ1oBrg6FAxUj40jId++EaRm80MKX5JnlH1sBsyZ5h0bcZKemCg==",
      "license": "BSD-3-Clause",
      "dependencies": {
        "@lit-labs/ssr-dom-shim": "^1.4.0"
      }
    },
    "node_modules/@nodelib/fs.scandir": {
      "version": "2.1.5",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.scandir/-/fs.scandir-2.1.5.tgz",
      "integrity": "sha512-vq24Bq3ym5HEQm2NKCr3yXDwjc7vTsEThRDnkp2DK9p1uqLR+DHurm/NOTo0KG7HYHU7eppKZj3MyqYuMBf62g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@nodelib/fs.stat": "2.0.5",
        "run-parallel": "^1.1.9"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/@nodelib/fs.stat": {
      "version": "2.0.5",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.stat/-/fs.stat-2.0.5.tgz",
      "integrity": "sha512-RkhPPp2zrqDAQA/2jNhnztcPAlv64XdhIp7a7454A5ovI7Bukxgt7MX7udwAu3zg1DcpPU0rz3VV1SeaqvY4+A==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/@nodelib/fs.walk": {
      "version": "1.2.8",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.walk/-/fs.walk-1.2.8.tgz",
      "integrity": "sha512-oGB+UxlgWcgQkgwo8GcEGwemoTFt3FIO9ababBmaGwXIoBKZ+GTy0pP185beGg7Llih/NSHSV2XAs1lnznocSg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@nodelib/fs.scandir": "2.1.5",
        "fastq": "^1.6.0"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/@rollup/rollup-android-arm-eabi": {
      "version": "4.52.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm-eabi/-/rollup-android-arm-eabi-4.52.0.tgz",
      "integrity": "sha512-VxDYCDqOaR7NXzAtvRx7G1u54d2kEHopb28YH/pKzY6y0qmogP3gG7CSiWsq9WvDFxOQMpNEyjVAHZFXfH3o/A==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ]
    },
    "node_modules/@rollup/rollup-android-arm64": {
      "version": "4.52.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm64/-/rollup-android-arm64-4.52.0.tgz",
      "integrity": "sha512-pqDirm8koABIKvzL59YI9W9DWbRlTX7RWhN+auR8HXJxo89m4mjqbah7nJZjeKNTNYopqL+yGg+0mhCpf3xZtQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ]
    },
    "node_modules/@rollup/rollup-darwin-arm64": {
      "version": "4.52.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-darwin-arm64/-/rollup-darwin-arm64-4.52.0.tgz",
      "integrity": "sha512-YCdWlY/8ltN6H78HnMsRHYlPiKvqKagBP1r+D7SSylxX+HnsgXGCmLiV3Y4nSyY9hW8qr8U9LDUx/Lo7M6MfmQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ]
    },
    "node_modules/@rollup/rollup-darwin-x64": {
      "version": "4.52.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-darwin-x64/-/rollup-darwin-x64-4.52.0.tgz",
      "integrity": "sha512-z4nw6y1j+OOSGzuVbSWdIp1IUks9qNw4dc7z7lWuWDKojY38VMWBlEN7F9jk5UXOkUcp97vA1N213DF+Lz8BRg==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ]
    },
    "node_modules/@rollup/rollup-freebsd-arm64": {
      "version": "4.52.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-freebsd-arm64/-/rollup-freebsd-arm64-4.52.0.tgz",
      "integrity": "sha512-Q/dv9Yvyr5rKlK8WQJZVrp5g2SOYeZUs9u/t2f9cQ2E0gJjYB/BWoedXfUT0EcDJefi2zzVfhcOj8drWCzTviw==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ]
    },
    "node_modules/@rollup/rollup-freebsd-x64": {
      "version": "4.52.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-freebsd-x64/-/rollup-freebsd-x64-4.52.0.tgz",
      "integrity": "sha512-kdBsLs4Uile/fbjZVvCRcKB4q64R+1mUq0Yd7oU1CMm1Av336ajIFqNFovByipciuUQjBCPMxwJhCgfG2re3rg==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm-gnueabihf": {
      "version": "4.52.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm-gnueabihf/-/rollup-linux-arm-gnueabihf-4.52.0.tgz",
      "integrity": "sha512-aL6hRwu0k7MTUESgkg7QHY6CoqPgr6gdQXRJI1/VbFlUMwsSzPGSR7sG5d+MCbYnJmJwThc2ol3nixj1fvI/zQ==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm-musleabihf": {
      "version": "4.52.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm-musleabihf/-/rollup-linux-arm-musleabihf-4.52.0.tgz",
      "integrity": "sha512-BTs0M5s1EJejgIBJhCeiFo7GZZ2IXWkFGcyZhxX4+8usnIo5Mti57108vjXFIQmmJaRyDwmV59Tw64Ap1dkwMw==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm64-gnu": {
      "version": "4.52.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm64-gnu/-/rollup-linux-arm64-gnu-4.52.0.tgz",
      "integrity": "sha512-uj672IVOU9m08DBGvoPKPi/J8jlVgjh12C9GmjjBxCTQc3XtVmRkRKyeHSmIKQpvJ7fIm1EJieBUcnGSzDVFyw==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm64-musl": {
      "version": "4.52.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm64-musl/-/rollup-linux-arm64-musl-4.52.0.tgz",
      "integrity": "sha512-/+IVbeDMDCtB/HP/wiWsSzduD10SEGzIZX2945KSgZRNi4TSkjHqRJtNTVtVb8IRwhJ65ssI56krlLik+zFWkw==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-loong64-gnu": {
      "version": "4.52.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-loong64-gnu/-/rollup-linux-loong64-gnu-4.52.0.tgz",
      "integrity": "sha512-U1vVzvSWtSMWKKrGoROPBXMh3Vwn93TA9V35PldokHGqiUbF6erSzox/5qrSMKp6SzakvyjcPiVF8yB1xKr9Pg==",
      "cpu": [
        "loong64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-ppc64-gnu": {
      "version": "4.52.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-ppc64-gnu/-/rollup-linux-ppc64-gnu-4.52.0.tgz",
      "integrity": "sha512-X/4WfuBAdQRH8cK3DYl8zC00XEE6aM472W+QCycpQJeLWVnHfkv7RyBFVaTqNUMsTgIX8ihMjCvFF9OUgeABzw==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-riscv64-gnu": {
      "version": "4.52.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-riscv64-gnu/-/rollup-linux-riscv64-gnu-4.52.0.tgz",
      "integrity": "sha512-xIRYc58HfWDBZoLmWfWXg2Sq8VCa2iJ32B7mqfWnkx5mekekl0tMe7FHpY8I72RXEcUkaWawRvl3qA55og+cwQ==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-riscv64-musl": {
      "version": "4.52.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-riscv64-musl/-/rollup-linux-riscv64-musl-4.52.0.tgz",
      "integrity": "sha512-mbsoUey05WJIOz8U1WzNdf+6UMYGwE3fZZnQqsM22FZ3wh1N887HT6jAOjXs6CNEK3Ntu2OBsyQDXfIjouI4dw==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-s390x-gnu": {
      "version": "4.52.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-s390x-gnu/-/rollup-linux-s390x-gnu-4.52.0.tgz",
      "integrity": "sha512-qP6aP970bucEi5KKKR4AuPFd8aTx9EF6BvutvYxmZuWLJHmnq4LvBfp0U+yFDMGwJ+AIJEH5sIP+SNypauMWzg==",
      "cpu": [
        "s390x"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-x64-gnu": {
      "version": "4.52.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-x64-gnu/-/rollup-linux-x64-gnu-4.52.0.tgz",
      "integrity": "sha512-nmSVN+F2i1yKZ7rJNKO3G7ZzmxJgoQBQZ/6c4MuS553Grmr7WqR7LLDcYG53Z2m9409z3JLt4sCOhLdbKQ3HmA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-x64-musl": {
      "version": "4.52.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-x64-musl/-/rollup-linux-x64-musl-4.52.0.tgz",
      "integrity": "sha512-2d0qRo33G6TfQVjaMR71P+yJVGODrt5V6+T0BDYH4EMfGgdC/2HWDVjSSFw888GSzAZUwuska3+zxNUCDco6rQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-openharmony-arm64": {
      "version": "4.52.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-openharmony-arm64/-/rollup-openharmony-arm64-4.52.0.tgz",
      "integrity": "sha512-A1JalX4MOaFAAyGgpO7XP5khquv/7xKzLIyLmhNrbiCxWpMlnsTYr8dnsWM7sEeotNmxvSOEL7F65j0HXFcFsw==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openharmony"
      ]
    },
    "node_modules/@rollup/rollup-win32-arm64-msvc": {
      "version": "4.52.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-arm64-msvc/-/rollup-win32-arm64-msvc-4.52.0.tgz",
      "integrity": "sha512-YQugafP/rH0eOOHGjmNgDURrpYHrIX0yuojOI8bwCyXwxC9ZdTd3vYkmddPX0oHONLXu9Rb1dDmT0VNpjkzGGw==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@rollup/rollup-win32-ia32-msvc": {
      "version": "4.52.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-ia32-msvc/-/rollup-win32-ia32-msvc-4.52.0.tgz",
      "integrity": "sha512-zYdUYhi3Qe2fndujBqL5FjAFzvNeLxtIqfzNEVKD1I7C37/chv1VxhscWSQHTNfjPCrBFQMnynwA3kpZpZ8w4A==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@rollup/rollup-win32-x64-gnu": {
      "version": "4.52.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-x64-gnu/-/rollup-win32-x64-gnu-4.52.0.tgz",
      "integrity": "sha512-fGk03kQylNaCOQ96HDMeT7E2n91EqvCDd3RwvT5k+xNdFCeMGnj5b5hEgTGrQuyidqSsD3zJDQ21QIaxXqTBJw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@rollup/rollup-win32-x64-msvc": {
      "version": "4.52.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-x64-msvc/-/rollup-win32-x64-msvc-4.52.0.tgz",
      "integrity": "sha512-6iKDCVSIUQ8jPMoIV0OytRKniaYyy5EbY/RRydmLW8ZR3cEBhxbWl5ro0rkUNe0ef6sScvhbY79HrjRm8i3vDQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@types/estree": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/@types/estree/-/estree-1.0.8.tgz",
      "integrity": "sha512-dWHzHa2WqEXI/O1E9OjrocMTKJl2mSrEolh1Iomrv6U+JuNwaHXsXx9bLu5gG7BUWFIN0skIQJQ/L1rIex4X6w==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/json-schema": {
      "version": "7.0.15",
      "resolved": "https://registry.npmjs.org/@types/json-schema/-/json-schema-7.0.15.tgz",
      "integrity": "sha512-5+fP8P8MFNC+AyZCDxrB2pkZFPGzqQWUzpSeuuVLvm8VMcorNYavBqoFcxK8bQz4Qsbn4oUEEem4wDLfcysGHA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/node": {
      "version": "24.5.2",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-24.5.2.tgz",
      "integrity": "sha512-FYxk1I7wPv3K2XBaoyH2cTnocQEu8AOZ60hPbsyukMPLv5/5qr7V1i8PLHdl6Zf87I+xZXFvPCXYjiTFq+YSDQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "undici-types": "~7.12.0"
      }
    },
    "node_modules/@types/semver": {
      "version": "7.7.1",
      "resolved": "https://registry.npmjs.org/@types/semver/-/semver-7.7.1.tgz",
      "integrity": "sha512-FmgJfu+MOcQ370SD0ev7EI8TlCAfKYU+B4m5T3yXc1CiRN94g/SZPtsCkk506aUDtlMnFZvasDwHHUcZUEaYuA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/trusted-types": {
      "version": "2.0.7",
      "resolved": "https://registry.npmjs.org/@types/trusted-types/-/trusted-types-2.0.7.tgz",
      "integrity": "sha512-ScaPdn1dQczgbl0QFTeTOmVHFULt394XJgOQNoyVhZ6r2vLnMLJfBPd53SB52T/3G36VI1/g2MZaX0cwDuXsfw==",
      "license": "MIT"
    },
    "node_modules/@typescript-eslint/eslint-plugin": {
      "version": "6.21.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/eslint-plugin/-/eslint-plugin-6.21.0.tgz",
      "integrity": "sha512-oy9+hTPCUFpngkEZUSzbf9MxI65wbKFoQYsgPdILTfbUldp5ovUuphZVe4i30emU9M/kP+T64Di0mxl7dSw3MA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@eslint-community/regexpp": "^4.5.1",
        "@typescript-eslint/scope-manager": "6.21.0",
        "@typescript-eslint/type-utils": "6.21.0",
        "@typescript-eslint/utils": "6.21.0",
        "@typescript-eslint/visitor-keys": "6.21.0",
        "debug": "^4.3.4",
        "graphemer": "^1.4.0",
        "ignore": "^5.2.4",
        "natural-compare": "^1.4.0",
        "semver": "^7.5.4",
        "ts-api-utils": "^1.0.1"
      },
      "engines": {
        "node": "^16.0.0 || >=18.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "@typescript-eslint/parser": "^6.0.0 || ^6.0.0-alpha",
        "eslint": "^7.0.0 || ^8.0.0"
      },
      "peerDependenciesMeta": {
        "typescript": {
          "optional": true
        }
      }
    },
    "node_modules/@typescript-eslint/parser": {
      "version": "6.21.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/parser/-/parser-6.21.0.tgz",
      "integrity": "sha512-tbsV1jPne5CkFQCgPBcDOt30ItF7aJoZL997JSF7MhGQqOeT3svWRYxiqlfA5RUdlHN6Fi+EI9bxqbdyAUZjYQ==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "@typescript-eslint/scope-manager": "6.21.0",
        "@typescript-eslint/types": "6.21.0",
        "@typescript-eslint/typescript-estree": "6.21.0",
        "@typescript-eslint/visitor-keys": "6.21.0",
        "debug": "^4.3.4"
      },
      "engines": {
        "node": "^16.0.0 || >=18.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "eslint": "^7.0.0 || ^8.0.0"
      },
      "peerDependenciesMeta": {
        "typescript": {
          "optional": true
        }
      }
    },
    "node_modules/@typescript-eslint/scope-manager": {
      "version": "6.21.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/scope-manager/-/scope-manager-6.21.0.tgz",
      "integrity": "sha512-OwLUIWZJry80O99zvqXVEioyniJMa+d2GrqpUTqi5/v5D5rOrppJVBPa0yKCblcigC0/aYAzxxqQ1B+DS2RYsg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@typescript-eslint/types": "6.21.0",
        "@typescript-eslint/visitor-keys": "6.21.0"
      },
      "engines": {
        "node": "^16.0.0 || >=18.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      }
    },
    "node_modules/@typescript-eslint/type-utils": {
      "version": "6.21.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/type-utils/-/type-utils-6.21.0.tgz",
      "integrity": "sha512-rZQI7wHfao8qMX3Rd3xqeYSMCL3SoiSQLBATSiVKARdFGCYSRvmViieZjqc58jKgs8Y8i9YvVVhRbHSTA4VBag==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@typescript-eslint/typescript-estree": "6.21.0",
        "@typescript-eslint/utils": "6.21.0",
        "debug": "^4.3.4",
        "ts-api-utils": "^1.0.1"
      },
      "engines": {
        "node": "^16.0.0 || >=18.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "eslint": "^7.0.0 || ^8.0.0"
      },
      "peerDependenciesMeta": {
        "typescript": {
          "optional": true
        }
      }
    },
    "node_modules/@typescript-eslint/types": {
      "version": "6.21.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/types/-/types-6.21.0.tgz",
      "integrity": "sha512-1kFmZ1rOm5epu9NZEZm1kckCDGj5UJEf7P1kliH4LKu/RkwpsfqqGmY2OOcUs18lSlQBKLDYBOGxRVtrMN5lpg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^16.0.0 || >=18.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      }
    },
    "node_modules/@typescript-eslint/typescript-estree": {
      "version": "6.21.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/typescript-estree/-/typescript-estree-6.21.0.tgz",
      "integrity": "sha512-6npJTkZcO+y2/kr+z0hc4HwNfrrP4kNYh57ek7yCNlrBjWQ1Y0OS7jiZTkgumrvkX5HkEKXFZkkdFNkaW2wmUQ==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "@typescript-eslint/types": "6.21.0",
        "@typescript-eslint/visitor-keys": "6.21.0",
        "debug": "^4.3.4",
        "globby": "^11.1.0",
        "is-glob": "^4.0.3",
        "minimatch": "9.0.3",
        "semver": "^7.5.4",
        "ts-api-utils": "^1.0.1"
      },
      "engines": {
        "node": "^16.0.0 || >=18.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependenciesMeta": {
        "typescript": {
          "optional": true
        }
      }
    },
    "node_modules/@typescript-eslint/utils": {
      "version": "6.21.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/utils/-/utils-6.21.0.tgz",
      "integrity": "sha512-NfWVaC8HP9T8cbKQxHcsJBY5YE1O33+jpMwN45qzWWaPDZgLIbo12toGMWnmhvCpd3sIxkpDw3Wv1B3dYrbDQQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@eslint-community/eslint-utils": "^4.4.0",
        "@types/json-schema": "^7.0.12",
        "@types/semver": "^7.5.0",
        "@typescript-eslint/scope-manager": "6.21.0",
        "@typescript-eslint/types": "6.21.0",
        "@typescript-eslint/typescript-estree": "6.21.0",
        "semver": "^7.5.4"
      },
      "engines": {
        "node": "^16.0.0 || >=18.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "eslint": "^7.0.0 || ^8.0.0"
      }
    },
    "node_modules/@typescript-eslint/visitor-keys": {
      "version": "6.21.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/visitor-keys/-/visitor-keys-6.21.0.tgz",
      "integrity": "sha512-JJtkDduxLi9bivAB+cYOVMtbkqdPOhZ+ZI5LC47MIRrDV4Yn2o+ZnW10Nkmr28xRpSpdJ6Sm42Hjf2+REYXm0A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@typescript-eslint/types": "6.21.0",
        "eslint-visitor-keys": "^3.4.1"
      },
      "engines": {
        "node": "^16.0.0 || >=18.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      }
    },
    "node_modules/@ungap/structured-clone": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/@ungap/structured-clone/-/structured-clone-1.3.0.tgz",
      "integrity": "sha512-WmoN8qaIAo7WTYWbAZuG8PYEhn5fkz7dZrqTBZ7dtt//lL2Gwms1IcnQ5yHqjDfX8Ft5j4YzDM23f87zBfDe9g==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/acorn": {
      "version": "8.15.0",
      "resolved": "https://registry.npmjs.org/acorn/-/acorn-8.15.0.tgz",
      "integrity": "sha512-NZyJarBfL7nWwIq+FDL6Zp/yHEhePMNnnJ0y3qfieCrmNvYct8uvtiV41UvlSe6apAfk0fY1FbWx+NwfmpvtTg==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "acorn": "bin/acorn"
      },
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/acorn-jsx": {
      "version": "5.3.2",
      "resolved": "https://registry.npmjs.org/acorn-jsx/-/acorn-jsx-5.3.2.tgz",
      "integrity": "sha512-rq9s+JNhf0IChjtDXxllJ7g41oZk5SlXtp0LHwyA5cejwn7vKmKp4pPri6YEePv2PU65sAsegbXtIinmDFDXgQ==",
      "dev": true,
      "license": "MIT",
      "peerDependencies": {
        "acorn": "^6.0.0 || ^7.0.0 || ^8.0.0"
      }
    },
    "node_modules/ajv": {
      "version": "6.12.6",
      "resolved": "https://registry.npmjs.org/ajv/-/ajv-6.12.6.tgz",
      "integrity": "sha512-j3fVLgvTo527anyYyJOGTYJbG+vnnQYvE0m5mmkc1TK+nxAppkCLMIL0aZ4dblVCNoGShhm+kzE4ZUykBoMg4g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "fast-deep-equal": "^3.1.1",
        "fast-json-stable-stringify": "^2.0.0",
        "json-schema-traverse": "^0.4.1",
        "uri-js": "^4.2.2"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/epoberezkin"
      }
    },
    "node_modules/ansi-regex": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.1.tgz",
      "integrity": "sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/ansi-styles": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz",
      "integrity": "sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "color-convert": "^2.0.1"
      },
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
      }
    },
    "node_modules/argparse": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/argparse/-/argparse-2.0.1.tgz",
      "integrity": "sha512-8+9WqebbFzpX9OR+Wa6O29asIogeRMzcGtAINdpMHHyAg10f05aSFVBbcEqGf/PXw1EjAZ+q2/bEBg3DvurK3Q==",
      "dev": true,
      "license": "Python-2.0"
    },
    "node_modules/array-union": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/array-union/-/array-union-2.1.0.tgz",
      "integrity": "sha512-HGyxoOTYUyCM6stUe6EJgnd4EoewAI7zMdfqO+kGjnlZmBDz/cR5pf8r/cR4Wq60sL/p0IkcjUEEPwS3GFrIyw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/balanced-match": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.2.tgz",
      "integrity": "sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/brace-expansion": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-2.0.2.tgz",
      "integrity": "sha512-Jt0vHyM+jmUBqojB7E1NIYadt0vI0Qxjxd2TErW94wDz+E2LAm5vKMXXwg6ZZBTHPuUlDgQHKXvjGBdfcF1ZDQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "balanced-match": "^1.0.0"
      }
    },
    "node_modules/braces": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/braces/-/braces-3.0.3.tgz",
      "integrity": "sha512-yQbXgO/OSZVD2IsiLlro+7Hf6Q18EJrKSEsdoMzKePKXct3gvD8oLcOQdIzGupr5Fj+EDe8gO/lxc1BzfMpxvA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "fill-range": "^7.1.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/callsites": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/callsites/-/callsites-3.1.0.tgz",
      "integrity": "sha512-P8BjAsXvZS+VIDUI11hHCQEv74YT67YUi5JJFNWIqL235sBmjX4+qx9Muvls5ivyNENctx46xQLQ3aTuE7ssaQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/chalk": {
      "version": "4.1.2",
      "resolved": "https://registry.npmjs.org/chalk/-/chalk-4.1.2.tgz",
      "integrity": "sha512-oKnbhFyRIXpUuez8iBMmyEa4nbj4IOQyuhc/wy9kY7/WVPcwIO9VA668Pu8RkO7+0G76SLROeyw9CpQ061i4mA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-styles": "^4.1.0",
        "supports-color": "^7.1.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/chalk/chalk?sponsor=1"
      }
    },
    "node_modules/color-convert": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
      "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "color-name": "~1.1.4"
      },
      "engines": {
        "node": ">=7.0.0"
      }
    },
    "node_modules/color-name": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz",
      "integrity": "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/concat-map": {
      "version": "0.0.1",
      "resolved": "https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz",
      "integrity": "sha512-/Srv4dswyQNBfohGpz9o6Yb3Gz3SrUDqBH5rTuhGR7ahtlbYKnVxw2bCFMRljaA7EXHaXZ8wsHdodFvbkhKmqg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/cross-spawn": {
      "version": "7.0.6",
      "resolved": "https://registry.npmjs.org/cross-spawn/-/cross-spawn-7.0.6.tgz",
      "integrity": "sha512-uV2QOWP2nWzsy2aMp8aRibhi9dlzF5Hgh5SHaB9OiTGEyDTiJJyx0uy51QXdyWbtAHNua4XJzUKca3OzKUd3vA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "path-key": "^3.1.0",
        "shebang-command": "^2.0.0",
        "which": "^2.0.1"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/custom-card-helpers": {
      "version": "1.9.0",
      "resolved": "https://registry.npmjs.org/custom-card-helpers/-/custom-card-helpers-1.9.0.tgz",
      "integrity": "sha512-5IW4OXq3MiiCqDvqeu+MYsM1NmntKW1WfJhyJFsdP2tbzqEI4BOnqRz2qzdp08lE4QLVhYfRLwe0WAqgQVNeFg==",
      "license": "MIT",
      "dependencies": {
        "@formatjs/intl-utils": "^3.8.4",
        "home-assistant-js-websocket": "^6.0.1",
        "intl-messageformat": "^9.11.1",
        "lit": "^2.1.1",
        "rollup": "^2.63.0",
        "superstruct": "^0.15.3",
        "typescript": "^4.5.4"
      }
    },
    "node_modules/custom-card-helpers/node_modules/@lit/reactive-element": {
      "version": "1.6.3",
      "resolved": "https://registry.npmjs.org/@lit/reactive-element/-/reactive-element-1.6.3.tgz",
      "integrity": "sha512-QuTgnG52Poic7uM1AN5yJ09QMe0O28e10XzSvWDz02TJiiKee4stsiownEIadWm8nYzyDAyT+gKzUoZmiWQtsQ==",
      "license": "BSD-3-Clause",
      "dependencies": {
        "@lit-labs/ssr-dom-shim": "^1.0.0"
      }
    },
    "node_modules/custom-card-helpers/node_modules/lit": {
      "version": "2.8.0",
      "resolved": "https://registry.npmjs.org/lit/-/lit-2.8.0.tgz",
      "integrity": "sha512-4Sc3OFX9QHOJaHbmTMk28SYgVxLN3ePDjg7hofEft2zWlehFL3LiAuapWc4U/kYwMYJSh2hTCPZ6/LIC7ii0MA==",
      "license": "BSD-3-Clause",
      "dependencies": {
        "@lit/reactive-element": "^1.6.0",
        "lit-element": "^3.3.0",
        "lit-html": "^2.8.0"
      }
    },
    "node_modules/custom-card-helpers/node_modules/lit-element": {
      "version": "3.3.3",
      "resolved": "https://registry.npmjs.org/lit-element/-/lit-element-3.3.3.tgz",
      "integrity": "sha512-XbeRxmTHubXENkV4h8RIPyr8lXc+Ff28rkcQzw3G6up2xg5E8Zu1IgOWIwBLEQsu3cOVFqdYwiVi0hv0SlpqUA==",
      "license": "BSD-3-Clause",
      "dependencies": {
        "@lit-labs/ssr-dom-shim": "^1.1.0",
        "@lit/reactive-element": "^1.3.0",
        "lit-html": "^2.8.0"
      }
    },
    "node_modules/custom-card-helpers/node_modules/lit-html": {
      "version": "2.8.0",
      "resolved": "https://registry.npmjs.org/lit-html/-/lit-html-2.8.0.tgz",
      "integrity": "sha512-o9t+MQM3P4y7M7yNzqAyjp7z+mQGa4NS4CxiyLqFPyFWyc4O+nodLrkrxSaCTrla6M5YOLaT3RpbbqjszB5g3Q==",
      "license": "BSD-3-Clause",
      "dependencies": {
        "@types/trusted-types": "^2.0.2"
      }
    },
    "node_modules/custom-card-helpers/node_modules/typescript": {
      "version": "4.9.5",
      "resolved": "https://registry.npmjs.org/typescript/-/typescript-4.9.5.tgz",
      "integrity": "sha512-1FXk9E2Hm+QzZQ7z+McJiHL4NW1F2EzMu9Nq9i3zAaGqibafqYwCVU6WyWAuyQRRzOlxou8xZSyXLEN8oKj24g==",
      "license": "Apache-2.0",
      "bin": {
        "tsc": "bin/tsc",
        "tsserver": "bin/tsserver"
      },
      "engines": {
        "node": ">=4.2.0"
      }
    },
    "node_modules/debug": {
      "version": "4.4.3",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.3.tgz",
      "integrity": "sha512-RGwwWnwQvkVfavKVt22FGLw+xYSdzARwm0ru6DhTVA3umU5hZc28V3kO4stgYryrTlLpuvgI9GiijltAjNbcqA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ms": "^2.1.3"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/deep-is": {
      "version": "0.1.4",
      "resolved": "https://registry.npmjs.org/deep-is/-/deep-is-0.1.4.tgz",
      "integrity": "sha512-oIPzksmTg4/MriiaYGO+okXDT7ztn/w3Eptv/+gSIdMdKsJo0u4CfYNFJPy+4SKMuCqGw2wxnA+URMg3t8a/bQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/dir-glob": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/dir-glob/-/dir-glob-3.0.1.tgz",
      "integrity": "sha512-WkrWp9GR4KXfKGYzOLmTuGVi1UWFfws377n9cc55/tb6DuqyF6pcQ5AbiHEshaDpY9v6oaSr2XCDidGmMwdzIA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "path-type": "^4.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/doctrine": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/doctrine/-/doctrine-3.0.0.tgz",
      "integrity": "sha512-yS+Q5i3hBf7GBkd4KG8a7eBNNWNGLTaEwwYWUijIYM7zrlYDM0BFXHjjPWlWZ1Rg7UaddZeIDmi9jF3HmqiQ2w==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "esutils": "^2.0.2"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/emojis-list": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/emojis-list/-/emojis-list-3.0.0.tgz",
      "integrity": "sha512-/kyM18EfinwXZbno9FyUGeFh87KC8HRQBQGildHZbEuRyWFOmv1U10o9BBp8XVZDVNNuQKyIGIu5ZYAAXJ0V2Q==",
      "license": "MIT",
      "engines": {
        "node": ">= 4"
      }
    },
    "node_modules/esbuild": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/esbuild/-/esbuild-0.21.5.tgz",
      "integrity": "sha512-mg3OPMV4hXywwpoDxu3Qda5xCKQi+vCTZq8S9J/EpkhB2HzKXq4SNFZE3+NK93JYxc8VMSep+lOUSC/RVKaBqw==",
      "dev": true,
      "hasInstallScript": true,
      "license": "MIT",
      "bin": {
        "esbuild": "bin/esbuild"
      },
      "engines": {
        "node": ">=12"
      },
      "optionalDependencies": {
        "@esbuild/aix-ppc64": "0.21.5",
        "@esbuild/android-arm": "0.21.5",
        "@esbuild/android-arm64": "0.21.5",
        "@esbuild/android-x64": "0.21.5",
        "@esbuild/darwin-arm64": "0.21.5",
        "@esbuild/darwin-x64": "0.21.5",
        "@esbuild/freebsd-arm64": "0.21.5",
        "@esbuild/freebsd-x64": "0.21.5",
        "@esbuild/linux-arm": "0.21.5",
        "@esbuild/linux-arm64": "0.21.5",
        "@esbuild/linux-ia32": "0.21.5",
        "@esbuild/linux-loong64": "0.21.5",
        "@esbuild/linux-mips64el": "0.21.5",
        "@esbuild/linux-ppc64": "0.21.5",
        "@esbuild/linux-riscv64": "0.21.5",
        "@esbuild/linux-s390x": "0.21.5",
        "@esbuild/linux-x64": "0.21.5",
        "@esbuild/netbsd-x64": "0.21.5",
        "@esbuild/openbsd-x64": "0.21.5",
        "@esbuild/sunos-x64": "0.21.5",
        "@esbuild/win32-arm64": "0.21.5",
        "@esbuild/win32-ia32": "0.21.5",
        "@esbuild/win32-x64": "0.21.5"
      }
    },
    "node_modules/escape-string-regexp": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-4.0.0.tgz",
      "integrity": "sha512-TtpcNJ3XAzx3Gq8sWRzJaVajRs0uVxA2YAkdb1jm2YkPz4G6egUFAyA3n5vtEIZefPk5Wa4UXbKuS5fKkJWdgA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/eslint": {
      "version": "8.57.1",
      "resolved": "https://registry.npmjs.org/eslint/-/eslint-8.57.1.tgz",
      "integrity": "sha512-ypowyDxpVSYpkXr9WPv2PAZCtNip1Mv5KTW0SCurXv/9iOpcrH9PaqUElksqEB6pChqHGDRCFTyrZlGhnLNGiA==",
      "deprecated": "This version is no longer supported. Please see https://eslint.org/version-support for other options.",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@eslint-community/eslint-utils": "^4.2.0",
        "@eslint-community/regexpp": "^4.6.1",
        "@eslint/eslintrc": "^2.1.4",
        "@eslint/js": "8.57.1",
        "@humanwhocodes/config-array": "^0.13.0",
        "@humanwhocodes/module-importer": "^1.0.1",
        "@nodelib/fs.walk": "^1.2.8",
        "@ungap/structured-clone": "^1.2.0",
        "ajv": "^6.12.4",
        "chalk": "^4.0.0",
        "cross-spawn": "^7.0.2",
        "debug": "^4.3.2",
        "doctrine": "^3.0.0",
        "escape-string-regexp": "^4.0.0",
        "eslint-scope": "^7.2.2",
        "eslint-visitor-keys": "^3.4.3",
        "espree": "^9.6.1",
        "esquery": "^1.4.2",
        "esutils": "^2.0.2",
        "fast-deep-equal": "^3.1.3",
        "file-entry-cache": "^6.0.1",
        "find-up": "^5.0.0",
        "glob-parent": "^6.0.2",
        "globals": "^13.19.0",
        "graphemer": "^1.4.0",
        "ignore": "^5.2.0",
        "imurmurhash": "^0.1.4",
        "is-glob": "^4.0.0",
        "is-path-inside": "^3.0.3",
        "js-yaml": "^4.1.0",
        "json-stable-stringify-without-jsonify": "^1.0.1",
        "levn": "^0.4.1",
        "lodash.merge": "^4.6.2",
        "minimatch": "^3.1.2",
        "natural-compare": "^1.4.0",
        "optionator": "^0.9.3",
        "strip-ansi": "^6.0.1",
        "text-table": "^0.2.0"
      },
      "bin": {
        "eslint": "bin/eslint.js"
      },
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/eslint-scope": {
      "version": "7.2.2",
      "resolved": "https://registry.npmjs.org/eslint-scope/-/eslint-scope-7.2.2.tgz",
      "integrity": "sha512-dOt21O7lTMhDM+X9mB4GX+DZrZtCUJPL/wlcTqxyrx5IvO0IYtILdtrQGQp+8n5S0gwSVmOf9NQrjMOgfQZlIg==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "esrecurse": "^4.3.0",
        "estraverse": "^5.2.0"
      },
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/eslint-visitor-keys": {
      "version": "3.4.3",
      "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-3.4.3.tgz",
      "integrity": "sha512-wpc+LXeiyiisxPlEkUzU6svyS1frIO3Mgxj1fdy7Pm8Ygzguax2N3Fa/D/ag1WqbOprdI+uY6wMUl8/a2G+iag==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/eslint/node_modules/brace-expansion": {
      "version": "1.1.12",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.12.tgz",
      "integrity": "sha512-9T9UjW3r0UW5c1Q7GTwllptXwhvYmEzFhzMfZ9H7FQWt+uZePjZPjBP/W1ZEyZ1twGWom5/56TF4lPcqjnDHcg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "balanced-match": "^1.0.0",
        "concat-map": "0.0.1"
      }
    },
    "node_modules/eslint/node_modules/minimatch": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz",
      "integrity": "sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "brace-expansion": "^1.1.7"
      },
      "engines": {
        "node": "*"
      }
    },
    "node_modules/espree": {
      "version": "9.6.1",
      "resolved": "https://registry.npmjs.org/espree/-/espree-9.6.1.tgz",
      "integrity": "sha512-oruZaFkjorTpF32kDSI5/75ViwGeZginGGy2NoOSg3Q9bnwlnmDm4HLnkl0RE3n+njDXR037aY1+x58Z/zFdwQ==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "acorn": "^8.9.0",
        "acorn-jsx": "^5.3.2",
        "eslint-visitor-keys": "^3.4.1"
      },
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/esquery": {
      "version": "1.6.0",
      "resolved": "https://registry.npmjs.org/esquery/-/esquery-1.6.0.tgz",
      "integrity": "sha512-ca9pw9fomFcKPvFLXhBKUK90ZvGibiGOvRJNbjljY7s7uq/5YO4BOzcYtJqExdx99rF6aAcnRxHmcUHcz6sQsg==",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "estraverse": "^5.1.0"
      },
      "engines": {
        "node": ">=0.10"
      }
    },
    "node_modules/esrecurse": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/esrecurse/-/esrecurse-4.3.0.tgz",
      "integrity": "sha512-KmfKL3b6G+RXvP8N1vr3Tq1kL/oCFgn2NYXEtqP8/L3pKapUA4G8cFVaoF3SU323CD4XypR/ffioHmkti6/Tag==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "estraverse": "^5.2.0"
      },
      "engines": {
        "node": ">=4.0"
      }
    },
    "node_modules/estraverse": {
      "version": "5.3.0",
      "resolved": "https://registry.npmjs.org/estraverse/-/estraverse-5.3.0.tgz",
      "integrity": "sha512-MMdARuVEQziNTeJD8DgMqmhwR11BRQ/cBP+pLtYdSTnf3MIO8fFeiINEbX36ZdNlfU/7A9f3gUw49B3oQsvwBA==",
      "dev": true,
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=4.0"
      }
    },
    "node_modules/esutils": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/esutils/-/esutils-2.0.3.tgz",
      "integrity": "sha512-kVscqXk4OCp68SZ0dkgEKVi6/8ij300KBWTJq32P/dYeWTSwK41WyTxalN1eRmA5Z9UU/LX9D7FWSmV9SAYx6g==",
      "dev": true,
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/fast-deep-equal": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/fast-deep-equal/-/fast-deep-equal-3.1.3.tgz",
      "integrity": "sha512-f3qQ9oQy9j2AhBe/H9VC91wLmKBCCU/gDOnKNAYG5hswO7BLKj09Hc5HYNz9cGI++xlpDCIgDaitVs03ATR84Q==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/fast-glob": {
      "version": "3.3.3",
      "resolved": "https://registry.npmjs.org/fast-glob/-/fast-glob-3.3.3.tgz",
      "integrity": "sha512-7MptL8U0cqcFdzIzwOTHoilX9x5BrNqye7Z/LuC7kCMRio1EMSyqRK3BEAUD7sXRq4iT4AzTVuZdhgQ2TCvYLg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@nodelib/fs.stat": "^2.0.2",
        "@nodelib/fs.walk": "^1.2.3",
        "glob-parent": "^5.1.2",
        "merge2": "^1.3.0",
        "micromatch": "^4.0.8"
      },
      "engines": {
        "node": ">=8.6.0"
      }
    },
    "node_modules/fast-glob/node_modules/glob-parent": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.2.tgz",
      "integrity": "sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "is-glob": "^4.0.1"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/fast-json-stable-stringify": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/fast-json-stable-stringify/-/fast-json-stable-stringify-2.1.0.tgz",
      "integrity": "sha512-lhd/wF+Lk98HZoTCtlVraHtfh5XYijIjalXck7saUtuanSDyLMxnHhSXEDJqHxD7msR8D0uCmqlkwjCV8xvwHw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/fast-levenshtein": {
      "version": "2.0.6",
      "resolved": "https://registry.npmjs.org/fast-levenshtein/-/fast-levenshtein-2.0.6.tgz",
      "integrity": "sha512-DCXu6Ifhqcks7TZKY3Hxp3y6qphY5SJZmrWMDrKcERSOXWQdMhU9Ig/PYrzyw/ul9jOIyh0N4M0tbC5hodg8dw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/fastq": {
      "version": "1.19.1",
      "resolved": "https://registry.npmjs.org/fastq/-/fastq-1.19.1.tgz",
      "integrity": "sha512-GwLTyxkCXjXbxqIhTsMI2Nui8huMPtnxg7krajPJAjnEG/iiOS7i+zCtWGZR9G0NBKbXKh6X9m9UIsYX/N6vvQ==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "reusify": "^1.0.4"
      }
    },
    "node_modules/file-entry-cache": {
      "version": "6.0.1",
      "resolved": "https://registry.npmjs.org/file-entry-cache/-/file-entry-cache-6.0.1.tgz",
      "integrity": "sha512-7Gps/XWymbLk2QLYK4NzpMOrYjMhdIxXuIvy2QBsLE6ljuodKvdkWs/cpyJJ3CVIVpH0Oi1Hvg1ovbMzLdFBBg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "flat-cache": "^3.0.4"
      },
      "engines": {
        "node": "^10.12.0 || >=12.0.0"
      }
    },
    "node_modules/fill-range": {
      "version": "7.1.1",
      "resolved": "https://registry.npmjs.org/fill-range/-/fill-range-7.1.1.tgz",
      "integrity": "sha512-YsGpe3WHLK8ZYi4tWDg2Jy3ebRz2rXowDxnld4bkQB00cc/1Zw9AWnC0i9ztDJitivtQvaI9KaLyKrc+hBW0yg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "to-regex-range": "^5.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/find-up": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/find-up/-/find-up-5.0.0.tgz",
      "integrity": "sha512-78/PXT1wlLLDgTzDs7sjq9hzz0vXD+zn+7wypEe4fXQxCmdmqfGsEPQxmiCSQI3ajFV91bVSsvNtrJRiW6nGng==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "locate-path": "^6.0.0",
        "path-exists": "^4.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/flat-cache": {
      "version": "3.2.0",
      "resolved": "https://registry.npmjs.org/flat-cache/-/flat-cache-3.2.0.tgz",
      "integrity": "sha512-CYcENa+FtcUKLmhhqyctpclsq7QF38pKjZHsGNiSQF5r4FtoKDWabFDl3hzaEQMvT1LHEysw5twgLvpYYb4vbw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "flatted": "^3.2.9",
        "keyv": "^4.5.3",
        "rimraf": "^3.0.2"
      },
      "engines": {
        "node": "^10.12.0 || >=12.0.0"
      }
    },
    "node_modules/flatted": {
      "version": "3.3.3",
      "resolved": "https://registry.npmjs.org/flatted/-/flatted-3.3.3.tgz",
      "integrity": "sha512-GX+ysw4PBCz0PzosHDepZGANEuFCMLrnRTiEy9McGjmkCQYwRq4A/X786G/fjM/+OjsWSU1ZrY5qyARZmO/uwg==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/fs.realpath": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/fs.realpath/-/fs.realpath-1.0.0.tgz",
      "integrity": "sha512-OO0pH2lK6a0hZnAdau5ItzHPI6pUlvI7jMVnxUQRtw4owF2wk8lOSabtGDCTP4Ggrg2MbGnWO9X8K1t4+fGMDw==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/fsevents": {
      "version": "2.3.3",
      "resolved": "https://registry.npmjs.org/fsevents/-/fsevents-2.3.3.tgz",
      "integrity": "sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==",
      "hasInstallScript": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": "^8.16.0 || ^10.6.0 || >=11.0.0"
      }
    },
    "node_modules/glob": {
      "version": "7.2.3",
      "resolved": "https://registry.npmjs.org/glob/-/glob-7.2.3.tgz",
      "integrity": "sha512-nFR0zLpU2YCaRxwoCJvL6UvCH2JFyFVIvwTLsIf21AuHlMskA1hhTdk+LlYJtOlYt9v6dvszD2BGRqBL+iQK9Q==",
      "deprecated": "Glob versions prior to v9 are no longer supported",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "fs.realpath": "^1.0.0",
        "inflight": "^1.0.4",
        "inherits": "2",
        "minimatch": "^3.1.1",
        "once": "^1.3.0",
        "path-is-absolute": "^1.0.0"
      },
      "engines": {
        "node": "*"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/glob-parent": {
      "version": "6.0.2",
      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-6.0.2.tgz",
      "integrity": "sha512-XxwI8EOhVQgWp6iDL+3b0r86f4d6AX6zSU55HfB4ydCEuXLXc5FcYeOu+nnGftS4TEju/11rt4KJPTMgbfmv4A==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "is-glob": "^4.0.3"
      },
      "engines": {
        "node": ">=10.13.0"
      }
    },
    "node_modules/glob/node_modules/brace-expansion": {
      "version": "1.1.12",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.12.tgz",
      "integrity": "sha512-9T9UjW3r0UW5c1Q7GTwllptXwhvYmEzFhzMfZ9H7FQWt+uZePjZPjBP/W1ZEyZ1twGWom5/56TF4lPcqjnDHcg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "balanced-match": "^1.0.0",
        "concat-map": "0.0.1"
      }
    },
    "node_modules/glob/node_modules/minimatch": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz",
      "integrity": "sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "brace-expansion": "^1.1.7"
      },
      "engines": {
        "node": "*"
      }
    },
    "node_modules/globals": {
      "version": "13.24.0",
      "resolved": "https://registry.npmjs.org/globals/-/globals-13.24.0.tgz",
      "integrity": "sha512-AhO5QUcj8llrbG09iWhPU2B204J1xnPeL8kQmVorSsy+Sjj1sk8gIyh6cUocGmH4L0UuhAJy+hJMRA4mgA4mFQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "type-fest": "^0.20.2"
      },
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/globby": {
      "version": "11.1.0",
      "resolved": "https://registry.npmjs.org/globby/-/globby-11.1.0.tgz",
      "integrity": "sha512-jhIXaOzy1sb8IyocaruWSn1TjmnBVs8Ayhcy83rmxNJ8q2uWKCAj3CnJY+KpGSXCueAPc0i05kVvVKtP1t9S3g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "array-union": "^2.1.0",
        "dir-glob": "^3.0.1",
        "fast-glob": "^3.2.9",
        "ignore": "^5.2.0",
        "merge2": "^1.4.1",
        "slash": "^3.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/graphemer": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/graphemer/-/graphemer-1.4.0.tgz",
      "integrity": "sha512-EtKwoO6kxCL9WO5xipiHTZlSzBm7WLT627TqC/uVRd0HKmq8NXyebnNYxDoBi7wt8eTWrUrKXCOVaFq9x1kgag==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/has-flag": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-4.0.0.tgz",
      "integrity": "sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/home-assistant-js-websocket": {
      "version": "6.1.1",
      "resolved": "https://registry.npmjs.org/home-assistant-js-websocket/-/home-assistant-js-websocket-6.1.1.tgz",
      "integrity": "sha512-TnZFzF4mn5F/v0XKUTK2GMQXrn/+eQpgaSDSELl6U0HSwSbFwRhGWLz330YT+hiKMspDflamsye//RPL+zwhDw==",
      "license": "Apache-2.0"
    },
    "node_modules/ignore": {
      "version": "5.3.2",
      "resolved": "https://registry.npmjs.org/ignore/-/ignore-5.3.2.tgz",
      "integrity": "sha512-hsBTNUqQTDwkWtcdYI2i06Y/nUBEsNEDJKjWdigLvegy8kDuJAS8uRlpkkcQpyEXL0Z/pjDy5HBmMjRCJ2gq+g==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 4"
      }
    },
    "node_modules/import-fresh": {
      "version": "3.3.1",
      "resolved": "https://registry.npmjs.org/import-fresh/-/import-fresh-3.3.1.tgz",
      "integrity": "sha512-TR3KfrTZTYLPB6jUjfx6MF9WcWrHL9su5TObK4ZkYgBdWKPOFoSoQIdEuTuR82pmtxH2spWG9h6etwfr1pLBqQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "parent-module": "^1.0.0",
        "resolve-from": "^4.0.0"
      },
      "engines": {
        "node": ">=6"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/imurmurhash": {
      "version": "0.1.4",
      "resolved": "https://registry.npmjs.org/imurmurhash/-/imurmurhash-0.1.4.tgz",
      "integrity": "sha512-JmXMZ6wuvDmLiHEml9ykzqO6lwFbof0GG4IkcGaENdCRDDmMVnny7s5HsIgHCbaq0w2MyPhDqkhTUgS2LU2PHA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.8.19"
      }
    },
    "node_modules/inflight": {
      "version": "1.0.6",
      "resolved": "https://registry.npmjs.org/inflight/-/inflight-1.0.6.tgz",
      "integrity": "sha512-k92I/b08q4wvFscXCLvqfsHCrjrF7yiXsQuIVvVE7N82W3+aqpzuUdBbfhWcy/FZR3/4IgflMgKLOsvPDrGCJA==",
      "deprecated": "This module is not supported, and leaks memory. Do not use it. Check out lru-cache if you want a good and tested way to coalesce async requests by a key value, which is much more comprehensive and powerful.",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "once": "^1.3.0",
        "wrappy": "1"
      }
    },
    "node_modules/inherits": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
      "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/intl-messageformat": {
      "version": "9.13.0",
      "resolved": "https://registry.npmjs.org/intl-messageformat/-/intl-messageformat-9.13.0.tgz",
      "integrity": "sha512-7sGC7QnSQGa5LZP7bXLDhVDtQOeKGeBFGHF2Y8LVBwYZoQZCgWeKoPGTa5GMG8g/TzDgeXuYJQis7Ggiw2xTOw==",
      "license": "BSD-3-Clause",
      "dependencies": {
        "@formatjs/ecma402-abstract": "1.11.4",
        "@formatjs/fast-memoize": "1.2.1",
        "@formatjs/icu-messageformat-parser": "2.1.0",
        "tslib": "^2.1.0"
      }
    },
    "node_modules/is-extglob": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/is-extglob/-/is-extglob-2.1.1.tgz",
      "integrity": "sha512-SbKbANkN603Vi4jEZv49LeVJMn4yGwsbzZworEoyEiutsN3nJYdbO36zfhGJ6QEDpOZIFkDtnq5JRxmvl3jsoQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-glob": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz",
      "integrity": "sha512-xelSayHH36ZgE7ZWhli7pW34hNbNl8Ojv5KVmkJD4hBdD3th8Tfk9vYasLM+mXWOZhFkgZfxhLSnrwRr4elSSg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-extglob": "^2.1.1"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-number": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/is-number/-/is-number-7.0.0.tgz",
      "integrity": "sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.12.0"
      }
    },
    "node_modules/is-path-inside": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/is-path-inside/-/is-path-inside-3.0.3.tgz",
      "integrity": "sha512-Fd4gABb+ycGAmKou8eMftCupSir5lRxqf4aD/vd0cD2qc4HL07OjCeuHMr8Ro4CoMaeCKDB0/ECBOVWjTwUvPQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/isexe": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/isexe/-/isexe-2.0.0.tgz",
      "integrity": "sha512-RHxMLp9lnKHGHRng9QFhRCMbYAcVpn69smSGcq3f36xjgVVWThj4qqLbTLlq7Ssj8B+fIQ1EuCEGI2lKsyQeIw==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/js-yaml": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.0.tgz",
      "integrity": "sha512-wpxZs9NoxZaJESJGIZTyDEaYpl0FKSA+FB9aJiyemKhMwkxQg63h4T1KJgUGHpTqPDNRcmmYLugrRjJlBtWvRA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "argparse": "^2.0.1"
      },
      "bin": {
        "js-yaml": "bin/js-yaml.js"
      }
    },
    "node_modules/json-buffer": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/json-buffer/-/json-buffer-3.0.1.tgz",
      "integrity": "sha512-4bV5BfR2mqfQTJm+V5tPPdf+ZpuhiIvTuAB5g8kcrXOZpTT/QwwVRWBywX1ozr6lEuPdbHxwaJlm9G6mI2sfSQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/json-schema-traverse": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-0.4.1.tgz",
      "integrity": "sha512-xbbCH5dCYU5T8LcEhhuh7HJ88HXuW3qsI3Y0zOZFKfZEHcpWiHU/Jxzk629Brsab/mMiHQti9wMP+845RPe3Vg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/json-stable-stringify-without-jsonify": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/json-stable-stringify-without-jsonify/-/json-stable-stringify-without-jsonify-1.0.1.tgz",
      "integrity": "sha512-Bdboy+l7tA3OGW6FjyFHWkP5LuByj1Tk33Ljyq0axyzdk9//JSi2u3fP1QSmd1KNwq6VOKYGlAu87CisVir6Pw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/keyv": {
      "version": "4.5.4",
      "resolved": "https://registry.npmjs.org/keyv/-/keyv-4.5.4.tgz",
      "integrity": "sha512-oxVHkHR/EJf2CNXnWxRLW6mg7JyCCUcG0DtEGmL2ctUo1PNTin1PUil+r/+4r5MpVgC/fn1kjsx7mjSujKqIpw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "json-buffer": "3.0.1"
      }
    },
    "node_modules/levn": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/levn/-/levn-0.4.1.tgz",
      "integrity": "sha512-+bT2uH4E5LGE7h/n3evcS/sQlJXCpIp6ym8OWJ5eV6+67Dsql/LaaT7qJBAt2rzfoa/5QBGBhxDix1dMt2kQKQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "prelude-ls": "^1.2.1",
        "type-check": "~0.4.0"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/lit": {
      "version": "3.3.1",
      "resolved": "https://registry.npmjs.org/lit/-/lit-3.3.1.tgz",
      "integrity": "sha512-Ksr/8L3PTapbdXJCk+EJVB78jDodUMaP54gD24W186zGRARvwrsPfS60wae/SSCTCNZVPd1chXqio1qHQmu4NA==",
      "license": "BSD-3-Clause",
      "dependencies": {
        "@lit/reactive-element": "^2.1.0",
        "lit-element": "^4.2.0",
        "lit-html": "^3.3.0"
      }
    },
    "node_modules/lit-element": {
      "version": "4.2.1",
      "resolved": "https://registry.npmjs.org/lit-element/-/lit-element-4.2.1.tgz",
      "integrity": "sha512-WGAWRGzirAgyphK2urmYOV72tlvnxw7YfyLDgQ+OZnM9vQQBQnumQ7jUJe6unEzwGU3ahFOjuz1iz1jjrpCPuw==",
      "license": "BSD-3-Clause",
      "dependencies": {
        "@lit-labs/ssr-dom-shim": "^1.4.0",
        "@lit/reactive-element": "^2.1.0",
        "lit-html": "^3.3.0"
      }
    },
    "node_modules/lit-html": {
      "version": "3.3.1",
      "resolved": "https://registry.npmjs.org/lit-html/-/lit-html-3.3.1.tgz",
      "integrity": "sha512-S9hbyDu/vs1qNrithiNyeyv64c9yqiW9l+DBgI18fL+MTvOtWoFR0FWiyq1TxaYef5wNlpEmzlXoBlZEO+WjoA==",
      "license": "BSD-3-Clause",
      "dependencies": {
        "@types/trusted-types": "^2.0.2"
      }
    },
    "node_modules/locate-path": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/locate-path/-/locate-path-6.0.0.tgz",
      "integrity": "sha512-iPZK6eYjbxRu3uB4/WZ3EsEIMJFMqAoopl3R+zuq0UjcAm/MO6KCweDgPfP3elTztoKP3KtnVHxTn2NHBSDVUw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "p-locate": "^5.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/lodash.merge": {
      "version": "4.6.2",
      "resolved": "https://registry.npmjs.org/lodash.merge/-/lodash.merge-4.6.2.tgz",
      "integrity": "sha512-0KpjqXRVvrYyCsX1swR/XTK0va6VQkQM6MNo7PqW77ByjAhoARA8EfrP1N4+KlKj8YS0ZUCtRT/YUuhyYDujIQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/merge2": {
      "version": "1.4.1",
      "resolved": "https://registry.npmjs.org/merge2/-/merge2-1.4.1.tgz",
      "integrity": "sha512-8q7VEgMJW4J8tcfVPy8g09NcQwZdbwFEqhe/WZkoIzjn/3TGDwtOCYtXGxA3O8tPzpczCCDgv+P2P5y00ZJOOg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/micromatch": {
      "version": "4.0.8",
      "resolved": "https://registry.npmjs.org/micromatch/-/micromatch-4.0.8.tgz",
      "integrity": "sha512-PXwfBhYu0hBCPw8Dn0E+WDYb7af3dSLVWKi3HGv84IdF4TyFoC0ysxFd0Goxw7nSv4T/PzEJQxsYsEiFCKo2BA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "braces": "^3.0.3",
        "picomatch": "^2.3.1"
      },
      "engines": {
        "node": ">=8.6"
      }
    },
    "node_modules/minimatch": {
      "version": "9.0.3",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-9.0.3.tgz",
      "integrity": "sha512-RHiac9mvaRw0x3AYRgDC1CxAP7HTcNrrECeA8YYJeWnpo+2Q5CegtZjaotWTWxDG3UeGA1coE05iH1mPjT/2mg==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "brace-expansion": "^2.0.1"
      },
      "engines": {
        "node": ">=16 || 14 >=14.17"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/nanoid": {
      "version": "3.3.11",
      "resolved": "https://registry.npmjs.org/nanoid/-/nanoid-3.3.11.tgz",
      "integrity": "sha512-N8SpfPUnUp1bK+PMYW8qSWdl9U+wwNWI4QKxOYDy9JAro3WMX7p2OeVRF9v+347pnakNevPmiHhNmZ2HbFA76w==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "bin": {
        "nanoid": "bin/nanoid.cjs"
      },
      "engines": {
        "node": "^10 || ^12 || ^13.7 || ^14 || >=15.0.1"
      }
    },
    "node_modules/natural-compare": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/natural-compare/-/natural-compare-1.4.0.tgz",
      "integrity": "sha512-OWND8ei3VtNC9h7V60qff3SVobHr996CTwgxubgyQYEpg290h9J0buyECNNJexkFm5sOajh5G116RYA1c8ZMSw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/once": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/once/-/once-1.4.0.tgz",
      "integrity": "sha512-lNaJgI+2Q5URQBkccEKHTQOPaXdUxnZZElQTZY0MFUAuaEqe1E+Nyvgdz/aIyNi6Z9MzO5dv1H8n58/GELp3+w==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "wrappy": "1"
      }
    },
    "node_modules/optionator": {
      "version": "0.9.4",
      "resolved": "https://registry.npmjs.org/optionator/-/optionator-0.9.4.tgz",
      "integrity": "sha512-6IpQ7mKUxRcZNLIObR0hz7lxsapSSIYNZJwXPGeF0mTVqGKFIXj1DQcMoT22S3ROcLyY/rz0PWaWZ9ayWmad9g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "deep-is": "^0.1.3",
        "fast-levenshtein": "^2.0.6",
        "levn": "^0.4.1",
        "prelude-ls": "^1.2.1",
        "type-check": "^0.4.0",
        "word-wrap": "^1.2.5"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/p-limit": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/p-limit/-/p-limit-3.1.0.tgz",
      "integrity": "sha512-TYOanM3wGwNGsZN2cVTYPArw454xnXj5qmWF1bEoAc4+cU/ol7GVh7odevjp1FNHduHc3KZMcFduxU5Xc6uJRQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "yocto-queue": "^0.1.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/p-locate": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/p-locate/-/p-locate-5.0.0.tgz",
      "integrity": "sha512-LaNjtRWUBY++zB5nE/NwcaoMylSPk+S+ZHNB1TzdbMJMny6dynpAGt7X/tl/QYq3TIeE6nxHppbo2LGymrG5Pw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "p-limit": "^3.0.2"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/parent-module": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz",
      "integrity": "sha512-GQ2EWRpQV8/o+Aw8YqtfZZPfNRWZYkbidE9k5rpl/hC3vtHHBfGm2Ifi6qWV+coDGkrUKZAxE3Lot5kcsRlh+g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "callsites": "^3.0.0"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/path-exists": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/path-exists/-/path-exists-4.0.0.tgz",
      "integrity": "sha512-ak9Qy5Q7jYb2Wwcey5Fpvg2KoAc/ZIhLSLOSBmRmygPsGwkVVt0fZa0qrtMz+m6tJTAHfZQ8FnmB4MG4LWy7/w==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/path-is-absolute": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/path-is-absolute/-/path-is-absolute-1.0.1.tgz",
      "integrity": "sha512-AVbw3UJ2e9bq64vSaS9Am0fje1Pa8pbGqTTsmXfaIiMpnr5DlDhfJOuLj9Sf95ZPVDAUerDfEk88MPmPe7UCQg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/path-key": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/path-key/-/path-key-3.1.1.tgz",
      "integrity": "sha512-ojmeN0qd+y0jszEtoY48r0Peq5dwMEkIlCOu6Q5f41lfkswXuKtYrhgoTpLnyIcHm24Uhqx+5Tqm2InSwLhE6Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/path-type": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/path-type/-/path-type-4.0.0.tgz",
      "integrity": "sha512-gDKb8aZMDeD/tZWs9P6+q0J9Mwkdl6xMV8TjnGP3qJVJ06bdMgkbBlLU8IdfOsIsFz2BW1rNVT3XuNEl8zPAvw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/picocolors": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/picocolors/-/picocolors-1.1.1.tgz",
      "integrity": "sha512-xceH2snhtb5M9liqDsmEw56le376mTZkEX/jEb/RxNFyegNul7eNslCXP9FDj/Lcu0X8KEyMceP2ntpaHrDEVA==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/picomatch": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-2.3.1.tgz",
      "integrity": "sha512-JU3teHTNjmE2VCGFzuY8EXzCDVwEqB2a8fsIvwaStHhAWJEeVd1o1QD80CU6+ZdEXXSLbSsuLwJjkCBWqRQUVA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/jonschlinkert"
      }
    },
    "node_modules/postcss": {
      "version": "8.5.6",
      "resolved": "https://registry.npmjs.org/postcss/-/postcss-8.5.6.tgz",
      "integrity": "sha512-3Ybi1tAuwAP9s0r1UQ2J4n5Y0G05bJkpUIO0/bI9MhwmD70S5aTWbXGBwxHrelT+XM1k6dM0pk+SwNkpTRN7Pg==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/postcss"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "nanoid": "^3.3.11",
        "picocolors": "^1.1.1",
        "source-map-js": "^1.2.1"
      },
      "engines": {
        "node": "^10 || ^12 || >=14"
      }
    },
    "node_modules/prelude-ls": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/prelude-ls/-/prelude-ls-1.2.1.tgz",
      "integrity": "sha512-vkcDPrRZo1QZLbn5RLGPpg/WmIQ65qoWWhcGKf/b5eplkkarX0m9z8ppCat4mlOqUsWpyNuYgO3VRyrYHSzX5g==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/punycode": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/punycode/-/punycode-2.3.1.tgz",
      "integrity": "sha512-vYt7UD1U9Wg6138shLtLOvdAu+8DsC/ilFtEVHcH+wydcSpNE20AfSOduf6MkRFahL5FY7X1oU7nKVZFtfq8Fg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/queue-microtask": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/queue-microtask/-/queue-microtask-1.2.3.tgz",
      "integrity": "sha512-NuaNSa6flKT5JaSYQzJok04JzTL1CA6aGhv5rfLW3PgqA+M2ChpZQnAC8h8i4ZFkBS8X5RqkDBHA7r4hej3K9A==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT"
    },
    "node_modules/resolve-from": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/resolve-from/-/resolve-from-4.0.0.tgz",
      "integrity": "sha512-pb/MYmXstAkysRFx8piNI1tGFNQIFA3vkE3Gq4EuA1dF6gHp/+vgZqsCGJapvy8N3Q+4o7FwvquPJcnZ7RYy4g==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/reusify": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/reusify/-/reusify-1.1.0.tgz",
      "integrity": "sha512-g6QUff04oZpHs0eG5p83rFLhHeV00ug/Yf9nZM6fLeUrPguBTkTQOdpAWWspMh55TZfVQDPaN3NQJfbVRAxdIw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "iojs": ">=1.0.0",
        "node": ">=0.10.0"
      }
    },
    "node_modules/rimraf": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/rimraf/-/rimraf-3.0.2.tgz",
      "integrity": "sha512-JZkJMZkAGFFPP2YqXZXPbMlMBgsxzE8ILs4lMIX/2o0L9UBw9O/Y3o6wFw/i9YLapcUJWwqbi3kdxIPdC62TIA==",
      "deprecated": "Rimraf versions prior to v4 are no longer supported",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "glob": "^7.1.3"
      },
      "bin": {
        "rimraf": "bin.js"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/rollup": {
      "version": "2.79.2",
      "resolved": "https://registry.npmjs.org/rollup/-/rollup-2.79.2.tgz",
      "integrity": "sha512-fS6iqSPZDs3dr/y7Od6y5nha8dW1YnbgtsyotCVvoFGKbERG++CVRFv1meyGDE1SNItQA8BrnCw7ScdAhRJ3XQ==",
      "license": "MIT",
      "bin": {
        "rollup": "dist/bin/rollup"
      },
      "engines": {
        "node": ">=10.0.0"
      },
      "optionalDependencies": {
        "fsevents": "~2.3.2"
      }
    },
    "node_modules/run-parallel": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/run-parallel/-/run-parallel-1.2.0.tgz",
      "integrity": "sha512-5l4VyZR86LZ/lDxZTR6jqL8AFE2S0IFLMP26AbjsLVADxHdhB/c0GUsH+y39UfCi3dzz8OlQuPmnaJOMoDHQBA==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "queue-microtask": "^1.2.2"
      }
    },
    "node_modules/semver": {
      "version": "7.7.2",
      "resolved": "https://registry.npmjs.org/semver/-/semver-7.7.2.tgz",
      "integrity": "sha512-RF0Fw+rO5AMf9MAyaRXI4AV0Ulj5lMHqVxxdSgiVbixSCXoEmmX/jk0CuJw4+3SqroYO9VoUh+HcuJivvtJemA==",
      "dev": true,
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/shebang-command": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/shebang-command/-/shebang-command-2.0.0.tgz",
      "integrity": "sha512-kHxr2zZpYtdmrN1qDjrrX/Z1rR1kG8Dx+gkpK1G4eXmvXswmcE1hTWBWYUzlraYw1/yZp6YuDY77YtvbN0dmDA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "shebang-regex": "^3.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/shebang-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/shebang-regex/-/shebang-regex-3.0.0.tgz",
      "integrity": "sha512-7++dFhtcx3353uBaq8DDR4NuxBetBzC7ZQOhmTQInHEd6bSrXdiEyzCvG07Z44UYdLShWUyXt5M/yhz8ekcb1A==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/sip.js": {
      "version": "0.21.2",
      "resolved": "https://registry.npmjs.org/sip.js/-/sip.js-0.21.2.tgz",
      "integrity": "sha512-tSqTcIgrOd2IhP/rd70JablvAp+fSfLSxO4hGNY6LkWRY1SKygTO7OtJEV/BQb8oIxtMRx0LE7nUF2MaqGbFzA==",
      "license": "MIT",
      "engines": {
        "node": ">=10.0"
      }
    },
    "node_modules/slash": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/slash/-/slash-3.0.0.tgz",
      "integrity": "sha512-g9Q1haeby36OSStwb4ntCGGGaKsaVSjQ68fBxoQcutl5fS1vuY18H3wSt3jFyFtrkx+Kz0V1G85A4MyAdDMi2Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/source-map-js": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/source-map-js/-/source-map-js-1.2.1.tgz",
      "integrity": "sha512-UXWMKhLOwVKb728IUtQPXxfYU+usdybtUrK/8uGE8CQMvrhOpwvzDBwj0QhSL7MQc7vIsISBG8VQ8+IDQxpfQA==",
      "dev": true,
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/strip-ansi": {
      "version": "6.0.1",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
      "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-regex": "^5.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/strip-json-comments": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.1.tgz",
      "integrity": "sha512-6fPc+R4ihwqP6N/aIv2f1gMH8lOVtWQHoqC4yK6oSDVVocumAsfCqjkXnqiYMhmMwS/mEHLp7Vehlt3ql6lEig==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/superstruct": {
      "version": "0.15.5",
      "resolved": "https://registry.npmjs.org/superstruct/-/superstruct-0.15.5.tgz",
      "integrity": "sha512-4AOeU+P5UuE/4nOUkmcQdW5y7i9ndt1cQd/3iUe+LTz3RxESf/W/5lg4B74HbDMMv8PHnPnGCQFH45kBcrQYoQ==",
      "license": "MIT"
    },
    "node_modules/supports-color": {
      "version": "7.2.0",
      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-7.2.0.tgz",
      "integrity": "sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "has-flag": "^4.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/text-table": {
      "version": "0.2.0",
      "resolved": "https://registry.npmjs.org/text-table/-/text-table-0.2.0.tgz",
      "integrity": "sha512-N+8UisAXDGk8PFXP4HAzVR9nbfmVJ3zYLAWiTIoqC5v5isinhr+r5uaO8+7r3BMfuNIufIsA7RdpVgacC2cSpw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/to-regex-range": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/to-regex-range/-/to-regex-range-5.0.1.tgz",
      "integrity": "sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-number": "^7.0.0"
      },
      "engines": {
        "node": ">=8.0"
      }
    },
    "node_modules/ts-api-utils": {
      "version": "1.4.3",
      "resolved": "https://registry.npmjs.org/ts-api-utils/-/ts-api-utils-1.4.3.tgz",
      "integrity": "sha512-i3eMG77UTMD0hZhgRS562pv83RC6ukSAC2GMNWc+9dieh/+jDM5u5YG+NHX6VNDRHQcHwmsTHctP9LhbC3WxVw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=16"
      },
      "peerDependencies": {
        "typescript": ">=4.2.0"
      }
    },
    "node_modules/tslib": {
      "version": "2.8.1",
      "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.8.1.tgz",
      "integrity": "sha512-oJFu94HQb+KVduSUQL7wnpmqnfmLsOA/nAh6b6EH0wCEoK0/mPeXU6c3wKDV83MkOuHPRHtSXKKU99IBazS/2w==",
      "license": "0BSD"
    },
    "node_modules/type-check": {
      "version": "0.4.0",
      "resolved": "https://registry.npmjs.org/type-check/-/type-check-0.4.0.tgz",
      "integrity": "sha512-XleUoc9uwGXqjWwXaUTZAmzMcFZ5858QA2vvx1Ur5xIcixXIP+8LnFDgRplU30us6teqdlskFfu+ae4K79Ooew==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "prelude-ls": "^1.2.1"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/type-fest": {
      "version": "0.20.2",
      "resolved": "https://registry.npmjs.org/type-fest/-/type-fest-0.20.2.tgz",
      "integrity": "sha512-Ne+eE4r0/iWnpAxD852z3A+N0Bt5RN//NjJwRd2VFHEmrywxf5vsZlh4R6lixl6B+wz/8d+maTSAkN1FIkI3LQ==",
      "dev": true,
      "license": "(MIT OR CC0-1.0)",
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/typescript": {
      "version": "5.9.2",
      "resolved": "https://registry.npmjs.org/typescript/-/typescript-5.9.2.tgz",
      "integrity": "sha512-CWBzXQrc/qOkhidw1OzBTQuYRbfyxDXJMVJ1XNwUHGROVmuaeiEm3OslpZ1RV96d7SKKjZKrSJu3+t/xlw3R9A==",
      "dev": true,
      "license": "Apache-2.0",
      "bin": {
        "tsc": "bin/tsc",
        "tsserver": "bin/tsserver"
      },
      "engines": {
        "node": ">=14.17"
      }
    },
    "node_modules/undici-types": {
      "version": "7.12.0",
      "resolved": "https://registry.npmjs.org/undici-types/-/undici-types-7.12.0.tgz",
      "integrity": "sha512-goOacqME2GYyOZZfb5Lgtu+1IDmAlAEu5xnD3+xTzS10hT0vzpf0SPjkXwAw9Jm+4n/mQGDP3LO8CPbYROeBfQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/uri-js": {
      "version": "4.4.1",
      "resolved": "https://registry.npmjs.org/uri-js/-/uri-js-4.4.1.tgz",
      "integrity": "sha512-7rKUyy33Q1yc98pQ1DAmLtwX109F7TIfWlW1Ydo8Wl1ii1SeHieeh0HHfPeL2fMXK6z0s8ecKs9frCuLJvndBg==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "punycode": "^2.1.0"
      }
    },
    "node_modules/vite": {
      "version": "5.4.20",
      "resolved": "https://registry.npmjs.org/vite/-/vite-5.4.20.tgz",
      "integrity": "sha512-j3lYzGC3P+B5Yfy/pfKNgVEg4+UtcIJcVRt2cDjIOmhLourAqPqf8P7acgxeiSgUB7E3p2P8/3gNIgDLpwzs4g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "esbuild": "^0.21.3",
        "postcss": "^8.4.43",
        "rollup": "^4.20.0"
      },
      "bin": {
        "vite": "bin/vite.js"
      },
      "engines": {
        "node": "^18.0.0 || >=20.0.0"
      },
      "funding": {
        "url": "https://github.com/vitejs/vite?sponsor=1"
      },
      "optionalDependencies": {
        "fsevents": "~2.3.3"
      },
      "peerDependencies": {
        "@types/node": "^18.0.0 || >=20.0.0",
        "less": "*",
        "lightningcss": "^1.21.0",
        "sass": "*",
        "sass-embedded": "*",
        "stylus": "*",
        "sugarss": "*",
        "terser": "^5.4.0"
      },
      "peerDependenciesMeta": {
        "@types/node": {
          "optional": true
        },
        "less": {
          "optional": true
        },
        "lightningcss": {
          "optional": true
        },
        "sass": {
          "optional": true
        },
        "sass-embedded": {
          "optional": true
        },
        "stylus": {
          "optional": true
        },
        "sugarss": {
          "optional": true
        },
        "terser": {
          "optional": true
        }
      }
    },
    "node_modules/vite/node_modules/rollup": {
      "version": "4.52.0",
      "resolved": "https://registry.npmjs.org/rollup/-/rollup-4.52.0.tgz",
      "integrity": "sha512-+IuescNkTJQgX7AkIDtITipZdIGcWF0pnVvZTWStiazUmcGA2ag8dfg0urest2XlXUi9kuhfQ+qmdc5Stc3z7g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/estree": "1.0.8"
      },
      "bin": {
        "rollup": "dist/bin/rollup"
      },
      "engines": {
        "node": ">=18.0.0",
        "npm": ">=8.0.0"
      },
      "optionalDependencies": {
        "@rollup/rollup-android-arm-eabi": "4.52.0",
        "@rollup/rollup-android-arm64": "4.52.0",
        "@rollup/rollup-darwin-arm64": "4.52.0",
        "@rollup/rollup-darwin-x64": "4.52.0",
        "@rollup/rollup-freebsd-arm64": "4.52.0",
        "@rollup/rollup-freebsd-x64": "4.52.0",
        "@rollup/rollup-linux-arm-gnueabihf": "4.52.0",
        "@rollup/rollup-linux-arm-musleabihf": "4.52.0",
        "@rollup/rollup-linux-arm64-gnu": "4.52.0",
        "@rollup/rollup-linux-arm64-musl": "4.52.0",
        "@rollup/rollup-linux-loong64-gnu": "4.52.0",
        "@rollup/rollup-linux-ppc64-gnu": "4.52.0",
        "@rollup/rollup-linux-riscv64-gnu": "4.52.0",
        "@rollup/rollup-linux-riscv64-musl": "4.52.0",
        "@rollup/rollup-linux-s390x-gnu": "4.52.0",
        "@rollup/rollup-linux-x64-gnu": "4.52.0",
        "@rollup/rollup-linux-x64-musl": "4.52.0",
        "@rollup/rollup-openharmony-arm64": "4.52.0",
        "@rollup/rollup-win32-arm64-msvc": "4.52.0",
        "@rollup/rollup-win32-ia32-msvc": "4.52.0",
        "@rollup/rollup-win32-x64-gnu": "4.52.0",
        "@rollup/rollup-win32-x64-msvc": "4.52.0",
        "fsevents": "~2.3.2"
      }
    },
    "node_modules/which": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/which/-/which-2.0.2.tgz",
      "integrity": "sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "isexe": "^2.0.0"
      },
      "bin": {
        "node-which": "bin/node-which"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/word-wrap": {
      "version": "1.2.5",
      "resolved": "https://registry.npmjs.org/word-wrap/-/word-wrap-1.2.5.tgz",
      "integrity": "sha512-BN22B5eaMMI9UMtjrGd5g5eCYPpCPDUy0FJXbYsaT5zYxjFOckS53SQDE3pWkVoWpHXVb3BrYcEN4Twa55B5cA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/wrappy": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
      "integrity": "sha512-l4Sp/DRseor9wL6EvV2+TuQn63dMkPjZ/sp9XkghTEbV9KlPS1xUsZ3u7/IQO4wxtcFB4bgpQPRcR3QCvezPcQ==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/yocto-queue": {
      "version": "0.1.0",
      "resolved": "https://registry.npmjs.org/yocto-queue/-/yocto-queue-0.1.0.tgz",
      "integrity": "sha512-rVksvsnNCdJ/ohGc6xgPwyN8eheCxsiLM8mxuE/t/mOVqJewPuO1miLpTHQiRgTKCLexL4MeAFVagts7HmNZ2Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    }
  }
}

---

=== Object: c1145b1516f3323142a3c94459fa789b943e02ce | Date: 2025-09-23 15:23:51 | Type: blob ===

import { debugLog, errorLog } from "./utils";

type SimpleUser = any;
type SimpleUserOptions = any;
let Web: any = null;

export interface SipConfig {
  server: string;
  username: string;
  password: string;
  domain: string;
  websocket_port: number;
  use_secure: boolean;
  display_name?: string;
  debug?: boolean;
}

export interface CallInfo {
  id: string;
  remoteIdentity: string;
  displayName: string;
  state: "incoming" | "outgoing" | "connected" | "ended";
  startTime?: Date;
  duration: number;
}

export class SipManager extends EventTarget {
  private simpleUser: SimpleUser | null = null;
  private config: SipConfig | null = null;
  private isRegistered = false;
  private isConnected = false;
  private connectionTimer: number | null = null;
  private currentCall: CallInfo | null = null;
  private remoteAudio: HTMLAudioElement | null = null;
  private remoteVideo: HTMLVideoElement | null = null;
  private localVideo: HTMLVideoElement | null = null;
  private localStream: MediaStream | null = null;
  private videoEnabled = false;
  private isInitialized = false;
  private isInitializing = false;
  private lastVideoState = false;

  constructor() {
    super();
    this.setupMediaElements();
  }

  private setupMediaElements(): void {
    this.remoteAudio = document.createElement("audio");
    this.remoteAudio.autoplay = true;
    this.remoteAudio.style.display = "none";
    document.body.appendChild(this.remoteAudio);

    this.remoteVideo = document.createElement("video");
    this.remoteVideo.autoplay = true;
    this.remoteVideo.playsInline = true;
    this.remoteVideo.style.display = "none";
    document.body.appendChild(this.remoteVideo);

    this.localVideo = document.createElement("video");
    this.localVideo.autoplay = true;
    this.localVideo.muted = true;
    this.localVideo.playsInline = true;
    this.localVideo.style.display = "none";
    document.body.appendChild(this.localVideo);
  }

  private async getUserMedia(includeVideo: boolean = false): Promise<MediaStream> {
    const constraints: MediaStreamConstraints = {
      audio: {
        echoCancellation: true,
        noiseSuppression: true,
        autoGainControl: true,
        sampleRate: 48000,
      },
      video: includeVideo
        ? {
            width: { ideal: 640, min: 320, max: 1280 },
            height: { ideal: 480, min: 240, max: 720 },
            frameRate: { ideal: 30, min: 15, max: 30 },
            facingMode: "user",
          }
        : false,
    };

    return navigator.mediaDevices.getUserMedia(constraints);
  }

  public async enableVideo(): Promise<void> {
    try {
      const stream = await this.getUserMedia(true);

      if (this.localStream) {
        this.localStream.getTracks().forEach((track) => track.stop());
      }

      if (this.localVideo) {
        this.localVideo.srcObject = stream;
      }

      this.localStream = stream;
      this.videoEnabled = true;

      debugLog(this.config?.debug || false, "Local video enabled with new stream:", {
        videoTracks: stream.getVideoTracks().length,
        audioTracks: stream.getAudioTracks().length,
        streamId: stream.id,
      });

      if (this.simpleUser?.session && this.currentCall?.state === "connected") {
        await this.replaceMediaTracks(stream);
      }

      this.dispatchEvent(
        new CustomEvent("localVideoChanged", {
          detail: {
            enabled: true,
            transmitting: stream.getVideoTracks().some((track) => track.enabled && track.readyState === "live"),
          },
        })
      );
    } catch (error) {
      errorLog("Enable video failed", error);
      this.videoEnabled = false;
      throw error;
    }
  }

  public async disableVideo(): Promise<void> {
    try {
      const audioOnlyStream = await this.getUserMedia(false);

      if (this.localVideo) {
        this.localVideo.srcObject = null;
      }

      if (this.localStream) {
        this.localStream.getTracks().forEach((track) => {
          track.stop();
          debugLog(this.config?.debug || false, `Stopped ${track.kind} track:`, track.id);
        });
      }

      this.localStream = audioOnlyStream;
      this.videoEnabled = false;

      debugLog(this.config?.debug || false, "Local video disabled, using audio-only stream:", {
        videoTracks: audioOnlyStream.getVideoTracks().length,
        audioTracks: audioOnlyStream.getAudioTracks().length,
        streamId: audioOnlyStream.id,
      });

      if (this.simpleUser?.session && this.currentCall?.state === "connected") {
        await this.replaceMediaTracks(audioOnlyStream);
      }

      this.dispatchEvent(
        new CustomEvent("localVideoChanged", {
          detail: {
            enabled: false,
            transmitting: false,
          },
        })
      );
    } catch (error) {
      errorLog("Disable video failed", error);
      throw error;
    }
  }

  private async replaceMediaTracks(newStream: MediaStream): Promise<void> {
    try {
      const session = this.simpleUser?.session;
      if (!session || !session.sessionDescriptionHandler) {
        debugLog(this.config?.debug || false, "No active session to replace tracks");
        return;
      }

      const pc = session.sessionDescriptionHandler.peerConnection;
      if (!pc) {
        debugLog(this.config?.debug || false, "No peer connection found");
        return;
      }

      const senders = pc.getSenders();

      const audioTrack = newStream.getAudioTracks()[0];
      const audioSender = senders.find((sender: any) => sender.track && sender.track.kind === "audio");
      if (audioSender && audioTrack) {
        await audioSender.replaceTrack(audioTrack);
        debugLog(this.config?.debug || false, "Audio track replaced successfully");
      }

      const videoTrack = newStream.getVideoTracks()[0] || null;
      const videoSender = senders.find((sender: any) => sender.track && sender.track.kind === "video");

      if (videoSender) {
        await videoSender.replaceTrack(videoTrack);
        debugLog(this.config?.debug || false, videoTrack ? "Video track replaced" : "Video track removed from sender");
      } else if (videoTrack) {
        try {
          pc.addTrack(videoTrack, newStream);
          debugLog(this.config?.debug || false, "Video track added to peer connection");

          if (session.sessionDescriptionHandler && typeof session.sessionDescriptionHandler.sendReinvite === "function") {
            await session.sessionDescriptionHandler.sendReinvite();
            debugLog(this.config?.debug || false, "Session renegotiated for new video track");
          }
        } catch (error) {
          debugLog(this.config?.debug || false, "Failed to add video track:", error);
        }
      }
    } catch (error) {
      debugLog(this.config?.debug || false, "Replace media tracks failed but call continues:", error);
    }
  }

  public async toggleVideo(): Promise<boolean> {
    try {
      if (this.videoEnabled) {
        await this.disableVideo();
        return false;
      } else {
        await this.enableVideo();
        return true;
      }
    } catch (error) {
      errorLog("Toggle video failed", error);
      throw error;
    }
  }

  public getLocalVideoState(): { enabled: boolean; transmitting: boolean } {
    return {
      enabled: this.videoEnabled,
      transmitting: this.localStream ? this.localStream.getVideoTracks().some((track) => track.enabled && track.readyState === "live") : false,
    };
  }

  private setupRemoteStreamHandlers(session: any): void {
    try {
      const sessionDescriptionHandler = session.sessionDescriptionHandler;
      if (!sessionDescriptionHandler) {
        debugLog(this.config?.debug || false, "No session description handler");
        return;
      }

      const pc = sessionDescriptionHandler.peerConnection;
      if (!pc) {
        debugLog(this.config?.debug || false, "No peer connection");
        return;
      }

      debugLog(this.config?.debug || false, "Setting up remote stream handlers for", pc.connectionState);

      pc.ontrack = (event: RTCTrackEvent) => {
        debugLog(this.config?.debug || false, "Remote track received:", {
          kind: event.track.kind,
          readyState: event.track.readyState,
          enabled: event.track.enabled,
          streams: event.streams.length,
          transceiver: event.transceiver.direction,
        });

        const stream = event.streams[0];
        if (!stream) {
          debugLog(this.config?.debug || false, "No stream in track event");
          return;
        }

        if (event.track.kind === "audio") {
          if (this.remoteAudio) {
            this.remoteAudio.srcObject = stream;
            debugLog(this.config?.debug || false, "Remote audio stream attached");
          }
        } else if (event.track.kind === "video") {
          if (this.remoteVideo) {
            this.remoteVideo.srcObject = stream;
            this.remoteVideo.autoplay = true;
            this.remoteVideo.playsInline = true;

            debugLog(this.config?.debug || false, "Remote video stream attached, playing...");

            // Handle video play with better error handling
            if (this.remoteVideo.srcObject) {
              const playPromise = this.remoteVideo.play();
              if (playPromise !== undefined) {
                playPromise
                  .then(() => {
                    debugLog(this.config?.debug || false, "Remote video playing successfully");
                  })
                  .catch((error) => {
                    debugLog(this.config?.debug || false, "Remote video play failed:", error);
                    
                    // Handle specific error types
                    if (error.name === "NotAllowedError") {
                      debugLog(this.config?.debug || false, "Video play not allowed, likely due to autoplay restrictions");
                      
                      // Try to handle autoplay restrictions by muting and retrying
                      if (this.remoteVideo) {
                        this.remoteVideo.muted = true;
                        const retryPromise = this.remoteVideo.play();
                        if (retryPromise !== undefined) {
                          retryPromise.catch((retryError) => {
                            debugLog(this.config?.debug || false, "Muted video play retry failed:", retryError);
                            
                            // Last resort: re-attach the stream
                            if (this.remoteVideo && this.remoteVideo.srcObject) {
                              const currentStream = this.remoteVideo.srcObject;
                              this.remoteVideo.srcObject = null;
                              this.remoteVideo.srcObject = currentStream;
                              setTimeout(() => {
                                if (this.remoteVideo && this.remoteVideo.srcObject) {
                                  this.remoteVideo.muted = true;
                                  const finalPromise = this.remoteVideo.play();
                                  if (finalPromise !== undefined) {
                                    finalPromise.catch((finalError) => {
                                      debugLog(this.config?.debug || false, "Final video play attempt failed:", finalError);
                                    });
                                  }
                                }
                              }, 100);
                            }
                          });
                        }
                      }
                                      } else if (error.name === "AbortError") {
                    debugLog(this.config?.debug || false, "Video play was interrupted, this is normal during stream updates");
                    
                    // Retry after a short delay, but be more careful about the timing
                    setTimeout(() => {
                      if (this.remoteVideo && this.remoteVideo.srcObject) {
                        // Check if the video element is in a playable state
                        if (this.remoteVideo.readyState >= 2) { // HAVE_CURRENT_DATA
                          const retryPromise = this.remoteVideo.play();
                          if (retryPromise !== undefined) {
                            retryPromise.catch((retryError) => {
                              debugLog(this.config?.debug || false, "Video play retry failed:", retryError);
                            });
                          }
                        } else {
                          // If not ready, wait a bit more
                          setTimeout(() => {
                            if (this.remoteVideo && this.remoteVideo.srcObject) {
                              const retryPromise = this.remoteVideo.play();
                              if (retryPromise !== undefined) {
                                retryPromise.catch((retryError) => {
                                  debugLog(this.config?.debug || false, "Delayed video play retry failed:", retryError);
                                });
                              }
                            }
                          }, 200);
                        }
                      }
                    }, 150);
                    } else {
                      // Try to handle other errors by re-attaching the stream
                      if (this.remoteVideo && this.remoteVideo.srcObject) {
                        const currentStream = this.remoteVideo.srcObject;
                        this.remoteVideo.srcObject = null;
                        this.remoteVideo.srcObject = currentStream;
                        setTimeout(() => {
                          if (this.remoteVideo && this.remoteVideo.srcObject) {
                            const retryPromise = this.remoteVideo.play();
                            if (retryPromise !== undefined) {
                              retryPromise.catch((retryError) => {
                                debugLog(this.config?.debug || false, "Remote video play retry failed:", retryError);
                              });
                            }
                          }
                        }, 100);
                      }
                    }
                  });
              }
            }

            const videoTracks = stream.getVideoTracks();
            const hasActiveVideo = videoTracks.length > 0 && videoTracks.some((track) => track.enabled);

            debugLog(this.config?.debug || false, "Video track details:", {
              trackCount: videoTracks.length,
              hasActive: hasActiveVideo,
              trackStates: videoTracks.map((t) => ({
                id: t.id,
                enabled: t.enabled,
                readyState: t.readyState,
                label: t.label,
              })),
            });

            this.lastVideoState = hasActiveVideo;

            this.dispatchEvent(
              new CustomEvent("remoteVideoChanged", {
                detail: {
                  enabled: true,
                  stream: stream,
                  hasVideoTracks: hasActiveVideo,
                },
              })
            );

            setTimeout(() => {
              this.dispatchEvent(
                new CustomEvent("remoteVideoChanged", {
                  detail: {
                    enabled: true,
                    stream: stream,
                    hasVideoTracks: hasActiveVideo,
                  },
                })
              );
            }, 200);
          }
        }
      };

      pc.oniceconnectionstatechange = () => {
        debugLog(this.config?.debug || false, "ICE connection state changed:", pc.iceConnectionState);

        if (pc.iceConnectionState === "failed") {
          errorLog("ICE connection failed - attempting to recover");
          this.handleIceConnectionFailure(pc);
        }
      };

      pc.onicegatheringstatechange = () => {
        debugLog(this.config?.debug || false, "ICE gathering state changed:", pc.iceGatheringState);
      };

      pc.onicecandidate = (event: RTCPeerConnectionIceEvent) => {
        if (event.candidate) {
          debugLog(this.config?.debug || false, "ICE candidate:", event.candidate.type, event.candidate.candidate);
        } else {
          debugLog(this.config?.debug || false, "ICE gathering complete");
        }
      };

      pc.onconnectionstatechange = () => {
        debugLog(this.config?.debug || false, "Connection state changed:", pc.connectionState);

        if (pc.connectionState === "failed") {
          errorLog("Peer connection failed completely");
          this.handleConnectionFailure();
        } else if (pc.connectionState === "connected") {
          setTimeout(() => {
            const transceivers = pc.getTransceivers();
            debugLog(this.config?.debug || false, "Checking transceivers:", transceivers.length);

            transceivers.forEach((transceiver: RTCRtpTransceiver, index: number) => {
              debugLog(this.config?.debug || false, `Transceiver ${index}:`, {
                direction: transceiver.direction,
                kind: transceiver.receiver?.track?.kind,
                trackState: transceiver.receiver?.track?.readyState,
                hasTrack: !!transceiver.receiver?.track,
              });

              if (transceiver.receiver?.track?.kind === "video" && transceiver.receiver.track.readyState === "live") {
                debugLog(this.config?.debug || false, "Found active video transceiver");

                let videoStream: MediaStream;
                if (this.remoteVideo?.srcObject instanceof MediaStream) {
                  videoStream = this.remoteVideo.srcObject;
                } else {
                  videoStream = new MediaStream([transceiver.receiver.track]);
                  if (this.remoteVideo) {
                    this.remoteVideo.srcObject = videoStream;
                  }
                }

                this.dispatchEvent(
                  new CustomEvent("remoteVideoChanged", {
                    detail: {
                      enabled: true,
                      stream: videoStream,
                      hasVideoTracks: true,
                    },
                  })
                );
              }
            });
          }, 500);
        }
      };

      pc.onremovetrack = (event: RTCTrackEvent) => {
        debugLog(this.config?.debug || false, "Remote track removed:", event.track.kind);

        if (event.track.kind === "video" && this.remoteVideo) {
          this.remoteVideo.srcObject = null;
          this.lastVideoState = false;

          this.dispatchEvent(
            new CustomEvent("remoteVideoChanged", {
              detail: {
                enabled: false,
                stream: null,
                hasVideoTracks: false,
              },
            })
          );
        }
      };
    } catch (error) {
      errorLog("Failed to setup remote stream handlers:", error);
    }
  }

  private handleIceConnectionFailure(pc: RTCPeerConnection): void {
    debugLog(this.config?.debug || false, "Attempting ICE restart");

    setTimeout(() => {
      if (pc.iceConnectionState === "failed") {
        try {
          pc.restartIce();
          debugLog(this.config?.debug || false, "ICE restart initiated");
        } catch (error) {
          errorLog("ICE restart failed:", error);
        }
      }
    }, 1000);
  }

  private handleConnectionFailure(): void {
    errorLog("Connection failed - notifying UI");

    this.dispatchEvent(
      new CustomEvent("error", {
        detail: {
          error: "Connection failed - check network and STUN servers",
          type: "connection_failure",
        },
      })
    );
  }

  private async waitForSipLibrary(timeout = 15000): Promise<void> {
    return new Promise<void>(async (resolve, reject) => {
      const startTime = Date.now();
      const timeoutId = setTimeout(() => {
        reject(new Error(`SIP.js library loading timeout after ${timeout}ms`));
      }, timeout);

      const checkLibrary = async () => {
        try {
          if (!Web) {
            const SIP = await import("sip.js");
            Web = (SIP as any).Web || SIP;
          }

          const isFullyLoaded =
            Web &&
            Web.SimpleUser &&
            Web.SimpleUser.prototype &&
            typeof Web.SimpleUser.prototype.register === "function" &&
            typeof Web.SimpleUser.prototype.connect === "function" &&
            typeof Web.SimpleUser.prototype.disconnect === "function";

          if (isFullyLoaded) {
            clearTimeout(timeoutId);
            debugLog(this.config?.debug || false, "SIP.js library fully loaded and verified");
            resolve();
            return;
          }

          if (Date.now() - startTime > timeout) {
            clearTimeout(timeoutId);
            reject(new Error("SIP.js library verification timeout"));
            return;
          }

          setTimeout(checkLibrary, 100);
        } catch (error) {
          setTimeout(checkLibrary, 200);
        }
      };

      checkLibrary();
    });
  }

  private async ensureSipClient(): Promise<void> {
    if (this.isInitialized) return;

    if (this.isInitializing) {
      return new Promise((resolve, reject) => {
        const checkInterval = setInterval(() => {
          if (this.isInitialized) {
            clearInterval(checkInterval);
            resolve();
          } else if (!this.isInitializing) {
            clearInterval(checkInterval);
            reject(new Error("Initialization failed"));
          }
        }, 100);
      });
    }

    if (!this.config) {
      throw new Error("SIP configuration not set");
    }

    await this.initialize(this.config);
  }

  setConfig(config: SipConfig): void {
    this.config = config;
    debugLog(config.debug || false, "SIP configuration set, will initialize on first use");
  }

  async initialize(config: SipConfig): Promise<void> {
    if (this.isInitializing || this.isInitialized) return;

    this.isInitializing = true;
    this.config = config;

    debugLog(config.debug || false, "Starting lazy SIP initialization");

    try {
      await this.waitForSipLibrary();
      await new Promise((resolve) => setTimeout(resolve, 500));

      const wsProtocol = config.use_secure ? "wss" : "ws";
      const wsPort = config.websocket_port || (config.use_secure ? 443 : 80);
      const wsServer = `${wsProtocol}://${config.server}:${wsPort}`;
      const sipAor = `sip:${config.username}@${config.domain}`;

      debugLog(config.debug || false, "WebSocket URL:", wsServer);
      debugLog(config.debug || false, "SIP AOR:", sipAor);

      const getMediaOptions = (includeVideo: boolean = false) => ({
        constraints: includeVideo
          ? {
              audio: {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true,
              },
              video: {
                width: { ideal: 640 },
                height: { ideal: 480 },
                frameRate: { ideal: 30 },
              },
            }
          : {
              audio: {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true,
              },
              video: false,
            },
        remote: {
          audio: this.remoteAudio!,
          video: this.remoteVideo!,
        },
      });

      const options: SimpleUserOptions = {
        aor: sipAor,
        media: getMediaOptions(false),
        userAgentOptions: {
          authorizationUsername: config.username,
          authorizationPassword: config.password,
          displayName: config.display_name || config.username,
          transportOptions: {
            server: wsServer,
            connectionTimeout: 15,
            maxReconnectionAttempts: 3,
            reconnectionTimeout: 4,
          },
          logLevel: config.debug ? "debug" : "error",
          sessionDescriptionHandlerFactoryOptions: {
            constraints: {
              audio: true,
              video: false,
            },
            peerConnectionConfiguration: {
              iceServers: [
                { urls: "stun:stun.l.google.com:19302" },
                { urls: "stun:stun1.l.google.com:19302" },
                { urls: "stun:stun2.l.google.com:19302" },
                { urls: "stun:stun3.l.google.com:19302" },
              ],
              iceCandidatePoolSize: 10,
              iceTransportPolicy: "all",
              bundlePolicy: "balanced",
              rtcpMuxPolicy: "require",
            },
          },
        },
      };

      if (!Web || !Web.SimpleUser) {
        throw new Error("SIP.js Web.SimpleUser not available after loading");
      }

      this.simpleUser = new Web.SimpleUser(wsServer, options);

      if (!this.simpleUser) {
        throw new Error("Failed to create SimpleUser instance");
      }

      if (!this.simpleUser.register || typeof this.simpleUser.register !== "function") {
        throw new Error("SimpleUser register method not available - library incomplete");
      }

      debugLog(config.debug || false, "SimpleUser created and verified successfully");

      this.setupEventHandlers();

      debugLog(config.debug || false, `Connecting to: ${wsServer}`);
      await this.simpleUser.connect();

      this.isConnected = true;
      this.dispatchEvent(new CustomEvent("connected"));
      debugLog(config.debug || false, "Connected to WebSocket server");

      debugLog(config.debug || false, "Registering with SIP server...");
      await this.simpleUser.register();

      this.isRegistered = true;
      this.dispatchEvent(new CustomEvent("registered", { detail: { registered: true } }));

      this.startConnectionMonitoring();

      this.isInitialized = true;
      this.isInitializing = false;

      debugLog(config.debug || false, "SIP client lazy initialization completed successfully");
    } catch (error) {
      this.isInitializing = false;
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      errorLog("SIP lazy initialization failed:", errorMessage);

      this.isConnected = false;
      this.isRegistered = false;

      if (this.simpleUser) {
        try {
          await this.simpleUser.disconnect();
        } catch (cleanupError) {
          debugLog(config.debug || false, "Cleanup error", cleanupError);
        }
        this.simpleUser = null;
      }

      this.dispatchEvent(
        new CustomEvent("error", {
          detail: {
            error: errorMessage,
            type: "initialization",
          },
        })
      );

      throw new Error(`Failed to initialize SIP client: ${errorMessage}`);
    }
  }

  private setupEventHandlers(): void {
    if (!this.simpleUser) {
      errorLog("Cannot setup event handlers: SimpleUser is null");
      return;
    }

    debugLog(this.config?.debug || false, "Setting up event handlers");

    this.simpleUser.delegate = {
      onCallCreated: () => {
        debugLog(this.config?.debug || false, "Call created");
        this.dispatchEvent(new CustomEvent("callCreated"));
      },

      onCallReceived: () => {
        debugLog(this.config?.debug || false, "Incoming call received");

        const session = this.simpleUser?.session;
        if (!session) {
          debugLog(this.config?.debug || false, "No session found for incoming call");
          return;
        }

        let remoteIdentity = "unknown";
        let displayName = "Unknown Caller";

        try {
          debugLog(this.config?.debug || false, "Current session state:", session.state);

          this.setupRemoteStreamHandlers(session);

          if (session.request) {
            const fromHeader = session.request.getHeader("From");
            debugLog(this.config?.debug || false, "From header:", fromHeader);

            if (fromHeader) {
              const uriMatches = fromHeader.match(/<sip:([^@]+)@/) || fromHeader.match(/sip:([^@]+)@/);
              if (uriMatches && uriMatches[1]) {
                remoteIdentity = uriMatches[1];
                debugLog(this.config?.debug || false, "Extracted extension from From:", remoteIdentity);
              }

              const nameMatches = fromHeader.match(/^"([^"]*)"/) || fromHeader.match(/^([^<]*)</);
              if (nameMatches && nameMatches[1] && nameMatches[1].trim()) {
                displayName = nameMatches[1].trim();
                debugLog(this.config?.debug || false, "Extracted display name:", displayName);
              } else if (remoteIdentity !== "unknown") {
                displayName = remoteIdentity;
              }
            }
          }

          if (remoteIdentity === "unknown" && session.remoteIdentity) {
            debugLog(this.config?.debug || false, "Trying session.remoteIdentity:", session.remoteIdentity);

            if (session.remoteIdentity.uri) {
              const uriString = session.remoteIdentity.uri.toString();
              debugLog(this.config?.debug || false, "Remote URI:", uriString);

              const matches = uriString.match(/sip:([^@]+)@/);
              if (matches && matches[1]) {
                remoteIdentity = matches[1];
                debugLog(this.config?.debug || false, "Extracted from remote URI:", remoteIdentity);
              }
            }

            if (session.remoteIdentity.displayName) {
              displayName = session.remoteIdentity.displayName;
              debugLog(this.config?.debug || false, "Remote display name:", displayName);
            } else if (remoteIdentity !== "unknown") {
              displayName = remoteIdentity;
            }
          }
        } catch (error) {
          debugLog(this.config?.debug || false, "Error parsing caller info:", error);
        }

        debugLog(this.config?.debug || false, "Final parsed caller info:", { remoteIdentity, displayName });

        this.currentCall = {
          id: Date.now().toString(),
          remoteIdentity: remoteIdentity,
          displayName: displayName,
          state: "incoming",
          duration: 0,
        };

        this.dispatchEvent(
          new CustomEvent("incomingCall", {
            detail: {
              from: remoteIdentity,
              displayName: displayName,
              callInfo: this.currentCall,
            },
          })
        );
      },

      onCallAnswered: () => {
        if (this.currentCall) {
          this.currentCall.state = "connected";
          this.currentCall.startTime = new Date();
        }

        debugLog(this.config?.debug || false, "Call answered");

        if (this.simpleUser?.session) {
          this.setupRemoteStreamHandlers(this.simpleUser.session);

          // FIXED: Force remote video check for outgoing calls after answer
          setTimeout(() => {
            this.forceRemoteVideoCheck(this.simpleUser.session);
          }, 500);
        }

        this.dispatchEvent(
          new CustomEvent("callAnswered", {
            detail: { callInfo: this.currentCall },
          })
        );

        this.startCallTimer();
      },

      onCallHangup: () => {
        debugLog(this.config?.debug || false, "Call ended");

        // Stop local media tracks to release camera and microphone
        if (this.localStream) {
          this.localStream.getTracks().forEach((track) => {
            try {
              track.stop();
              debugLog(this.config?.debug || false, `Stopped local media track: ${track.kind}`);
            } catch (error) {
              debugLog(this.config?.debug || false, `Failed to stop track: ${track.kind}`, error);
            }
          });
          this.localStream = null;
        }

        if (this.remoteVideo) {
          this.remoteVideo.srcObject = null;
        }

        if (this.currentCall) {
          this.currentCall.state = "ended";
        }

        this.stopCallTimer();
        this.dispatchEvent(
          new CustomEvent("callEnded", {
            detail: { callInfo: this.currentCall },
          })
        );

        this.currentCall = null;
        this.lastVideoState = false;
        this.videoEnabled = false;
      },

      onCallHold: (held: boolean) => {
        debugLog(this.config?.debug || false, "Call hold state changed", held);
        this.dispatchEvent(
          new CustomEvent("callHold", {
            detail: { held, callInfo: this.currentCall },
          })
        );
      },

      onRegistered: () => {
        this.isRegistered = true;
        debugLog(this.config?.debug || false, "Registration successful");
        this.dispatchEvent(new CustomEvent("registered", { detail: { registered: true } }));
      },

      onUnregistered: () => {
        this.isRegistered = false;
        debugLog(this.config?.debug || false, "Unregistered");
        this.dispatchEvent(new CustomEvent("registered", { detail: { registered: false } }));
      },

      onServerConnect: () => {
        this.isConnected = true;
        debugLog(this.config?.debug || false, "Server connected");
        this.dispatchEvent(new CustomEvent("connected"));
      },

      onServerDisconnect: () => {
        this.isConnected = false;
        this.isRegistered = false;
        debugLog(this.config?.debug || false, "Server disconnected");
        this.dispatchEvent(new CustomEvent("disconnected"));
      },
    };
  }

  private callTimer: number | null = null;

  private startCallTimer(): void {
    this.stopCallTimer();
    this.callTimer = window.setInterval(() => {
      if (this.currentCall && this.currentCall.startTime) {
        this.currentCall.duration = Math.floor((Date.now() - this.currentCall.startTime.getTime()) / 1000);
        this.dispatchEvent(
          new CustomEvent("callTimer", {
            detail: { duration: this.currentCall.duration, callInfo: this.currentCall },
          })
        );
      }
    }, 1000);
  }

  private stopCallTimer(): void {
    if (this.callTimer) {
      clearInterval(this.callTimer);
      this.callTimer = null;
    }
  }

  private startConnectionMonitoring(): void {
    this.connectionTimer = window.setInterval(() => {
      const connected = this.simpleUser?.isConnected() || false;

      if (connected !== this.isConnected) {
        this.isConnected = connected;
        this.dispatchEvent(
          new CustomEvent("heartbeat", {
            detail: {
              connected,
              registered: this.isRegistered,
            },
          })
        );
      }
    }, 5000);
  }

  async makeCall(target: string, includeVideo = true): Promise<void> {
    await this.ensureSipClient();

    if (!this.simpleUser || !this.isRegistered) {
      throw new Error("SIP client not registered");
    }

    if (this.currentCall) {
      throw new Error("Another call is already in progress");
    }

    try {
      const targetUri = `sip:${target}@${this.config!.domain}`;
      debugLog(this.config?.debug || false, "Making VIDEO call to", targetUri, "with video:", includeVideo);

      if (!this.videoEnabled) {
        await this.enableVideo();
      }
      const mediaStream = this.localStream!;

      this.currentCall = {
        id: Date.now().toString(),
        remoteIdentity: target,
        displayName: target,
        state: "outgoing",
        duration: 0,
      };

      const callOptions = {
        sessionDescriptionHandlerOptions: {
          constraints: {
            audio: true,
            video: true,
          },
          offerToReceiveAudio: true,
          offerToReceiveVideo: true,

          iceGatheringTimeout: 10000,
          rtcConfiguration: {
            iceServers: [
              { urls: "stun:stun.l.google.com:19302" },
              { urls: "stun:stun1.l.google.com:19302" },
              { urls: "stun:stun2.l.google.com:19302" },
              { urls: "stun:stun3.l.google.com:19302" },
            ],
            iceCandidatePoolSize: 10,
            iceTransportPolicy: "all",
            bundlePolicy: "balanced",
            rtcpMuxPolicy: "require",
          },
        },
        sessionDescriptionHandlerFactory: (session: any, options: any) => {
          options.localStream = mediaStream;
          options.remote = {
            audio: this.remoteAudio,
            video: this.remoteVideo,
          };

          return session.sessionDescriptionHandlerFactory(session, options);
        },
      };

      await this.simpleUser.call(targetUri, callOptions);

      // FIXED: Enhanced outgoing call session handling
      if (this.simpleUser.session) {
        const session = this.simpleUser.session;
        debugLog(this.config?.debug || false, "Outgoing call session created, state:", session.state);

        // FIXED: Set up handlers immediately for outgoing calls
        this.setupRemoteStreamHandlers(session);

        // FIXED: Listen for all session state changes
        session.stateChange.addListener((newState: any) => {
          debugLog(this.config?.debug || false, "Outgoing session state changed:", newState);

          switch (newState) {
            case "Establishing":
              debugLog(this.config?.debug || false, "Call is establishing, setting up stream handlers");
              this.setupRemoteStreamHandlers(session);
              break;

            case "Established":
              debugLog(this.config?.debug || false, "Call established, ensuring stream handlers");
              setTimeout(() => {
                this.setupRemoteStreamHandlers(session);
                this.forceRemoteVideoCheck(session);
              }, 100);
              break;

            case "Terminated":
            case "Ended":
              debugLog(this.config?.debug || false, "Outgoing call ended");
              if (this.currentCall) {
                this.currentCall.state = "ended";
                this.dispatchEvent(
                  new CustomEvent("callEnded", {
                    detail: { callInfo: this.currentCall },
                  })
                );
              }
              break;
          }
        });

        // FIXED: Also listen for session description handler changes
        const checkForSDH = () => {
          if (session.sessionDescriptionHandler) {
            debugLog(this.config?.debug || false, "Session description handler available for outgoing call");
            this.setupRemoteStreamHandlers(session);
          } else {
            setTimeout(checkForSDH, 100);
          }
        };
        checkForSDH();
      }

      this.dispatchEvent(
        new CustomEvent("callStarted", {
          detail: {
            target,
            callInfo: this.currentCall,
            videoEnabled: true,
          },
        })
      );
    } catch (error) {
      errorLog("Call failed", error);
      
      // Stop local media tracks to release camera and microphone
      if (this.localStream) {
        this.localStream.getTracks().forEach((track) => {
          try {
            track.stop();
            debugLog(this.config?.debug || false, `Stopped local media track on call failure: ${track.kind}`);
          } catch (trackError) {
            debugLog(this.config?.debug || false, `Failed to stop track on call failure: ${track.kind}`, trackError);
          }
        });
        this.localStream = null;
      }
      
      this.currentCall = null;
      this.dispatchEvent(
        new CustomEvent("callFailed", {
          detail: {
            error: error instanceof Error ? error.message : "Call failed",
            target,
          },
        })
      );
      throw error;
    }
  }

  private forceRemoteVideoCheck(session: any): void {
    try {
      if (!session || !session.sessionDescriptionHandler) {
        debugLog(this.config?.debug || false, "No session description handler for video check");
        return;
      }

      const pc = session.sessionDescriptionHandler.peerConnection;
      if (!pc) {
        debugLog(this.config?.debug || false, "No peer connection for video check");
        return;
      }

      debugLog(this.config?.debug || false, "Forcing remote video check, connection state:", pc.connectionState);

      // Check for remote streams
      const remoteStreams = pc.getRemoteStreams ? pc.getRemoteStreams() : [];
      debugLog(this.config?.debug || false, "Remote streams found:", remoteStreams.length);

      if (remoteStreams.length > 0) {
        const remoteStream = remoteStreams[0];
        const videoTracks = remoteStream.getVideoTracks();

        debugLog(this.config?.debug || false, "Found remote stream with video tracks:", videoTracks.length);

        if (videoTracks.length > 0 && this.remoteVideo) {
          this.remoteVideo.srcObject = remoteStream;
          this.remoteVideo.autoplay = true;
          this.remoteVideo.playsInline = true;

          const playPromise = this.remoteVideo.play();
          if (playPromise !== undefined) {
            playPromise.catch((error) => {
              debugLog(this.config?.debug || false, "Remote video play failed:", error);
              // Try to handle the error by re-attaching the stream
              if (this.remoteVideo && this.remoteVideo.srcObject) {
                const currentStream = this.remoteVideo.srcObject;
                this.remoteVideo.srcObject = null;
                this.remoteVideo.srcObject = currentStream;
                setTimeout(() => {
                  if (this.remoteVideo && this.remoteVideo.srcObject) {
                    const retryPromise = this.remoteVideo.play();
                    if (retryPromise !== undefined) {
                      retryPromise.catch((retryError) => {
                        debugLog(this.config?.debug || false, "Remote video play retry failed:", retryError);
                      });
                    }
                  }
                }, 100);
              }
            });
          }

          const hasActiveVideo = videoTracks.some((track: any) => track.enabled && track.readyState === "live");

          this.dispatchEvent(
            new CustomEvent("remoteVideoChanged", {
              detail: {
                enabled: true,
                stream: remoteStream,
                hasVideoTracks: hasActiveVideo,
              },
            })
          );
        }
      }

      // Also check transceivers
      const transceivers = pc.getTransceivers();
      debugLog(this.config?.debug || false, "Checking transceivers for outgoing call:", transceivers.length);

      transceivers.forEach((transceiver: RTCRtpTransceiver, index: number) => {
        if (transceiver.receiver?.track?.kind === "video" && transceiver.receiver.track.readyState === "live") {
          debugLog(this.config?.debug || false, `Found active video transceiver ${index} for outgoing call`);

          if (this.remoteVideo && !this.remoteVideo.srcObject) {
            const videoStream = new MediaStream([transceiver.receiver.track]);
            this.remoteVideo.srcObject = videoStream;
            this.remoteVideo.autoplay = true;
            this.remoteVideo.playsInline = true;

            // Handle video play with better error handling
            if (this.remoteVideo.srcObject) {
              const playPromise = this.remoteVideo.play();
              if (playPromise !== undefined) {
                playPromise
                  .then(() => {
                    debugLog(this.config?.debug || false, "Transceiver video playing successfully");
                  })
                  .catch((error) => {
                    debugLog(this.config?.debug || false, "Transceiver video play failed:", error);
                    // Try to handle the error by re-attaching the stream
                    if (this.remoteVideo && this.remoteVideo.srcObject) {
                      const currentStream = this.remoteVideo.srcObject;
                      this.remoteVideo.srcObject = null;
                      this.remoteVideo.srcObject = currentStream;
                      // Add a small delay before retrying to avoid race conditions
                      setTimeout(() => {
                        if (this.remoteVideo && this.remoteVideo.srcObject) {
                          // Check if the video element is in a playable state
                          if (this.remoteVideo.readyState >= 2) { // HAVE_CURRENT_DATA
                            const retryPromise = this.remoteVideo.play();
                            if (retryPromise !== undefined) {
                              retryPromise.catch((retryError) => {
                                debugLog(this.config?.debug || false, "Transceiver video play retry failed:", retryError);
                              });
                            }
                          } else {
                            // If not ready, wait a bit more
                            setTimeout(() => {
                              if (this.remoteVideo && this.remoteVideo.srcObject) {
                                const retryPromise = this.remoteVideo.play();
                                if (retryPromise !== undefined) {
                                  retryPromise.catch((retryError) => {
                                    debugLog(this.config?.debug || false, "Delayed transceiver video play retry failed:", retryError);
                                  });
                                }
                              }
                            }, 200);
                          }
                        }
                      }, 150);
                    }
                  });
              }
            }

            this.dispatchEvent(
              new CustomEvent("remoteVideoChanged", {
                detail: {
                  enabled: true,
                  stream: videoStream,
                  hasVideoTracks: true,
                },
              })
            );
          }
        }
      });
    } catch (error) {
      debugLog(this.config?.debug || false, "Force remote video check failed:", error);
    }
  }

  async answerCall(): Promise<void> {
    await this.ensureSipClient();

    if (!this.simpleUser) {
      throw new Error("SIP client not available");
    }

    const session = this.simpleUser.session;
    if (!session) {
      throw new Error("No session available to answer");
    }

    if (!this.currentCall || this.currentCall.state !== "incoming") {
      throw new Error("No incoming call to answer");
    }

    const sessionState = session.state;
    debugLog(this.config?.debug || false, "Attempting to answer call, session state:", sessionState);

    if (sessionState === "Terminated" || sessionState === "Ended") {
      throw new Error("Call has already ended");
    }

    if (sessionState !== "Initial") {
      throw new Error(`Cannot answer call in state: ${sessionState}`);
    }

    try {
      if (!this.videoEnabled) {
        await this.enableVideo();
      }
      const mediaStream = this.localStream!;

      const answerOptions = {
        sessionDescriptionHandlerOptions: {
          constraints: {
            audio: true,
            video: true,
          },
          rtcConfiguration: {
            iceServers: [
              { urls: "stun:stun.l.google.com:19302" },
              { urls: "stun:stun1.l.google.com:19302" },
              { urls: "stun:stun2.l.google.com:19302" },
              { urls: "stun:stun3.l.google.com:19302" },
            ],
            iceCandidatePoolSize: 10,
            iceTransportPolicy: "all",
            bundlePolicy: "balanced",
            rtcpMuxPolicy: "require",
          },
        },
        sessionDescriptionHandlerFactory: (session: any, options: any) => {
          options.localStream = mediaStream;
          return session.sessionDescriptionHandlerFactory(session, options);
        },
      };

      await this.simpleUser.answer(answerOptions);
      debugLog(this.config?.debug || false, "Call answered with video:", this.videoEnabled);

      if (this.simpleUser.session) {
        this.setupRemoteStreamHandlers(this.simpleUser.session);
      }
    } catch (error) {
      errorLog("Answer call failed", error);
      throw error;
    }
  }

  async rejectCall(): Promise<void> {
    await this.ensureSipClient();

    if (!this.simpleUser) {
      throw new Error("SIP client not available");
    }

    try {
      await this.simpleUser.decline();

      if (this.currentCall) {
        this.currentCall.state = "ended";
      }

      this.currentCall = null;
      debugLog(this.config?.debug || false, "Call rejected");
    } catch (error) {
      errorLog("Reject call failed", error);
      throw error;
    }
  }

  async hangup(): Promise<void> {
    if (!this.simpleUser) return;

    try {
      await this.simpleUser.hangup();
      debugLog(this.config?.debug || false, "Call hung up");
    } catch (error) {
      errorLog("Hangup failed", error);
      throw error;
    }
  }

  async mute(): Promise<void> {
    if (!this.simpleUser) return;

    try {
      await this.simpleUser.mute();
      debugLog(this.config?.debug || false, "Call muted");
    } catch (error) {
      errorLog("Mute failed", error);
      throw error;
    }
  }

  async unmute(): Promise<void> {
    if (!this.simpleUser) return;

    try {
      await this.simpleUser.unmute();
      debugLog(this.config?.debug || false, "Call unmuted");
    } catch (error) {
      errorLog("Unmute failed", error);
      throw error;
    }
  }

  sendDTMF(tone: string): void {
    if (!this.simpleUser || !this.currentCall) return;

    try {
      if (typeof this.simpleUser.sendDTMF === "function") {
        this.simpleUser.sendDTMF(tone);
        debugLog(this.config?.debug || false, "DTMF sent", tone);

        this.dispatchEvent(
          new CustomEvent("dtmfSent", {
            detail: { tone, callInfo: this.currentCall },
          })
        );
      }
    } catch (error) {
      errorLog("DTMF send failed", error);
    }
  }

  getRemoteVideo(): HTMLVideoElement | null {
    return this.remoteVideo;
  }

  getRemoteAudio(): HTMLAudioElement | null {
    return this.remoteAudio;
  }

  getCurrentCall(): CallInfo | null {
    return this.currentCall;
  }

  getConnectionStatus(): { connected: boolean; registered: boolean; initialized: boolean } {
    return {
      connected: this.isConnected,
      registered: this.isRegistered,
      initialized: this.isInitialized,
    };
  }

  async connect(): Promise<void> {
    await this.ensureSipClient();
  }

  async disconnect(): Promise<void> {
    if (this.connectionTimer) {
      clearInterval(this.connectionTimer);
      this.connectionTimer = null;
    }

    this.stopCallTimer();

    if (this.simpleUser) {
      try {
        if (this.currentCall) {
          await this.hangup();
        }

        if (this.isRegistered) {
          await this.simpleUser.unregister();
        }

        if (this.isConnected) {
          await this.simpleUser.disconnect();
        }
      } catch (error) {
        errorLog("Disconnect error", error);
      }

      this.simpleUser = null;
    }

    try {
      if (this.localStream) {
        this.localStream.getTracks().forEach((track) => track.stop());
        this.localStream = null;
      }

      if (this.localVideo && this.localVideo.parentNode) {
        this.localVideo.pause();
        this.localVideo.srcObject = null;
        this.localVideo.parentNode.removeChild(this.localVideo);
        this.localVideo = null;
      }

      if (this.remoteVideo && this.remoteVideo.parentNode) {
        this.remoteVideo.pause();
        this.remoteVideo.srcObject = null;
        this.remoteVideo.parentNode.removeChild(this.remoteVideo);
        this.remoteVideo = null;
      }

      this.videoEnabled = false;

      if (this.remoteAudio && this.remoteAudio.parentNode) {
        this.remoteAudio.pause();
        this.remoteAudio.srcObject = null;
        this.remoteAudio.parentNode.removeChild(this.remoteAudio);
        this.remoteAudio = null;
      }
    } catch (error) {
      errorLog("Error cleaning up media resources:", error);
    }

    this.isConnected = false;
    this.isRegistered = false;
    this.isInitialized = false;
    this.isInitializing = false;
    this.currentCall = null;

    debugLog(this.config?.debug || false, "SIP client disconnected");
  }
}

---

=== Object: 9aed54c35b12f5e8cec1ea5f3d26d406163b172b | Date: 2025-09-23 15:23:51 | Type: blob ===

import type { CallInfo } from "./sip-manager";
import { SipManager } from "./sip-manager";
import { formatDuration, playRingtone, stopRingtone, getContactByExtension } from "./utils";
import type { SIPContact } from "./types";

export interface CallState {
  active: boolean;
  incoming: boolean;
  outgoing: boolean;
  onHold: boolean;
  muted: boolean;
  remoteVideoEnabled: boolean;
  localVideoTransmitting: boolean;
  callerId?: string;
  callerName?: string;
  duration: number;
  status: "idle" | "connecting" | "ringing" | "answered" | "held" | "ended" | "error";
}

export class CallManager extends EventTarget {
  private sipManager: SipManager;
  private callState: CallState;
  private ringtone: HTMLAudioElement | null = null;
  private ringTimeout: number | null = null;
  private contacts: SIPContact[] = [];

  constructor(sipManager: SipManager, contacts: SIPContact[] = []) {
    super();
    this.sipManager = sipManager;
    this.contacts = contacts;
    this.callState = this.getInitialState();
    this.setupSipEventHandlers();
  }

  public updateContacts(contacts: SIPContact[]): void {
    this.contacts = contacts;
  }

  private getInitialState(): CallState {
    return {
      active: false,
      incoming: false,
      outgoing: false,
      onHold: false,
      muted: false,
      remoteVideoEnabled: false,
      localVideoTransmitting: false,
      duration: 0,
      status: "idle",
    };
  }

  private setupSipEventHandlers(): void {
    this.sipManager.addEventListener("incomingCall", this.handleIncomingCall.bind(this) as EventListener);
    this.sipManager.addEventListener("callStarted", this.handleCallStarted.bind(this) as EventListener);
    this.sipManager.addEventListener("callAnswered", this.handleCallAnswered.bind(this) as EventListener);
    this.sipManager.addEventListener("callEnded", this.handleCallEnded.bind(this) as EventListener);
    this.sipManager.addEventListener("callFailed", this.handleCallFailed.bind(this) as EventListener);
    this.sipManager.addEventListener("localVideoChanged", this.handleLocalVideoChanged.bind(this) as EventListener);
    this.sipManager.addEventListener("remoteVideoChanged", this.handleRemoteVideoChanged.bind(this) as EventListener);
    this.sipManager.addEventListener("callTimer", this.handleCallTimer.bind(this) as EventListener);
    this.sipManager.addEventListener("callHold", this.handleCallHold.bind(this) as EventListener);
  }

  private cleanExtension(rawExtension: string): string {
    if (!rawExtension || rawExtension === "unknown") return rawExtension;

    let cleaned = rawExtension.replace(/^Extension\s+/i, "");
    cleaned = cleaned.replace(/-screen$|-web$|-mobile$|-phone$/i, "");

    const numericMatch = cleaned.match(/(\d+)/);
    if (numericMatch) {
      return numericMatch[1];
    }

    return cleaned;
  }

  private cleanDisplayName(displayName: string, extension: string): string {
    if (!displayName || displayName === "unknown" || displayName === "Unknown Caller") {
      return extension;
    }

    let cleaned = displayName.replace(/^Extension\s+/i, "");
    cleaned = cleaned.replace(new RegExp(`\\b${extension}\\b`, "g"), "").trim();

    if (!cleaned || cleaned === extension) {
      return extension;
    }

    return cleaned;
  }

  private handleIncomingCall(event: CustomEvent): void {
    const { from, displayName, callInfo } = event.detail;

    const cleanedExtension = this.cleanExtension(from);
    const cleanedDisplayName = this.cleanDisplayName(displayName, cleanedExtension);
    const contact = this.contacts ? getContactByExtension(this.contacts, cleanedExtension) : null;
    const finalCallerName = contact ? contact.name : cleanedDisplayName;

    this.callState = {
      ...this.callState,
      active: true,
      incoming: true,
      outgoing: false,
      callerId: cleanedExtension,
      callerName: finalCallerName,
      status: "ringing",
      duration: 0,
    };

    this.ringtone = playRingtone();

    this.ringTimeout = window.setTimeout(() => {
      if (this.callState.status === "ringing" && this.callState.incoming) {
        this.rejectCall().catch((error) => {
          console.error("Auto-reject failed:", error);
          this.forceCallCleanup();
        });
      }
    }, 30000);

    this.dispatchCallStateUpdate();
  }

  private forceCallCleanup(): void {
    this.stopRinging();
    this.clearRingTimeout();

    // Ensure media tracks are stopped when force cleaning up
    try {
      // The SIP manager should handle this, but we'll make sure
      console.log("Force call cleanup, ensuring media tracks are stopped");
    } catch (error) {
      console.error("Error during force call cleanup:", error);
    }

    this.callState = this.getInitialState();
    this.callState.status = "ended";

    this.dispatchCallStateUpdate();

    setTimeout(() => {
      this.callState.status = "idle";
      this.dispatchCallStateUpdate();
    }, 1000);
  }

  private handleCallStarted(event: CustomEvent): void {
    const { target } = event.detail;

    const cleanedExtension = this.cleanExtension(target);
    const contact = this.contacts ? getContactByExtension(this.contacts, cleanedExtension) : null;
    const finalCallerName = contact ? contact.name : cleanedExtension;

    this.callState = {
      ...this.callState,
      active: true,
      incoming: false,
      outgoing: true,
      callerId: cleanedExtension,
      callerName: finalCallerName,
      status: "connecting",
      duration: 0,
    };

    this.dispatchCallStateUpdate();
  }

  private handleCallAnswered(_event: CustomEvent): void {
    this.stopRinging();
    this.clearRingTimeout();

    this.callState = {
      ...this.callState,
      status: "answered",
      incoming: false,
      outgoing: false,
      duration: 0,
    };

    // FIXED: Update local video state immediately
    const videoState = this.sipManager.getLocalVideoState();
    this.callState.localVideoTransmitting = videoState.transmitting;

    // Check if remote video is available
    setTimeout(() => {
      const remoteVideo = this.sipManager.getRemoteVideo();
      if (remoteVideo && remoteVideo.srcObject) {
        const stream = remoteVideo.srcObject as MediaStream;
        const videoTracks = stream.getVideoTracks();
        this.callState.remoteVideoEnabled = videoTracks.length > 0 && videoTracks.some((track) => track.enabled);
        console.log("Remote video detected in call answered:", {
          videoTracks: videoTracks.length,
          enabled: this.callState.remoteVideoEnabled,
        });
        this.dispatchCallStateUpdate();
      }
    }, 500);

    this.dispatchCallStateUpdate();
  }

  private handleCallEnded(_event: CustomEvent): void {
    this.stopRinging();
    this.clearRingTimeout();

    this.callState = this.getInitialState();
    this.callState.status = "ended";

    this.dispatchCallStateUpdate();

    setTimeout(() => {
      this.callState.status = "idle";
      this.dispatchCallStateUpdate();
    }, 2000);
  }

  private handleCallFailed(_event: CustomEvent): void {
    this.stopRinging();
    this.clearRingTimeout();

    // Ensure media tracks are stopped
    try {
      // The SIP manager should handle this, but we'll make sure
      console.log("Call failed, ensuring media tracks are stopped");
    } catch (error) {
      console.error("Error during call failure cleanup:", error);
    }

    this.callState = this.getInitialState();
    this.callState.status = "error";

    this.dispatchCallStateUpdate();
  }

  private handleCallTimer(_event: CustomEvent): void {
    // This method is intentionally left empty as the timer is handled by the SIP manager
  }

  private handleCallHold(event: CustomEvent): void {
    const { held } = event.detail;
    this.callState.onHold = held;
    this.callState.status = held ? "held" : "answered";
    this.dispatchCallStateUpdate();
  }

  private handleLocalVideoChanged(event: CustomEvent): void {
    const { transmitting } = event.detail;
    this.callState.localVideoTransmitting = transmitting;
    this.dispatchCallStateUpdate();
  }

  private handleRemoteVideoChanged(event: CustomEvent): void {
    const { enabled } = event.detail;
    this.callState.remoteVideoEnabled = enabled;
    this.dispatchCallStateUpdate();
  }

  public async toggleVideo(): Promise<boolean> {
    try {
      const enabled = await this.sipManager.toggleVideo();
      return enabled;
    } catch (error) {
      console.error("Failed to toggle video:", error);
      throw error;
    }
  }

  public async enableVideo(): Promise<void> {
    try {
      await this.sipManager.enableVideo();
      console.log("Video enabled successfully");
    } catch (error) {
      console.error("Failed to enable video:", error);
      throw error;
    }
  }

  public async disableVideo(): Promise<void> {
    try {
      await this.sipManager.disableVideo();
    } catch (error) {
      console.error("Failed to disable video:", error);
      throw error;
    }
  }

  private stopRinging(): void {
    if (this.ringtone) {
      stopRingtone(this.ringtone);
      this.ringtone = null;
    }
  }

  private clearRingTimeout(): void {
    if (this.ringTimeout) {
      clearTimeout(this.ringTimeout);
      this.ringTimeout = null;
    }
  }

  private dispatchCallStateUpdate(): void {
    this.dispatchEvent(
      new CustomEvent("callStateChanged", {
        detail: { callState: { ...this.callState } },
      })
    );
  }

  async makeCall(target: string, includeVideo?: boolean): Promise<void> {
    try {
      await this.sipManager.makeCall(target, includeVideo);
    } catch (error) {
      this.callState.status = "error";
      this.dispatchCallStateUpdate();
      throw error;
    }
  }

  // FIXED: Enhanced answerCall to properly handle video
  async answerCall(withVideo = false): Promise<void> {
    try {
      if (withVideo) {
        console.log("Answering with video - enabling video first");
        await this.sipManager.enableVideo();
      }

      await this.sipManager.answerCall();
      console.log(`Call answered ${withVideo ? "with" : "without"} video`);
    } catch (error) {
      console.error("Failed to answer call:", error);
      this.callState.status = "error";
      this.dispatchCallStateUpdate();
      throw error;
    }
  }

  async rejectCall(): Promise<void> {
    this.stopRinging();
    this.clearRingTimeout();

    try {
      if (this.sipManager && (this.callState.status === "ringing" || this.callState.incoming)) {
        await this.sipManager.rejectCall();
      } else {
        console.warn("Cannot reject call - invalid state:", this.callState.status);
        this.forceCallCleanup();
        return;
      }
    } catch (error) {
      console.error("Reject call failed:", error);
      this.forceCallCleanup();
      throw error;
    }
  }

  async hangupCall(): Promise<void> {
    try {
      await this.sipManager.hangup();
    } catch (error) {
      this.callState = this.getInitialState();
      this.dispatchCallStateUpdate();
      throw error;
    }
  }

  async toggleMute(): Promise<boolean> {
    try {
      if (this.callState.muted) {
        await this.sipManager.unmute();
        this.callState.muted = false;
      } else {
        await this.sipManager.mute();
        this.callState.muted = true;
      }

      this.dispatchCallStateUpdate();
      return this.callState.muted;
    } catch (error) {
      throw error;
    }
  }

  sendDTMF(tone: string): void {
    if (this.callState.active && this.callState.status === "answered") {
      this.sipManager.sendDTMF(tone);
    }
  }

  getCallState(): CallState {
    return { ...this.callState };
  }

  getRemoteVideo(): HTMLVideoElement | null {
    return this.sipManager.getRemoteVideo();
  }

  getCurrentCall(): CallInfo | null {
    return this.sipManager.getCurrentCall();
  }

  getFormattedDuration(): string {
    return formatDuration(this.callState.duration);
  }
}

---

=== Object: 7c640ef577b642ec92384f4eadfdc77ffa8e28f2 | Date: 2025-09-23 15:23:51 | Type: blob ===

import { LitElement, html, css, type CSSResultGroup, type TemplateResult } from "lit";
import { customElement, property, state, query } from "lit/decorators.js";
import type { HomeAssistant, SIPCardConfig, SIPContact } from "./types";
import { SipManager, type SipConfig } from "./sip-manager";
import { CallManager, type CallState } from "./call-manager";
import { sharedStyles } from "./styles";
import { CARD_VERSION, DEFAULT_CONFIG, DTMF_KEYS } from "./constants";
import { mergeConfig, validateConfig, formatPhoneNumber, sanitizeExtension } from "./utils";

@customElement("ha-webrtc-sip-card")
export class WebRTCSipCard extends LitElement {
  @property({ attribute: false }) public hass!: HomeAssistant;
  @state() private config!: SIPCardConfig;
  @state() private connected = false;
  @state() private registered = false;
  @state() private error: string | null = null;
  @state() private callState!: CallState;
  @state() private showKeypad = false;
  @state() private currentInput = "";
  @state() private callDuration = "00:00";
  @state() private remoteVideoAvailable = false;
  @state() private connectionAttempts = 0;
  @state() private isRetrying = false;

  @query("#remote-video") private remoteVideoElement?: HTMLVideoElement;

  private sipManager: SipManager | null = null;
  private callManager: CallManager | null = null;
  private remoteVideoCheckInterval: number | null = null;
  private remoteVideoUpdateTimeout: number | null = null;
  private connectionRetryTimeout: number | null = null;

  private readonly MAX_RETRY_ATTEMPTS = 5;
  private readonly RETRY_DELAYS = [2000, 5000, 10000, 20000, 30000];

  public static getConfigElement() {
    return document.createElement("ha-webrtc-sip-card-editor");
  }

  public static getStubConfig(): SIPCardConfig {
    return { ...DEFAULT_CONFIG };
  }

  public setConfig(config: SIPCardConfig): void {
    try {
      validateConfig(config);
      this.config = mergeConfig(config);
      this.connectionAttempts = 0;
      this.initializeSipClient();
    } catch (error) {
      this.error = error instanceof Error ? error.message : "Invalid configuration";
      throw new Error(this.error);
    }
  }

  public getCardSize(): number {
    return this.callState && this.callState.active ? 6 : 4;
  }

  private async initializeSipClient(): Promise<void> {
    try {
      if (this.sipManager) {
        await this.sipManager.disconnect();
      }

      this.error = null;
      this.connected = false;
      this.registered = false;
      this.isRetrying = false;

      const sipConfig: SipConfig = {
        server: this.config.server_url.replace(/^wss?:\/\//, "").replace(/:\d+$/, ""),
        username: this.config.username,
        password: this.config.password,
        domain: this.config.domain || this.config.server_url.replace(/^wss?:\/\//, "").replace(/:\d+$/, ""),
        websocket_port: this.config.websocket_port ? Number(this.config.websocket_port) : this.config.server_url.includes("wss://") ? 443 : 80,
        use_secure: this.config.server_url.startsWith("wss://"),
        display_name: this.config.display_name,
        debug: this.config.debug,
      };

      this.sipManager = new SipManager();
      this.callManager = new CallManager(this.sipManager, this.config.contacts);

      this.setupEventHandlers();
      this.callState = this.callManager.getCallState();
      this.sipManager.setConfig(sipConfig);

      this.attemptConnection();
    } catch (error) {
      this.error = error instanceof Error ? error.message : "Configuration failed";
      this.connected = false;
      this.registered = false;
      console.error("SIP configuration failed:", error);
    }
  }

  private async attemptConnection(): Promise<void> {
    if (this.connectionAttempts >= this.MAX_RETRY_ATTEMPTS) {
      this.error = "Failed to connect after multiple attempts. Please check server configuration and network connectivity.";
      this.isRetrying = false;
      this.requestUpdate();
      return;
    }

    if (this.connectionRetryTimeout) {
      clearTimeout(this.connectionRetryTimeout);
      this.connectionRetryTimeout = null;
    }

    try {
      this.isRetrying = this.connectionAttempts > 0;
      this.requestUpdate();

      console.log(`Connection attempt ${this.connectionAttempts + 1}/${this.MAX_RETRY_ATTEMPTS}`);

      await this.sipManager!.connect();

      this.connectionAttempts = 0;
      this.isRetrying = false;
      this.error = null;
      console.log("SIP client connected successfully");
      this.requestUpdate();
    } catch (error) {
      this.connectionAttempts++;
      const errorMessage = error instanceof Error ? error.message : "Connection failed";

      console.error(`Connection attempt ${this.connectionAttempts} failed:`, errorMessage);

      if (this.connectionAttempts < this.MAX_RETRY_ATTEMPTS) {
        const delay = this.RETRY_DELAYS[this.connectionAttempts - 1] || this.RETRY_DELAYS[this.RETRY_DELAYS.length - 1];

        this.error = `Connection failed. Retrying in ${Math.ceil(delay / 1000)} seconds... (${this.connectionAttempts}/${this.MAX_RETRY_ATTEMPTS})`;
        this.isRetrying = true;
        this.requestUpdate();

        this.connectionRetryTimeout = window.setTimeout(() => {
          this.attemptConnection();
        }, delay);
      } else {
        let detailedError = "Connection failed";
        if (errorMessage.includes("1006")) {
          detailedError =
            "WebSocket connection failed (1006). Check:\n Server is running and accessible\n Correct WebSocket URL and port\n Network/firewall allows WebSocket connections\n SSL certificate valid (for wss://)";
        } else if (errorMessage.includes("timeout")) {
          detailedError = "Connection timeout. Server may be unreachable or overloaded.";
        } else if (errorMessage.includes("refused")) {
          detailedError = "Connection refused. Check server URL and port.";
        }

        this.error = detailedError;
        this.isRetrying = false;
        this.connected = false;
        this.registered = false;
        this.requestUpdate();
      }
    }
  }

  private setupEventHandlers(): void {
    if (!this.sipManager || !this.callManager) return;

    this.sipManager.addEventListener("connected", () => {
      this.connected = true;
      this.connectionAttempts = 0;
      this.isRetrying = false;
      this.error = null;
      this.requestUpdate();
    });

    this.sipManager.addEventListener("disconnected", () => {
      this.connected = false;
      this.registered = false;
      if (!this.isRetrying && this.connectionAttempts === 0) {
        this.error = "Disconnected from server";
        this.scheduleReconnect();
      }
      this.requestUpdate();
    });

    this.sipManager.addEventListener("registered", (event: any) => {
      this.registered = event.detail.registered;
      if (this.registered) {
        this.error = null;
        this.connectionAttempts = 0;
        this.isRetrying = false;
      }
      this.requestUpdate();
    });

    this.sipManager.addEventListener("error", (event: any) => {
      const errorDetail = event.detail.error;
      console.error("SIP Manager error:", errorDetail);

      if (errorDetail.includes("WebSocket closed") || errorDetail.includes("1006")) {
        if (!this.isRetrying) {
          this.scheduleReconnect();
        }
      } else {
        this.error = errorDetail;
        this.connected = false;
        this.registered = false;
        this.requestUpdate();
      }
    });

    this.sipManager.addEventListener("localVideoChanged", (event: any) => {
      this.callState = this.callManager?.getCallState() || this.callState;
      this.requestUpdate();
    });

    this.sipManager.addEventListener("remoteVideoChanged", (event: any) => {
      console.log("Remote video changed:", event.detail);
      this.remoteVideoAvailable = event.detail.enabled && event.detail.hasVideoTracks;
      this.callState = this.callManager?.getCallState() || this.callState;
      this.callState.remoteVideoEnabled = this.remoteVideoAvailable;

      this.updateComplete.then(() => {
        this.debouncedUpdateRemoteVideo();
      });

      this.requestUpdate();
    });

    this.callManager.addEventListener("callStateChanged", (event: any) => {
      const wasActive = this.callState?.active;
      this.callState = event.detail.callState;

      if (this.callState.active && !wasActive) {
        this.startRemoteVideoMonitoring();
      } else if (!this.callState.active && wasActive) {
        this.stopRemoteVideoMonitoring();
        this.remoteVideoAvailable = false;
      }

      this.updateComplete.then(() => {
        this.debouncedUpdateRemoteVideo();
      });

      this.requestUpdate();
    });

    this.callManager.addEventListener("callTimerUpdate", (event: any) => {
      this.callDuration = event.detail.formattedDuration;
    });
  }

  private scheduleReconnect(): void {
    if (this.isRetrying || this.connectionRetryTimeout) return;

    console.log("Scheduling reconnection...");
    this.connectionAttempts = 0;

    this.connectionRetryTimeout = window.setTimeout(() => {
      this.attemptConnection();
    }, 3000);
  }

  private debouncedUpdateRemoteVideo(): void {
    if (this.remoteVideoUpdateTimeout) {
      clearTimeout(this.remoteVideoUpdateTimeout);
    }

    this.remoteVideoUpdateTimeout = window.setTimeout(() => {
      this.updateRemoteVideo();
      this.remoteVideoUpdateTimeout = null;
    }, 50);
  }

  private startRemoteVideoMonitoring(): void {
    this.stopRemoteVideoMonitoring();

    this.remoteVideoCheckInterval = window.setInterval(() => {
      const remoteVideo = this.callManager?.getRemoteVideo();
      if (remoteVideo && remoteVideo.srcObject) {
        const stream = remoteVideo.srcObject as MediaStream;
        const hasVideoTracks = stream.getVideoTracks().length > 0;

        if (hasVideoTracks !== this.remoteVideoAvailable) {
          this.remoteVideoAvailable = hasVideoTracks;
          this.callState.remoteVideoEnabled = hasVideoTracks;

          console.log("Remote video monitoring detected change:", {
            hasVideoTracks,
            streamId: stream.id,
          });

          this.updateRemoteVideo();
          this.requestUpdate();
        }
      }
    }, 1000);
  }

  private stopRemoteVideoMonitoring(): void {
    if (this.remoteVideoCheckInterval) {
      clearInterval(this.remoteVideoCheckInterval);
      this.remoteVideoCheckInterval = null;
    }
  }

  private updateRemoteVideo(): void {
    if (this.callState.active && this.remoteVideoElement) {
      const remoteVideo = this.callManager?.getRemoteVideo();
      if (remoteVideo && remoteVideo.srcObject) {
        console.log("Updating remote video element:", {
          hasStream: !!remoteVideo.srcObject,
          videoTracks: (remoteVideo.srcObject as MediaStream)?.getVideoTracks().length || 0,
        });

        const updateVideoStream = async () => {
          try {
            if (this.remoteVideoElement!.srcObject !== remoteVideo.srcObject) {
              if (!this.remoteVideoElement!.paused) {
                this.remoteVideoElement!.pause();
              }

              this.remoteVideoElement!.srcObject = remoteVideo.srcObject;
              this.remoteVideoElement!.autoplay = true;
              this.remoteVideoElement!.playsInline = true;
              this.remoteVideoElement!.muted = false;

              const playPromise = this.remoteVideoElement!.play();

              if (playPromise !== undefined) {
                playPromise
                  .then(() => {
                    console.log("Remote video playback started successfully");
                  })
                  .catch((error) => {
                    console.warn("Remote video playback failed:", error);
                  });
              }
            }
          } catch (error: any) {
            if (error.name === "AbortError") {
              console.log("Video play was interrupted, this is normal during stream updates");

              // Don't immediately retry, wait for a more stable state
              setTimeout(() => {
                if (this.remoteVideoElement && this.remoteVideoElement.srcObject) {
                  // Check if the element is still in a playable state
                  if (this.remoteVideoElement.readyState >= 2) { // HAVE_CURRENT_DATA
                    const retryPromise = this.remoteVideoElement.play();
                    if (retryPromise !== undefined) {
                      retryPromise.catch(() => {
                        console.log("Secondary play attempt failed, ignoring");
                      });
                    }
                  } else {
                    // If not ready, wait a bit more and try again
                    setTimeout(() => {
                      if (this.remoteVideoElement && this.remoteVideoElement.srcObject) {
                        const retryPromise = this.remoteVideoElement.play();
                        if (retryPromise !== undefined) {
                          retryPromise.catch(() => {
                            console.log("Delayed play attempt failed, ignoring");
                          });
                        }
                      }
                    }, 200);
                  }
                }
              }, 150);
            } else if (error.name === "NotAllowedError") {
              console.log("Video play not allowed, likely due to autoplay restrictions");

              // Try to handle autoplay restrictions by re-attaching the stream
              if (this.remoteVideoElement) {
                const currentStream = this.remoteVideoElement.srcObject;
                this.remoteVideoElement.srcObject = null;
                this.remoteVideoElement.srcObject = currentStream;
                setTimeout(() => {
                  if (this.remoteVideoElement && this.remoteVideoElement.srcObject) {
                    this.remoteVideoElement.muted = true;
                    const retryPromise = this.remoteVideoElement.play();
                    if (retryPromise !== undefined) {
                      retryPromise.catch((retryError) => {
                        console.log("Retry play attempt failed:", retryError);
                        
                        // Last resort: try to re-attach the stream again
                        if (this.remoteVideoElement && this.remoteVideoElement.srcObject) {
                          const currentStream = this.remoteVideoElement.srcObject;
                          this.remoteVideoElement.srcObject = null;
                          this.remoteVideoElement.srcObject = currentStream;
                          setTimeout(() => {
                            if (this.remoteVideoElement && this.remoteVideoElement.srcObject) {
                              this.remoteVideoElement.muted = true;
                              const finalPromise = this.remoteVideoElement.play();
                              if (finalPromise !== undefined) {
                                finalPromise.catch((finalError) => {
                                  console.log("Final play attempt failed:", finalError);
                                });
                              }
                            }
                          }, 100);
                        }
                      });
                    }
                  }
                }, 100);
              }
            } else {
              console.warn("Video play failed:", error);
            }
          }
        };

        updateVideoStream();

        if (!this.remoteVideoAvailable) {
          const stream = remoteVideo.srcObject as MediaStream;
          this.remoteVideoAvailable = stream.getVideoTracks().length > 0;
          this.requestUpdate();
        }
      }
    }
  }

  connectedCallback() {
    super.connectedCallback();
    if (this.config) {
      this.initializeSipClient();
    }
  }

  disconnectedCallback() {
    super.disconnectedCallback();

    if (this.connectionRetryTimeout) {
      clearTimeout(this.connectionRetryTimeout);
      this.connectionRetryTimeout = null;
    }

    if (this.remoteVideoUpdateTimeout) {
      clearTimeout(this.remoteVideoUpdateTimeout);
      this.remoteVideoUpdateTimeout = null;
    }

    this.stopRemoteVideoMonitoring();
    if (this.sipManager) {
      this.sipManager.disconnect().catch(console.error);
    }
  }

  protected render(): TemplateResult {
    if (!this.config) {
      return html`<ha-card><div class="error">Configuration required</div></ha-card>`;
    }

    return html` <ha-card> ${this.renderStatusBar()} ${this.renderError()} ${this.renderContent()} ${this.renderIncomingCallModal()} </ha-card> `;
  }

  private renderStatusBar(): TemplateResult {
    const statusClass = this.registered ? "connected" : this.connected ? "connecting" : this.isRetrying ? "retrying" : "disconnected";

    let statusText = "Disconnected";
    if (this.registered) {
      statusText = "Connected";
    } else if (this.connected) {
      statusText = "Registering...";
    } else if (this.isRetrying) {
      statusText = `Retrying... (${this.connectionAttempts}/${this.MAX_RETRY_ATTEMPTS})`;
    }

    return html`
      <div class="status-bar">
        <div class="status-indicator">
          <div class="status-dot ${statusClass}"></div>
          <span>${statusText}</span>
          ${this.isRetrying ? html`<ha-circular-progress size="small" indeterminate></ha-circular-progress>` : ""}
        </div>
        <div class="card-title">${this.config.title || "WebRTC SIP Phone"}</div>
        ${!this.registered && !this.isRetrying
          ? html` <ha-icon-button @click=${this.manualRetry} icon="mdi:refresh" title="Retry connection"></ha-icon-button> `
          : ""}
      </div>
    `;
  }

  private renderError(): TemplateResult {
    if (!this.error) return html``;

    const isMultiLine = this.error.includes("\n");

    return html`
      <div class="error-message ${isMultiLine ? "multiline" : ""}">
        <ha-icon icon="mdi:alert-circle"></ha-icon>
        <div class="error-text">${isMultiLine ? this.error.split("\n").map((line) => html`<div>${line}</div>`) : this.error}</div>
      </div>
    `;
  }

  private renderContent(): TemplateResult {
    if (this.callState.active) {
      return this.renderActiveCall();
    }

    return html` <div class="card-content">${this.renderContacts()} ${this.renderManualDial()} ${this.showKeypad ? this.renderKeypad() : ""}</div> `;
  }

  private renderContacts(): TemplateResult {
    if (!this.config.contacts.length) {
      return html`
        <div class="no-contacts">
          <ha-icon icon="mdi:account-plus-outline"></ha-icon>
          <div class="no-contacts-text">No contacts configured</div>
          <div class="no-contacts-subtitle">Add contacts in card configuration</div>
        </div>
      `;
    }

    return html`
      <div class="contacts-section">
        <div class="section-header">
          <ha-icon icon="mdi:contacts"></ha-icon>
          <h3>Quick Dial</h3>
          <div class="contact-count">${this.config.contacts.length}</div>
        </div>
        <div class="contacts-list">${this.config.contacts.map((contact) => this.renderContact(contact))}</div>
      </div>
    `;
  }

  private renderContact(contact: SIPContact): TemplateResult {
    return html`
      <div class="contact-item" ?disabled=${!this.registered}>
        <div class="contact-avatar">
          <ha-icon icon=${contact.icon || "mdi:account"}></ha-icon>
        </div>

        <div class="contact-info">
          <div class="contact-name">${contact.name}</div>
          <div class="contact-details">
            <span class="contact-extension">${formatPhoneNumber(contact.extension)}</span>
            <span class="video-badge">Video</span>
          </div>
        </div>

        <div class="contact-actions">
          <button class="action-btn video-btn" @click=${() => this.callContact(contact, true)} ?disabled=${!this.registered} title="Video call">
            <ha-icon icon="mdi:video"></ha-icon>
          </button>
        </div>
      </div>
    `;
  }

  private renderManualDial(): TemplateResult {
    return html`
      <div class="manual-dial">
        <div class="dial-input-container">
          <ha-textfield .value=${this.currentInput} @input=${this.handleInputChange} placeholder="Enter number..." ?disabled=${!this.registered}></ha-textfield>
          <ha-icon-button @click=${this.toggleKeypad} icon="mdi:dialpad" ?disabled=${!this.registered}></ha-icon-button>
        </div>
        <div class="dial-actions">
          <ha-button @click=${() => this.makeVideoCall()} ?disabled=${!this.registered || !this.currentInput.trim()} class="video-call">
            <ha-icon icon="mdi:video" slot="icon"></ha-icon> Video Call
          </ha-button>
          <ha-button @click=${this.clearInput} ?disabled=${!this.currentInput.length}> Clear </ha-button>
        </div>
      </div>
    `;
  }

  private renderKeypad(): TemplateResult {
    return html`
      <div class="keypad">
        ${DTMF_KEYS.flat().map((key) => html` <button class="keypad-button" @click=${() => this.handleKeypadPress(key)}>${key}</button> `)}
      </div>
    `;
  }

  private renderActiveCall(): TemplateResult {
    const isIncoming = this.callState.incoming && this.callState.status === "ringing";
    const isActive = this.callState.status === "answered";

    return html`
      <div class="active-call">
        ${this.renderCallInfo()} ${this.renderVideoStatus()} ${this.renderVideoArea()} ${isIncoming ? this.renderIncomingCallControls() : ""}
        ${isActive ? this.renderCallControls() : ""} ${isActive && !this.config.hide_keypad ? this.renderInCallKeypad() : ""}
      </div>
    `;
  }

  private renderCallInfo(): TemplateResult {
    return html`
      <div class="call-info">
        <div class="caller-name">${this.callState.callerName || "Unknown"}</div>
        <div class="caller-number">${formatPhoneNumber(this.callState.callerId || "")}</div>
        <div class="call-status">${this.getCallStatusText()}</div>
        ${this.callState.status === "answered" ? html`<div class="call-duration">${this.callDuration}</div>` : ""}
      </div>
    `;
  }

  private renderVideoStatus(): TemplateResult {
    return html`
      <div class="video-status">
        <div class="video-indicator active">
          <ha-icon icon="mdi:video"></ha-icon>
          <span>Camera On</span>
        </div>

        <div class="video-indicator ${this.remoteVideoAvailable ? "active" : "inactive"}">
          <ha-icon icon=${this.remoteVideoAvailable ? "mdi:video" : "mdi:video-off"}></ha-icon>
          <span>${this.remoteVideoAvailable ? "Remote Video" : "No Remote Video"}</span>
        </div>
      </div>
    `;
  }

  private renderVideoArea(): TemplateResult {
    return html`
      <div class="video-container ${this.remoteVideoAvailable ? "has-video" : "no-video"}">
        <video id="remote-video" autoplay playsinline ?muted=${false}></video>
        ${!this.remoteVideoAvailable
          ? html`
              <div class="video-overlay">
                <ha-icon icon="mdi:video-off"></ha-icon>
                <div>No remote video</div>
              </div>
            `
          : ""}
      </div>
    `;
  }

  private renderIncomingCallControls(): TemplateResult {
    return html`
      <div class="call-controls">
        <button class="control-button video" @click=${() => this.answerCall(true)}>
          <ha-icon icon="mdi:video"></ha-icon>
        </button>
        <button class="control-button danger" @click=${this.rejectCall}>
          <ha-icon icon="mdi:phone-hangup"></ha-icon>
        </button>
      </div>
    `;
  }

  private renderCallControls(): TemplateResult {
    return html`
      <div class="call-controls">
        <button class="control-button ${this.callState.muted ? "danger" : "secondary"}" @click=${this.toggleMute}>
          <ha-icon icon=${this.callState.muted ? "mdi:microphone-off" : "mdi:microphone"}></ha-icon>
        </button>

        <button class="control-button danger" @click=${this.hangupCall}>
          <ha-icon icon="mdi:phone-hangup"></ha-icon>
        </button>

        <button class="control-button secondary" @click=${() => (this.showKeypad = !this.showKeypad)}>
          <ha-icon icon="mdi:dialpad"></ha-icon>
        </button>
      </div>
    `;
  }

  private renderInCallKeypad(): TemplateResult {
    if (!this.showKeypad) return html``;

    return html`
      <div class="in-call-keypad">
        <div class="keypad">${DTMF_KEYS.flat().map((key) => html` <button class="keypad-button" @click=${() => this.sendDTMF(key)}>${key}</button> `)}</div>
      </div>
    `;
  }

  private renderIncomingCallModal(): TemplateResult {
    if (!this.callState.incoming || this.callState.status !== "ringing") {
      return html``;
    }

    return html`
      <div class="incoming-call-modal">
        <div class="incoming-call-content">
          <div class="incoming-call-avatar">
            <ha-icon icon="mdi:account"></ha-icon>
          </div>
          <div class="caller-name">${this.callState.callerName || "Unknown Caller"}</div>
          <div class="caller-number">${formatPhoneNumber(this.callState.callerId || "")}</div>
          <div class="incoming-call-actions">
            <button class="video-answer-button" @click=${() => this.answerCall(true)}>
              <ha-icon icon="mdi:video"></ha-icon>
            </button>
            <button class="reject-button" @click=${this.rejectCall}>
              <ha-icon icon="mdi:phone-hangup"></ha-icon>
            </button>
          </div>
        </div>
      </div>
    `;
  }

  private getCallStatusText(): string {
    switch (this.callState.status) {
      case "connecting":
        return "Connecting...";
      case "ringing":
        return this.callState.incoming ? "Incoming call" : "Ringing...";
      case "answered":
        return "Connected";
      case "ended":
        return "Call ended";
      case "error":
        return "Call failed";
      default:
        return "";
    }
  }

  private handleInputChange(event: Event): void {
    const target = event.target as HTMLInputElement;
    this.currentInput = sanitizeExtension(target.value);
  }

  private handleKeypadPress(key: string): void {
    this.currentInput += key;
    this.requestUpdate();
  }

  private toggleKeypad(): void {
    this.showKeypad = !this.showKeypad;
  }

  private clearInput(): void {
    this.currentInput = "";
  }

  private async manualRetry(): Promise<void> {
    this.connectionAttempts = 0;
    this.error = null;
    await this.attemptConnection();
  }

  private async callContact(contact: SIPContact, withVideo = true): Promise<void> {
    if (!this.callManager || !this.registered) return;

    try {
      await this.callManager.makeCall(contact.extension, withVideo);
      console.log(`Video call started to ${contact.name}`);
    } catch (error) {
      console.error("Failed to call contact:", error);
      this.error = `Failed to call ${contact.name}`;
    }
  }

  private async makeVideoCall(): Promise<void> {
    if (!this.callManager || !this.registered || !this.currentInput.trim()) return;

    try {
      await this.callManager.makeCall(this.currentInput.trim(), true);
      this.currentInput = "";
      this.showKeypad = false;
    } catch (error) {
      console.error("Failed to make video call:", error);
      this.error = "Failed to make video call";
    }
  }

  private async answerCall(withVideo = true): Promise<void> {
    if (!this.callManager) return;

    try {
      if (withVideo) {
        await this.callManager.enableVideo();
      }
      await this.callManager.answerCall();
    } catch (error) {
      console.error("Failed to answer call:", error);
      this.error = "Failed to answer call";
    }
  }

  private async rejectCall(): Promise<void> {
    if (!this.callManager) return;

    try {
      await this.callManager.rejectCall();
    } catch (error) {
      console.error("Failed to reject call:", error);
    }
  }

  private async hangupCall(): Promise<void> {
    if (!this.callManager) return;

    try {
      await this.callManager.hangupCall();
      this.showKeypad = false;
    } catch (error) {
      console.error("Failed to hangup call:", error);
    }
  }

  private async toggleMute(): Promise<void> {
    if (!this.callManager) return;

    try {
      await this.callManager.toggleMute();
    } catch (error) {
      console.error("Failed to toggle mute:", error);
      this.error = "Failed to toggle mute";
    }
  }

  private sendDTMF(tone: string): void {
    if (!this.callManager) return;
    this.callManager.sendDTMF(tone);
  }

  static get styles(): CSSResultGroup {
    return [
      sharedStyles,
      css`
        .card-title {
          font-weight: 500;
          font-size: 16px;
        }

        .status-bar {
          display: flex;
          align-items: center;
          justify-content: space-between;
          padding: 12px 16px;
          border-bottom: 1px solid var(--divider-color);
        }

        .status-indicator {
          display: flex;
          align-items: center;
          gap: 8px;
        }

        .status-dot {
          width: 8px;
          height: 8px;
          border-radius: 50%;
          animation: pulse 2s infinite;
        }

        .status-dot.connected {
          background: var(--success-color, #4caf50);
          animation: none;
        }

        .status-dot.connecting {
          background: var(--warning-color, #ff9800);
        }

        .status-dot.retrying {
          background: var(--info-color, #2196f3);
        }

        .status-dot.disconnected {
          background: var(--error-color, #f44336);
        }

        @keyframes pulse {
          0%,
          100% {
            opacity: 1;
          }
          50% {
            opacity: 0.5;
          }
        }

        .error-message {
          display: flex;
          align-items: flex-start;
          gap: 12px;
          padding: 16px;
          margin: 16px;
          background: rgba(var(--error-color-rgb, 244, 67, 54), 0.1);
          border: 1px solid var(--error-color, #f44336);
          border-radius: 8px;
          color: var(--error-color, #f44336);
        }

        .error-message.multiline {
          align-items: flex-start;
        }

        .error-message ha-icon {
          flex-shrink: 0;
          margin-top: 2px;
        }

        .error-text div {
          margin: 2px 0;
          font-size: 13px;
        }

        .contacts-section {
          margin-bottom: 24px;
        }

        .section-header {
          display: flex;
          align-items: center;
          gap: 12px;
          margin-bottom: 16px;
          padding: 0 4px;
        }

        .section-header ha-icon {
          color: var(--primary-color);
          font-size: 20px;
        }

        .section-header h3 {
          margin: 0;
          font-size: 16px;
          font-weight: 500;
          color: var(--primary-text-color);
          flex: 1;
        }

        .contact-count {
          background: var(--primary-color);
          color: white;
          font-size: 12px;
          font-weight: 500;
          padding: 2px 8px;
          border-radius: 12px;
          min-width: 16px;
          text-align: center;
        }

        .no-contacts {
          display: flex;
          flex-direction: column;
          align-items: center;
          padding: 48px 16px;
          text-align: center;
          background: var(--card-background-color);
          border: 2px dashed var(--divider-color);
          border-radius: 16px;
          margin-bottom: 24px;
        }

        .no-contacts ha-icon {
          font-size: 48px;
          color: var(--disabled-text-color);
          margin-bottom: 16px;
        }

        .no-contacts-text {
          font-size: 16px;
          font-weight: 500;
          color: var(--primary-text-color);
          margin-bottom: 4px;
        }

        .no-contacts-subtitle {
          font-size: 14px;
          color: var(--secondary-text-color);
        }

        .contacts-list {
          display: flex;
          flex-direction: column;
          gap: 8px;
        }

        .contact-item {
          display: flex;
          align-items: center;
          padding: 16px;
          background: var(--card-background-color);
          border: 1px solid var(--divider-color);
          border-radius: 16px;
          transition: all 0.2s ease;
          position: relative;
          overflow: hidden;
        }

        .contact-item::before {
          content: "";
          position: absolute;
          left: 0;
          top: 0;
          bottom: 0;
          width: 4px;
          background: var(--primary-color);
          transform: scaleY(0);
          transition: transform 0.2s ease;
        }

        .contact-item:hover:not([disabled]) {
          border-color: var(--primary-color);
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
          transform: translateY(-2px);
        }

        .contact-item:hover:not([disabled])::before {
          transform: scaleY(1);
        }

        .contact-item[disabled] {
          opacity: 0.6;
          cursor: not-allowed;
        }

        .contact-item[disabled] .action-btn {
          pointer-events: none;
        }

        .contact-avatar {
          width: 48px;
          height: 48px;
          border-radius: 50%;
          background: linear-gradient(135deg, var(--primary-color), var(--accent-color, var(--primary-color)));
          display: flex;
          align-items: center;
          justify-content: center;
          margin-right: 16px;
          flex-shrink: 0;
        }

        .contact-avatar ha-icon {
          font-size: 24px;
          color: white;
        }

        .contact-info {
          flex: 1;
          min-width: 0;
        }

        .contact-name {
          font-size: 16px;
          font-weight: 500;
          color: var(--primary-text-color);
          margin-bottom: 4px;
          white-space: nowrap;
          overflow: hidden;
          text-overflow: ellipsis;
        }

        .contact-details {
          display: flex;
          align-items: center;
          gap: 8px;
        }

        .contact-extension {
          font-size: 14px;
          color: var(--secondary-text-color);
          font-family: var(--code-font-family, monospace);
          background: var(--secondary-background-color);
          padding: 2px 6px;
          border-radius: 4px;
        }

        .video-badge {
          font-size: 11px;
          font-weight: 500;
          color: var(--primary-color);
          background: rgba(var(--primary-color-rgb, 33, 150, 243), 0.1);
          padding: 2px 6px;
          border-radius: 8px;
          text-transform: uppercase;
          letter-spacing: 0.5px;
        }

        .contact-actions {
          display: flex;
          gap: 8px;
          flex-shrink: 0;
        }

        .action-btn {
          width: 44px;
          height: 44px;
          border: none;
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
          cursor: pointer;
          transition: all 0.2s ease;
          position: relative;
          overflow: hidden;
        }

        .action-btn::before {
          content: "";
          position: absolute;
          inset: 0;
          background: currentColor;
          opacity: 0;
          transition: opacity 0.2s ease;
        }

        .action-btn:hover::before {
          opacity: 0.1;
        }

        .action-btn:active {
          transform: scale(0.95);
        }

        .action-btn ha-icon {
          font-size: 20px;
          z-index: 1;
        }

        .video-btn {
          background: var(--primary-color);
          color: white;
          box-shadow: 0 2px 4px rgba(var(--primary-color-rgb, 33, 150, 243), 0.3);
        }

        .video-btn:hover {
          box-shadow: 0 4px 12px rgba(var(--primary-color-rgb, 33, 150, 243), 0.4);
          transform: translateY(-2px);
        }

        .action-btn:disabled {
          opacity: 0.5;
          cursor: not-allowed;
          transform: none !important;
          box-shadow: none !important;
        }

        .manual-dial {
          margin-top: 24px;
          padding-top: 24px;
          border-top: 1px solid var(--sip-divider-color);
        }

        .dial-input-container {
          display: flex;
          gap: 8px;
          margin-bottom: 16px;
        }

        .dial-input-container ha-textfield {
          flex: 1;
        }

        .dial-actions {
          display: flex;
          gap: 12px;
          justify-content: center;
          flex-wrap: wrap;
        }

        .active-call {
          padding: 16px;
        }

        .call-status {
          font-size: 14px;
          color: var(--sip-text-secondary-color);
          margin-bottom: 8px;
        }

        .in-call-keypad {
          margin-top: 16px;
          padding-top: 16px;
          border-top: 1px solid var(--sip-divider-color);
        }

        .video-container {
          position: relative;
          width: 100%;
          height: 240px;
          background: #000;
          border-radius: 12px;
          overflow: hidden;
          margin-bottom: 16px;
          display: flex;
          align-items: center;
          justify-content: center;
        }

        .video-container video {
          width: 100%;
          height: 100%;
          object-fit: contain;
          background: #000;
          border-radius: 12px;
        }

        .video-container.has-video video {
          opacity: 1;
        }

        .video-container.no-video video {
          opacity: 0;
        }

        .video-overlay {
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          text-align: center;
          color: var(--primary-text-color);
          opacity: 0.7;
        }

        .video-overlay ha-icon {
          font-size: 48px;
          margin-bottom: 8px;
        }

        .video-status {
          display: flex;
          justify-content: center;
          gap: 16px;
          padding: 8px 16px;
          background: var(--secondary-background-color);
          border-radius: 8px;
          margin-bottom: 16px;
        }

        .video-indicator {
          display: flex;
          align-items: center;
          gap: 8px;
          padding: 4px 12px;
          border-radius: 16px;
          font-size: 12px;
          font-weight: 500;
          transition: all 0.2s ease;
        }

        .video-indicator.active {
          background: rgba(var(--success-color-rgb, 76, 175, 80), 0.1);
          color: var(--success-color, #4caf50);
        }

        .video-indicator.active ha-icon {
          color: var(--success-color, #4caf50);
        }

        .video-indicator.inactive {
          background: rgba(var(--disabled-text-color-rgb, 128, 128, 128), 0.1);
          color: var(--disabled-text-color, #808080);
        }

        .video-indicator.inactive ha-icon {
          color: var(--disabled-text-color, #808080);
        }

        .control-button.primary {
          background: var(--sip-success-color);
          color: white;
        }

        .control-button.video {
          background: var(--primary-color);
          color: white;
        }

        .control-button.secondary {
          background: var(--secondary-background-color);
          color: var(--primary-text-color);
        }

        .control-button.danger {
          background: var(--sip-danger-color);
          color: white;
        }

        .incoming-call-actions {
          display: flex;
          justify-content: center;
          gap: 24px;
        }

        .video-answer-button {
          background: var(--primary-color);
          border: none;
          border-radius: 50%;
          width: 64px;
          height: 64px;
          color: white;
          font-size: 24px;
          cursor: pointer;
          transition: all 0.2s ease;
        }

        .video-answer-button:hover {
          transform: scale(1.1);
        }

        ha-button.video-call {
          --mdc-theme-primary: var(--primary-color);
        }

        ha-textfield {
          width: 100%;
        }

        ha-icon-button {
          --mdc-icon-button-size: 40px;
        }

        @media (max-width: 600px) {
          .contact-item {
            padding: 12px;
          }

          .contact-avatar {
            width: 40px;
            height: 40px;
            margin-right: 12px;
          }

          .contact-avatar ha-icon {
            font-size: 20px;
          }

          .action-btn {
            width: 40px;
            height: 40px;
          }

          .action-btn ha-icon {
            font-size: 18px;
          }

          .contact-name {
            font-size: 15px;
          }

          .contact-extension {
            font-size: 13px;
          }

          .video-container {
            height: 200px;
          }
        }

        @media (max-width: 400px) {
          .section-header {
            margin-bottom: 12px;
          }

          .contacts-list {
            gap: 6px;
          }

          .contact-item {
            padding: 10px;
          }

          .contact-actions {
            gap: 6px;
          }

          .video-container {
            height: 160px;
          }
        }
      `,
    ];
  }
}

declare global {
  interface HTMLElementTagNameMap {
    "ha-webrtc-sip-card": WebRTCSipCard;
  }
}

(window as any).customCards = (window as any).customCards || [];
(window as any).customCards.push({
  type: "ha-webrtc-sip-card",
  name: "WebRTC SIP Card",
  description: "A modern WebRTC SIP client card for Home Assistant",
  version: CARD_VERSION,
});

console.info(
  `%c HA-WEBRTC-SIP-CARD %c ${CARD_VERSION} `,
  "color: white; background: #03a9f4; font-weight: bold;",
  "color: #03a9f4; background: white; font-weight: bold;"
);

---

=== Object: 01ee994722e361d8c2e8176d25862131b512b5de | Date: 2025-09-23 15:23:51 | Type: blob ===

{
  "compilerOptions": {
    "target": "ES2020",
    "lib": [
      "ES2020",
      "DOM",
      "DOM.Iterable"
    ],
    "module": "CommonJS",
    "moduleResolution": "node",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "resolveJsonModule": true,
    "isolatedModules": false,
    "noEmit": true,
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "experimentalDecorators": true,
    "useDefineForClassFields": false,
    "types": ["node"]
  },
  "include": [
    "src/**/*.ts",
    "src/**/*.d.ts"
  ]
}
---

=== Object: e1d15dea70f54389114a64627b4f3cfda7fd9d2a | Date: 2025-09-22 14:05:07 | Type: blob ===

import { debugLog, errorLog } from "./utils";

type SimpleUser = any;
type SimpleUserOptions = any;
let Web: any = null;

export interface SipConfig {
  server: string;
  username: string;
  password: string;
  domain: string;
  websocket_port: number;
  use_secure: boolean;
  display_name?: string;
  debug?: boolean;
}

export interface CallInfo {
  id: string;
  remoteIdentity: string;
  displayName: string;
  state: "incoming" | "outgoing" | "connected" | "ended";
  startTime?: Date;
  duration: number;
}

export class SipManager extends EventTarget {
  private simpleUser: SimpleUser | null = null;
  private config: SipConfig | null = null;
  private isRegistered = false;
  private isConnected = false;
  private connectionTimer: number | null = null;
  private currentCall: CallInfo | null = null;
  private remoteAudio: HTMLAudioElement | null = null;
  private remoteVideo: HTMLVideoElement | null = null;
  private localVideo: HTMLVideoElement | null = null;
  private localStream: MediaStream | null = null;
  private videoEnabled = false;
  private isInitialized = false;
  private isInitializing = false;
  private lastVideoState = false;

  constructor() {
    super();
    this.setupMediaElements();
  }

  private setupMediaElements(): void {
    this.remoteAudio = document.createElement("audio");
    this.remoteAudio.autoplay = true;
    this.remoteAudio.style.display = "none";
    document.body.appendChild(this.remoteAudio);

    this.remoteVideo = document.createElement("video");
    this.remoteVideo.autoplay = true;
    this.remoteVideo.playsInline = true;
    this.remoteVideo.style.display = "none";
    document.body.appendChild(this.remoteVideo);

    this.localVideo = document.createElement("video");
    this.localVideo.autoplay = true;
    this.localVideo.muted = true;
    this.localVideo.playsInline = true;
    this.localVideo.style.display = "none";
    document.body.appendChild(this.localVideo);
  }

  private async getUserMedia(includeVideo: boolean = false): Promise<MediaStream> {
    const constraints: MediaStreamConstraints = {
      audio: {
        echoCancellation: true,
        noiseSuppression: true,
        autoGainControl: true,
        sampleRate: 48000
      },
      video: includeVideo ? {
        width: { ideal: 640, min: 320, max: 1280 },
        height: { ideal: 480, min: 240, max: 720 },
        frameRate: { ideal: 30, min: 15, max: 30 },
        facingMode: "user"
      } : false
    };

    return navigator.mediaDevices.getUserMedia(constraints);
  }

  public async enableVideo(): Promise<void> {
    try {
      const stream = await this.getUserMedia(true);
      
      if (this.localVideo) {
        this.localVideo.srcObject = stream;
      }

      this.localStream = stream;
      this.videoEnabled = true;

      debugLog(this.config?.debug || false, "Local video enabled with stream:", {
        videoTracks: stream.getVideoTracks().length,
        audioTracks: stream.getAudioTracks().length
      });

      if (this.simpleUser?.session && this.currentCall?.state === "connected") {
        await this.replaceMediaTracks(stream);
      }

      this.dispatchEvent(
        new CustomEvent("localVideoChanged", {
          detail: { 
            enabled: true,
            transmitting: stream.getVideoTracks().some(track => track.enabled && track.readyState === 'live')
          },
        })
      );

    } catch (error) {
      errorLog("Enable video failed", error);
      throw error;
    }
  }

  public async disableVideo(): Promise<void> {
    try {
      if (!this.localStream) return;

      const audioOnlyStream = await this.getUserMedia(false);

      if (this.localVideo) {
        this.localVideo.srcObject = null;
      }

      this.localStream.getVideoTracks().forEach(track => track.stop());
      this.localStream = audioOnlyStream;
      this.videoEnabled = false;

      debugLog(this.config?.debug || false, "Local video disabled");

      if (this.simpleUser?.session && this.currentCall?.state === "connected") {
        await this.replaceMediaTracks(audioOnlyStream);
      }

      this.dispatchEvent(
        new CustomEvent("localVideoChanged", {
          detail: { 
            enabled: false,
            transmitting: false
          },
        })
      );

    } catch (error) {
      errorLog("Disable video failed", error);
      throw error;
    }
  }

  private async replaceMediaTracks(newStream: MediaStream): Promise<void> {
    try {
      const session = this.simpleUser?.session;
      if (!session || !session.sessionDescriptionHandler) {
        debugLog(this.config?.debug || false, "No active session to replace tracks");
        return;
      }

      const pc = session.sessionDescriptionHandler.peerConnection;
      if (!pc) {
        debugLog(this.config?.debug || false, "No peer connection found");
        return;
      }

      const senders = pc.getSenders();
      const audioTrack = newStream.getAudioTracks()[0];
      const audioSender = senders.find((sender: any) => sender.track && sender.track.kind === "audio");
      if (audioSender && audioTrack) {
        await audioSender.replaceTrack(audioTrack);
        debugLog(this.config?.debug || false, "Audio track replaced");
      }

      const videoTrack = newStream.getVideoTracks()[0] || null;
      const videoSender = senders.find((sender: any) => sender.track && sender.track.kind === "video");

      if (videoSender) {
        await videoSender.replaceTrack(videoTrack);
        debugLog(this.config?.debug || false, videoTrack ? "Video track replaced" : "Video track removed");
      }

    } catch (error) {
      debugLog(this.config?.debug || false, "Video toggle failed but call continues:", error);
    }
  }

  public async toggleVideo(): Promise<boolean> {
    if (this.videoEnabled) {
      await this.disableVideo();
      return false;
    } else {
      await this.enableVideo();
      return true;
    }
  }

  public getLocalVideoState(): { enabled: boolean; transmitting: boolean } {
    return {
      enabled: this.videoEnabled,
      transmitting: this.localStream ? 
        this.localStream.getVideoTracks().some(track => track.enabled && track.readyState === 'live') : false
    };
  }

  private setupRemoteStreamHandlers(session: any): void {
    try {
      const sessionDescriptionHandler = session.sessionDescriptionHandler;
      if (!sessionDescriptionHandler) return;

      const pc = sessionDescriptionHandler.peerConnection;
      if (!pc) return;

      debugLog(this.config?.debug || false, "Setting up remote stream handlers");

      pc.ontrack = (event: RTCTrackEvent) => {
        debugLog(this.config?.debug || false, "Remote track received:", {
          kind: event.track.kind,
          readyState: event.track.readyState,
          enabled: event.track.enabled,
          streams: event.streams.length
        });
        
        const stream = event.streams[0];
        if (!stream) {
          debugLog(this.config?.debug || false, "No stream in track event");
          return;
        }

        if (event.track.kind === 'audio') {
          if (this.remoteAudio) {
            this.remoteAudio.srcObject = stream;
            debugLog(this.config?.debug || false, "Remote audio stream attached");
          }
        } else if (event.track.kind === 'video') {
          if (this.remoteVideo) {
            const isDifferentStream = this.remoteVideo.srcObject !== stream;
            
            if (isDifferentStream) {
              this.remoteVideo.srcObject = stream;
              
              this.remoteVideo.onloadedmetadata = () => {
                debugLog(this.config?.debug || false, "Remote video metadata loaded");
                this.remoteVideo!.play().catch((error) => {
                  debugLog(this.config?.debug || false, "Remote video play failed:", error);
                });
              };
              
              debugLog(this.config?.debug || false, "Remote video stream attached");
            }
            
            const videoTracks = stream.getVideoTracks();
            const hasActiveVideo = videoTracks.length > 0 && videoTracks.some(track => track.enabled);
            
            debugLog(this.config?.debug || false, "Remote video tracks:", {
              count: videoTracks.length,
              hasActive: hasActiveVideo,
              tracks: videoTracks.map(t => ({
                enabled: t.enabled,
                readyState: t.readyState,
                id: t.id
              }))
            });

            if (hasActiveVideo !== this.lastVideoState) {
              this.lastVideoState = hasActiveVideo;
              
              setTimeout(() => {
                this.dispatchEvent(
                  new CustomEvent("remoteVideoChanged", {
                    detail: { 
                      enabled: true,
                      stream: stream,
                      hasVideoTracks: hasActiveVideo
                    },
                  })
                );
              }, 100);
            }
          }
        }
      };

      pc.onremovetrack = (event: RTCTrackEvent) => {
        debugLog(this.config?.debug || false, "Remote track removed:", event.track.kind);
        
        if (event.track.kind === 'video' && this.remoteVideo) {
          this.remoteVideo.srcObject = null;
          this.lastVideoState = false;
          
          this.dispatchEvent(
            new CustomEvent("remoteVideoChanged", {
              detail: { 
                enabled: false,
                stream: null,
                hasVideoTracks: false
              },
            })
          );
        }
      };

      pc.onconnectionstatechange = () => {
        debugLog(this.config?.debug || false, "Connection state changed:", pc.connectionState);
        
        if (pc.connectionState === 'connected') {
          setTimeout(() => {
            if (this.remoteVideo && this.remoteVideo.srcObject) {
              const stream = this.remoteVideo.srcObject as MediaStream;
              const videoTracks = stream.getVideoTracks();
              const hasActiveVideo = videoTracks.length > 0 && videoTracks.some(track => track.enabled);
              
              debugLog(this.config?.debug || false, "Connection established, checking video:", {
                hasVideo: hasActiveVideo,
                tracks: videoTracks.length
              });

              this.dispatchEvent(
                new CustomEvent("remoteVideoChanged", {
                  detail: { 
                    enabled: true,
                    stream: stream,
                    hasVideoTracks: hasActiveVideo
                  },
                })
              );
            }
          }, 500);
        }
      };

    } catch (error) {
      errorLog("Failed to setup remote stream handlers:", error);
    }
  }

  private async waitForSipLibrary(timeout = 15000): Promise<void> {
    return new Promise<void>(async (resolve, reject) => {
      const startTime = Date.now();
      const timeoutId = setTimeout(() => {
        reject(new Error(`SIP.js library loading timeout after ${timeout}ms`));
      }, timeout);

      const checkLibrary = async () => {
        try {
          if (!Web) {
            const SIP = await import("sip.js");
            Web = (SIP as any).Web || SIP;
          }

          const isFullyLoaded =
            Web &&
            Web.SimpleUser &&
            Web.SimpleUser.prototype &&
            typeof Web.SimpleUser.prototype.register === "function" &&
            typeof Web.SimpleUser.prototype.connect === "function" &&
            typeof Web.SimpleUser.prototype.disconnect === "function";

          if (isFullyLoaded) {
            clearTimeout(timeoutId);
            debugLog(this.config?.debug || false, "SIP.js library fully loaded and verified");
            resolve();
            return;
          }

          if (Date.now() - startTime > timeout) {
            clearTimeout(timeoutId);
            reject(new Error("SIP.js library verification timeout"));
            return;
          }

          setTimeout(checkLibrary, 100);
        } catch (error) {
          setTimeout(checkLibrary, 200);
        }
      };

      checkLibrary();
    });
  }

  private async ensureSipClient(): Promise<void> {
    if (this.isInitialized) return;

    if (this.isInitializing) {
      return new Promise((resolve, reject) => {
        const checkInterval = setInterval(() => {
          if (this.isInitialized) {
            clearInterval(checkInterval);
            resolve();
          } else if (!this.isInitializing) {
            clearInterval(checkInterval);
            reject(new Error("Initialization failed"));
          }
        }, 100);
      });
    }

    if (!this.config) {
      throw new Error("SIP configuration not set");
    }

    await this.initialize(this.config);
  }

  setConfig(config: SipConfig): void {
    this.config = config;
    debugLog(config.debug || false, "SIP configuration set, will initialize on first use");
  }

  async initialize(config: SipConfig): Promise<void> {
    if (this.isInitializing || this.isInitialized) return;

    this.isInitializing = true;
    this.config = config;

    debugLog(config.debug || false, "Starting lazy SIP initialization");

    try {
      await this.waitForSipLibrary();
      await new Promise((resolve) => setTimeout(resolve, 500));

      const wsProtocol = config.use_secure ? "wss" : "ws";
      const wsPort = config.websocket_port || (config.use_secure ? 443 : 80);
      const wsServer = `${wsProtocol}://${config.server}:${wsPort}`;
      const sipAor = `sip:${config.username}@${config.domain}`;

      debugLog(config.debug || false, "WebSocket URL:", wsServer);
      debugLog(config.debug || false, "SIP AOR:", sipAor);

      const getMediaOptions = (includeVideo: boolean = false) => ({
        constraints: includeVideo ? {
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true
          },
          video: {
            width: { ideal: 640 },
            height: { ideal: 480 },
            frameRate: { ideal: 30 }
          }
        } : {
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true
          },
          video: false
        },
        remote: {
          audio: this.remoteAudio!,
          video: this.remoteVideo!,
        }
      });

      const options: SimpleUserOptions = {
        aor: sipAor,
        media: getMediaOptions(false),
        userAgentOptions: {
          authorizationUsername: config.username,
          authorizationPassword: config.password,
          displayName: config.display_name || config.username,
          transportOptions: {
            server: wsServer,
            connectionTimeout: 15,
            maxReconnectionAttempts: 3,
            reconnectionTimeout: 4,
          },
          logLevel: config.debug ? "debug" : "error",
          sessionDescriptionHandlerFactoryOptions: {
            constraints: {
              audio: true,
              video: false,
            },
            peerConnectionConfiguration: {
              iceServers: [
                { urls: "stun:stun.l.google.com:19302" }, 
                { urls: "stun:stun1.l.google.com:19302" }
              ],
            },
          },
        },
      };

      if (!Web || !Web.SimpleUser) {
        throw new Error("SIP.js Web.SimpleUser not available after loading");
      }

      this.simpleUser = new Web.SimpleUser(wsServer, options);

      if (!this.simpleUser) {
        throw new Error("Failed to create SimpleUser instance");
      }

      if (!this.simpleUser.register || typeof this.simpleUser.register !== "function") {
        throw new Error("SimpleUser register method not available - library incomplete");
      }

      debugLog(config.debug || false, "SimpleUser created and verified successfully");

      this.setupEventHandlers();

      debugLog(config.debug || false, `Connecting to: ${wsServer}`);
      await this.simpleUser.connect();

      this.isConnected = true;
      this.dispatchEvent(new CustomEvent("connected"));
      debugLog(config.debug || false, "Connected to WebSocket server");

      debugLog(config.debug || false, "Registering with SIP server...");
      await this.simpleUser.register();

      this.isRegistered = true;
      this.dispatchEvent(new CustomEvent("registered", { detail: { registered: true } }));

      this.startConnectionMonitoring();

      this.isInitialized = true;
      this.isInitializing = false;

      debugLog(config.debug || false, "SIP client lazy initialization completed successfully");
    } catch (error) {
      this.isInitializing = false;
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      errorLog("SIP lazy initialization failed:", errorMessage);

      this.isConnected = false;
      this.isRegistered = false;

      if (this.simpleUser) {
        try {
          await this.simpleUser.disconnect();
        } catch (cleanupError) {
          debugLog(config.debug || false, "Cleanup error", cleanupError);
        }
        this.simpleUser = null;
      }

      this.dispatchEvent(
        new CustomEvent("error", {
          detail: {
            error: errorMessage,
            type: "initialization",
          },
        })
      );

      throw new Error(`Failed to initialize SIP client: ${errorMessage}`);
    }
  }

  private setupEventHandlers(): void {
    if (!this.simpleUser) {
      errorLog("Cannot setup event handlers: SimpleUser is null");
      return;
    }

    debugLog(this.config?.debug || false, "Setting up event handlers");

    this.simpleUser.delegate = {
      onCallCreated: () => {
        debugLog(this.config?.debug || false, "Call created");
        this.dispatchEvent(new CustomEvent("callCreated"));
      },

      onCallReceived: () => {
        debugLog(this.config?.debug || false, "Incoming call received");

        let remoteIdentity = "unknown";
        let displayName = "Unknown Caller";

        try {
          const session = this.simpleUser?.session;
          debugLog(this.config?.debug || false, "Current session:", session);

          if (session) {
            this.setupRemoteStreamHandlers(session);

            if (session.request) {
              const fromHeader = session.request.getHeader("From");
              debugLog(this.config?.debug || false, "From header:", fromHeader);
              
              if (fromHeader) {
                const uriMatches = fromHeader.match(/<sip:([^@]+)@/) || fromHeader.match(/sip:([^@]+)@/);
                if (uriMatches && uriMatches[1]) {
                  remoteIdentity = uriMatches[1];
                  debugLog(this.config?.debug || false, "Extracted extension from From:", remoteIdentity);
                }
                
                const nameMatches = fromHeader.match(/^"([^"]*)"/) || fromHeader.match(/^([^<]*)</);
                if (nameMatches && nameMatches[1] && nameMatches[1].trim()) {
                  displayName = nameMatches[1].trim();
                  debugLog(this.config?.debug || false, "Extracted display name:", displayName);
                } else if (remoteIdentity !== "unknown") {
                  displayName = remoteIdentity;
                }
              }
            }

            if (remoteIdentity === "unknown" && session.remoteIdentity) {
              debugLog(this.config?.debug || false, "Trying session.remoteIdentity:", session.remoteIdentity);
              
              if (session.remoteIdentity.uri) {
                const uriString = session.remoteIdentity.uri.toString();
                debugLog(this.config?.debug || false, "Remote URI:", uriString);
                
                const matches = uriString.match(/sip:([^@]+)@/);
                if (matches && matches[1]) {
                  remoteIdentity = matches[1];
                  debugLog(this.config?.debug || false, "Extracted from remote URI:", remoteIdentity);
                }
              }
              
              if (session.remoteIdentity.displayName) {
                displayName = session.remoteIdentity.displayName;
                debugLog(this.config?.debug || false, "Remote display name:", displayName);
              } else if (remoteIdentity !== "unknown") {
                displayName = remoteIdentity;
              }
            }
          }
        } catch (error) {
          debugLog(this.config?.debug || false, "Error parsing caller info:", error);
        }

        debugLog(this.config?.debug || false, "Final parsed caller info:", { remoteIdentity, displayName });

        this.currentCall = {
          id: Date.now().toString(),
          remoteIdentity: remoteIdentity,
          displayName: displayName,
          state: "incoming",
          duration: 0,
        };

        this.dispatchEvent(
          new CustomEvent("incomingCall", {
            detail: {
              from: remoteIdentity,
              displayName: displayName,
              callInfo: this.currentCall,
            },
          })
        );
      },

      onCallAnswered: () => {
        if (this.currentCall) {
          this.currentCall.state = "connected";
          this.currentCall.startTime = new Date();
        }

        debugLog(this.config?.debug || false, "Call answered");

        if (this.simpleUser?.session) {
          this.setupRemoteStreamHandlers(this.simpleUser.session);
        }

        this.dispatchEvent(
          new CustomEvent("callAnswered", {
            detail: { callInfo: this.currentCall },
          })
        );

        this.startCallTimer();
      },

      onCallHangup: () => {
        debugLog(this.config?.debug || false, "Call ended");

        if (this.remoteVideo) {
          this.remoteVideo.srcObject = null;
        }

        if (this.currentCall) {
          this.currentCall.state = "ended";
        }

        this.stopCallTimer();
        this.dispatchEvent(
          new CustomEvent("callEnded", {
            detail: { callInfo: this.currentCall },
          })
        );

        this.currentCall = null;
        this.lastVideoState = false;
      },

      onCallHold: (held: boolean) => {
        debugLog(this.config?.debug || false, "Call hold state changed", held);
        this.dispatchEvent(
          new CustomEvent("callHold", {
            detail: { held, callInfo: this.currentCall },
          })
        );
      },

      onRegistered: () => {
        this.isRegistered = true;
        debugLog(this.config?.debug || false, "Registration successful");
        this.dispatchEvent(new CustomEvent("registered", { detail: { registered: true } }));
      },

      onUnregistered: () => {
        this.isRegistered = false;
        debugLog(this.config?.debug || false, "Unregistered");
        this.dispatchEvent(new CustomEvent("registered", { detail: { registered: false } }));
      },

      onServerConnect: () => {
        this.isConnected = true;
        debugLog(this.config?.debug || false, "Server connected");
        this.dispatchEvent(new CustomEvent("connected"));
      },

      onServerDisconnect: () => {
        this.isConnected = false;
        this.isRegistered = false;
        debugLog(this.config?.debug || false, "Server disconnected");
        this.dispatchEvent(new CustomEvent("disconnected"));
      },
    };
  }

  private callTimer: number | null = null;

  private startCallTimer(): void {
    this.stopCallTimer();
    this.callTimer = window.setInterval(() => {
      if (this.currentCall && this.currentCall.startTime) {
        this.currentCall.duration = Math.floor((Date.now() - this.currentCall.startTime.getTime()) / 1000);
        this.dispatchEvent(
          new CustomEvent("callTimer", {
            detail: { duration: this.currentCall.duration, callInfo: this.currentCall },
          })
        );
      }
    }, 1000);
  }

  private stopCallTimer(): void {
    if (this.callTimer) {
      clearInterval(this.callTimer);
      this.callTimer = null;
    }
  }

  private startConnectionMonitoring(): void {
    this.connectionTimer = window.setInterval(() => {
      const connected = this.simpleUser?.isConnected() || false;

      if (connected !== this.isConnected) {
        this.isConnected = connected;
        this.dispatchEvent(
          new CustomEvent("heartbeat", {
            detail: {
              connected,
              registered: this.isRegistered,
            },
          })
        );
      }
    }, 5000);
  }

  async makeCall(target: string, includeVideo = false): Promise<void> {
    await this.ensureSipClient();

    if (!this.simpleUser || !this.isRegistered) {
      throw new Error("SIP client not registered");
    }

    if (this.currentCall) {
      throw new Error("Another call is already in progress");
    }

    try {
      const targetUri = `sip:${target}@${this.config!.domain}`;
      debugLog(this.config?.debug || false, "Making call to", targetUri, "with video:", includeVideo);

      let mediaStream: MediaStream;
      if (includeVideo) {
        if (!this.videoEnabled) {
          await this.enableVideo();
        }
        mediaStream = this.localStream!;
      } else {
        mediaStream = await this.getUserMedia(false);
      }

      this.currentCall = {
        id: Date.now().toString(),
        remoteIdentity: target,
        displayName: target,
        state: "outgoing",
        duration: 0,
      };

      const callOptions = {
        sessionDescriptionHandlerOptions: {
          constraints: {
            audio: true,
            video: includeVideo
          }
        },
        sessionDescriptionHandlerFactory: (session: any, options: any) => {
          options.localStream = mediaStream;
          return session.sessionDescriptionHandlerFactory(session, options);
        }
      };

      await this.simpleUser.call(targetUri, callOptions);

      if (this.simpleUser.session) {
        this.setupRemoteStreamHandlers(this.simpleUser.session);
      }

      this.dispatchEvent(
        new CustomEvent("callStarted", {
          detail: { 
            target, 
            callInfo: this.currentCall,
            videoEnabled: includeVideo
          },
        })
      );
    } catch (error) {
      errorLog("Call failed", error);
      this.currentCall = null;
      this.dispatchEvent(
        new CustomEvent("callFailed", {
          detail: {
            error: error instanceof Error ? error.message : "Call failed",
            target,
          },
        })
      );
      throw error;
    }
  }

  async answerCall(): Promise<void> {
    await this.ensureSipClient();

    if (!this.simpleUser) {
      throw new Error("SIP client not available");
    }

    try {
      let mediaStream: MediaStream;
      if (this.videoEnabled) {
        mediaStream = this.localStream!;
      } else {
        mediaStream = await this.getUserMedia(false);
      }

      const answerOptions = {
        sessionDescriptionHandlerOptions: {
          constraints: {
            audio: true,
            video: this.videoEnabled
          }
        },
        sessionDescriptionHandlerFactory: (session: any, options: any) => {
          options.localStream = mediaStream;
          return session.sessionDescriptionHandlerFactory(session, options);
        }
      };

      await this.simpleUser.answer(answerOptions);
      debugLog(this.config?.debug || false, "Call answered");
    } catch (error) {
      errorLog("Answer call failed", error);
      throw error;
    }
  }

  async rejectCall(): Promise<void> {
    await this.ensureSipClient();

    if (!this.simpleUser) {
      throw new Error("SIP client not available");
    }

    try {
      await this.simpleUser.decline();

      if (this.currentCall) {
        this.currentCall.state = "ended";
      }

      this.currentCall = null;
      debugLog(this.config?.debug || false, "Call rejected");
    } catch (error) {
      errorLog("Reject call failed", error);
      throw error;
    }
  }

  async hangup(): Promise<void> {
    if (!this.simpleUser) return;

    try {
      await this.simpleUser.hangup();
      debugLog(this.config?.debug || false, "Call hung up");
    } catch (error) {
      errorLog("Hangup failed", error);
      throw error;
    }
  }

  async hold(): Promise<void> {
    if (!this.simpleUser) return;

    try {
      await this.simpleUser.hold();
      debugLog(this.config?.debug || false, "Call put on hold");
    } catch (error) {
      errorLog("Hold failed", error);
      throw error;
    }
  }

  async unhold(): Promise<void> {
    if (!this.simpleUser) return;

    try {
      await this.simpleUser.unhold();
      debugLog(this.config?.debug || false, "Call removed from hold");
    } catch (error) {
      errorLog("Unhold failed", error);
      throw error;
    }
  }

  async mute(): Promise<void> {
    if (!this.simpleUser) return;

    try {
      await this.simpleUser.mute();
      debugLog(this.config?.debug || false, "Call muted");
    } catch (error) {
      errorLog("Mute failed", error);
      throw error;
    }
  }

  async unmute(): Promise<void> {
    if (!this.simpleUser) return;

    try {
      await this.simpleUser.unmute();
      debugLog(this.config?.debug || false, "Call unmuted");
    } catch (error) {
      errorLog("Unmute failed", error);
      throw error;
    }
  }

  sendDTMF(tone: string): void {
    if (!this.simpleUser || !this.currentCall) return;

    try {
      if (typeof this.simpleUser.sendDTMF === "function") {
        this.simpleUser.sendDTMF(tone);
        debugLog(this.config?.debug || false, "DTMF sent", tone);

        this.dispatchEvent(
          new CustomEvent("dtmfSent", {
            detail: { tone, callInfo: this.currentCall },
          })
        );
      }
    } catch (error) {
      errorLog("DTMF send failed", error);
    }
  }

  getRemoteVideo(): HTMLVideoElement | null {
    return this.remoteVideo;
  }

  getRemoteAudio(): HTMLAudioElement | null {
    return this.remoteAudio;
  }

  getCurrentCall(): CallInfo | null {
    return this.currentCall;
  }

  getConnectionStatus(): { connected: boolean; registered: boolean; initialized: boolean } {
    return {
      connected: this.isConnected,
      registered: this.isRegistered,
      initialized: this.isInitialized,
    };
  }

  async connect(): Promise<void> {
    await this.ensureSipClient();
  }

  async disconnect(): Promise<void> {
    if (this.connectionTimer) {
      clearInterval(this.connectionTimer);
      this.connectionTimer = null;
    }

    this.stopCallTimer();

    if (this.simpleUser) {
      try {
        if (this.currentCall) {
          await this.hangup();
        }

        if (this.isRegistered) {
          await this.simpleUser.unregister();
        }

        if (this.isConnected) {
          await this.simpleUser.disconnect();
        }
      } catch (error) {
        errorLog("Disconnect error", error);
      }

      this.simpleUser = null;
    }

    try {
      if (this.localStream) {
        this.localStream.getTracks().forEach(track => track.stop());
        this.localStream = null;
      }

      if (this.localVideo && this.localVideo.parentNode) {
        this.localVideo.pause();
        this.localVideo.srcObject = null;
        this.localVideo.parentNode.removeChild(this.localVideo);
        this.localVideo = null;
      }

      if (this.remoteVideo && this.remoteVideo.parentNode) {
        this.remoteVideo.pause();
        this.remoteVideo.srcObject = null;
        this.remoteVideo.parentNode.removeChild(this.remoteVideo);
        this.remoteVideo = null;
      }

      this.videoEnabled = false;

      if (this.remoteAudio && this.remoteAudio.parentNode) {
        this.remoteAudio.pause();
        this.remoteAudio.srcObject = null;
        this.remoteAudio.parentNode.removeChild(this.remoteAudio);
        this.remoteAudio = null;
      }
    } catch (error) {
      errorLog("Error cleaning up media resources:", error);
    }

    this.isConnected = false;
    this.isRegistered = false;
    this.isInitialized = false;
    this.isInitializing = false;
    this.currentCall = null;

    debugLog(this.config?.debug || false, "SIP client disconnected");
  }
}
---

=== Object: b1801e2a04d452ba510d5bbc93cde4b265690131 | Date: 2025-09-22 14:05:07 | Type: blob ===

import { LitElement, html, css, type CSSResultGroup, type TemplateResult } from "lit";
import { customElement, property, state, query } from "lit/decorators.js";
import type { HomeAssistant, SIPCardConfig, SIPContact } from "./types";
import { SipManager, type SipConfig } from "./sip-manager";
import { CallManager, type CallState } from "./call-manager";
import { sharedStyles } from "./styles";
import { CARD_VERSION, DEFAULT_CONFIG, DTMF_KEYS } from "./constants";
import { mergeConfig, validateConfig, formatPhoneNumber, sanitizeExtension } from "./utils";

@customElement("ha-webrtc-sip-card")
export class WebRTCSipCard extends LitElement {
  @property({ attribute: false }) public hass!: HomeAssistant;
  @state() private config!: SIPCardConfig;
  @state() private connected = false;
  @state() private registered = false;
  @state() private error: string | null = null;
  @state() private callState!: CallState;
  @state() private showKeypad = false;
  @state() private currentInput = "";
  @state() private callDuration = "00:00";
  @state() private remoteVideoAvailable = false;

  @query("#remote-video") private remoteVideoElement?: HTMLVideoElement;

  private sipManager: SipManager | null = null;
  private callManager: CallManager | null = null;
  private remoteVideoCheckInterval: number | null = null;
  private remoteVideoUpdateTimeout: number | null = null;

  public static getConfigElement() {
    return document.createElement("ha-webrtc-sip-card-editor");
  }

  public static getStubConfig(): SIPCardConfig {
    return { ...DEFAULT_CONFIG };
  }

  public setConfig(config: SIPCardConfig): void {
    try {
      validateConfig(config);
      this.config = mergeConfig(config);
      this.initializeSipClient();
    } catch (error) {
      this.error = error instanceof Error ? error.message : "Invalid configuration";
      throw new Error(this.error);
    }
  }

  public getCardSize(): number {
    return this.callState && this.callState.active ? 6 : 4;
  }

  private async initializeSipClient(): Promise<void> {
    try {
      if (this.sipManager) {
        await this.sipManager.disconnect();
      }

      this.error = null;
      this.connected = false;
      this.registered = false;

      const sipConfig: SipConfig = {
        server: this.config.server_url.replace(/^wss?:\/\//, "").replace(/:\d+$/, ""),
        username: this.config.username,
        password: this.config.password,
        domain: this.config.domain || this.config.server_url.replace(/^wss?:\/\//, "").replace(/:\d+$/, ""),
        websocket_port: this.config.websocket_port ? Number(this.config.websocket_port) : this.config.server_url.includes("wss://") ? 443 : 80,
        use_secure: this.config.server_url.startsWith("wss://"),
        display_name: this.config.display_name,
        debug: this.config.debug,
      };

      this.sipManager = new SipManager();
      this.callManager = new CallManager(this.sipManager, this.config.contacts);

      this.setupEventHandlers();
      this.callState = this.callManager.getCallState();
      this.sipManager.setConfig(sipConfig);

      setTimeout(async () => {
        try {
          await this.sipManager!.connect();
          console.log("SIP client auto-connected successfully");
        } catch (error) {
          console.error("Auto-connect failed:", error);
          this.error = error instanceof Error ? error.message : "Connection failed";
          this.requestUpdate();
        }
      }, 1000);
    } catch (error) {
      this.error = error instanceof Error ? error.message : "Configuration failed";
      this.connected = false;
      this.registered = false;
      console.error("SIP configuration failed:", error);
    }
  }

  private setupEventHandlers(): void {
    if (!this.sipManager || !this.callManager) return;

    this.sipManager.addEventListener("connected", () => {
      this.connected = true;
      this.requestUpdate();
    });

    this.sipManager.addEventListener("disconnected", () => {
      this.connected = false;
      this.registered = false;
      this.requestUpdate();
    });

    this.sipManager.addEventListener("registered", (event: any) => {
      this.registered = event.detail.registered;
      if (this.registered) {
        this.error = null;
      }
      this.requestUpdate();
    });

    this.sipManager.addEventListener("error", (event: any) => {
      this.error = event.detail.error;
      this.connected = false;
      this.registered = false;
      this.requestUpdate();
    });

    this.sipManager.addEventListener("localVideoChanged", (event: any) => {
      this.callState = this.callManager?.getCallState() || this.callState;
      this.requestUpdate();
    });

    this.sipManager.addEventListener("remoteVideoChanged", (event: any) => {
      console.log("Remote video changed:", event.detail);
      this.remoteVideoAvailable = event.detail.enabled && event.detail.hasVideoTracks;
      this.callState = this.callManager?.getCallState() || this.callState;
      this.callState.remoteVideoEnabled = this.remoteVideoAvailable;
      
      this.updateComplete.then(() => {
        this.debouncedUpdateRemoteVideo();
      });
      
      this.requestUpdate();
    });

    this.callManager.addEventListener("callStateChanged", (event: any) => {
      const wasActive = this.callState?.active;
      this.callState = event.detail.callState;
      
      if (this.callState.active && !wasActive) {
        this.startRemoteVideoMonitoring();
      } else if (!this.callState.active && wasActive) {
        this.stopRemoteVideoMonitoring();
        this.remoteVideoAvailable = false;
      }
      
      this.updateComplete.then(() => {
        this.debouncedUpdateRemoteVideo();
      });
      
      this.requestUpdate();
    });

    this.callManager.addEventListener("callTimerUpdate", (event: any) => {
      this.callDuration = event.detail.formattedDuration;
    });
  }

  private debouncedUpdateRemoteVideo(): void {
    if (this.remoteVideoUpdateTimeout) {
      clearTimeout(this.remoteVideoUpdateTimeout);
    }

    this.remoteVideoUpdateTimeout = window.setTimeout(() => {
      this.updateRemoteVideo();
      this.remoteVideoUpdateTimeout = null;
    }, 50);
  }

  private startRemoteVideoMonitoring(): void {
    this.stopRemoteVideoMonitoring();
    
    this.remoteVideoCheckInterval = window.setInterval(() => {
      const remoteVideo = this.callManager?.getRemoteVideo();
      if (remoteVideo && remoteVideo.srcObject) {
        const stream = remoteVideo.srcObject as MediaStream;
        const hasVideoTracks = stream.getVideoTracks().length > 0;
        
        if (hasVideoTracks !== this.remoteVideoAvailable) {
          this.remoteVideoAvailable = hasVideoTracks;
          this.callState.remoteVideoEnabled = hasVideoTracks;
          
          console.log("Remote video monitoring detected change:", {
            hasVideoTracks,
            streamId: stream.id
          });
          
          this.updateRemoteVideo();
          this.requestUpdate();
        }
      }
    }, 1000);
  }

  private stopRemoteVideoMonitoring(): void {
    if (this.remoteVideoCheckInterval) {
      clearInterval(this.remoteVideoCheckInterval);
      this.remoteVideoCheckInterval = null;
    }
  }

  private updateRemoteVideo(): void {
    if (this.callState.active && this.remoteVideoElement) {
      const remoteVideo = this.callManager?.getRemoteVideo();
      if (remoteVideo && remoteVideo.srcObject) {
        console.log("Updating remote video element:", {
          hasStream: !!remoteVideo.srcObject,
          videoTracks: (remoteVideo.srcObject as MediaStream)?.getVideoTracks().length || 0
        });
        
        const updateVideoStream = async () => {
          try {
            if (this.remoteVideoElement!.srcObject !== remoteVideo.srcObject) {
              if (!this.remoteVideoElement!.paused) {
                this.remoteVideoElement!.pause();
              }

              this.remoteVideoElement!.srcObject = remoteVideo.srcObject;
              this.remoteVideoElement!.autoplay = true;
              this.remoteVideoElement!.playsInline = true;
              this.remoteVideoElement!.muted = false;

              const playPromise = this.remoteVideoElement!.play();
              
              if (playPromise !== undefined) {
                await playPromise;
                console.log("Remote video playback started successfully");
              }
            }
          } catch (error: any) {
            if (error.name === 'AbortError') {
              console.log("Video play was interrupted, this is normal during stream updates");
              
              setTimeout(() => {
                if (this.remoteVideoElement && this.remoteVideoElement.srcObject) {
                  this.remoteVideoElement.play().catch(() => {
                    console.log("Secondary play attempt failed, ignoring");
                  });
                }
              }, 100);
            } else {
              console.warn("Video play failed:", error);
            }
          }
        };

        updateVideoStream();
        
        if (!this.remoteVideoAvailable) {
          const stream = remoteVideo.srcObject as MediaStream;
          this.remoteVideoAvailable = stream.getVideoTracks().length > 0;
          this.requestUpdate();
        }
      }
    }
  }

  connectedCallback() {
    super.connectedCallback();
    if (this.config) {
      this.initializeSipClient();
    }
  }

  disconnectedCallback() {
    super.disconnectedCallback();
    
    if (this.remoteVideoUpdateTimeout) {
      clearTimeout(this.remoteVideoUpdateTimeout);
      this.remoteVideoUpdateTimeout = null;
    }
    
    this.stopRemoteVideoMonitoring();
    if (this.sipManager) {
      this.sipManager.disconnect().catch(console.error);
    }
  }

  protected render(): TemplateResult {
    if (!this.config) {
      return html`<ha-card><div class="error">Configuration required</div></ha-card>`;
    }

    return html` <ha-card> ${this.renderStatusBar()} ${this.renderError()} ${this.renderContent()} ${this.renderIncomingCallModal()} </ha-card> `;
  }

  private renderStatusBar(): TemplateResult {
    const statusClass = this.registered ? "connected" : this.connected ? "connecting" : "disconnected";
    const statusText = this.registered ? "Connected" : this.connected ? "Connecting..." : "Disconnected";

    return html`
      <div class="status-bar">
        <div class="status-indicator">
          <div class="status-dot ${statusClass}"></div>
          <span>${statusText}</span>
        </div>
        <div class="card-title">${this.config.title || "WebRTC SIP Phone"}</div>
      </div>
    `;
  }

  private renderError(): TemplateResult {
    if (!this.error) return html``;

    return html`
      <div class="error-message">
        <ha-icon icon="mdi:alert-circle"></ha-icon>
        ${this.error}
      </div>
    `;
  }

  private renderContent(): TemplateResult {
    if (this.callState.active) {
      return this.renderActiveCall();
    }

    return html` <div class="card-content">${this.renderContacts()} ${this.renderManualDial()} ${this.showKeypad ? this.renderKeypad() : ""}</div> `;
  }

  private renderContacts(): TemplateResult {
    if (!this.config.contacts.length) {
      return html`<div class="no-contacts">No contacts configured</div>`;
    }

    return html`
      <div class="contacts-section">
        <h3>Quick Dial</h3>
        <div class="contacts-grid">${this.config.contacts.map((contact) => this.renderContact(contact))}</div>
      </div>
    `;
  }

  private renderContact(contact: SIPContact): TemplateResult {
    const supportsVideo = this.config.video_enabled && (contact.video_enabled !== false);
    
    return html`
      <div class="contact-card" ?disabled=${!this.registered}>
        <div class="contact-info">
          <ha-icon class="contact-icon" icon=${contact.icon || "mdi:account"}></ha-icon>
          <div class="contact-details">
            <div class="contact-name">${contact.name}</div>
            <div class="contact-extension">${formatPhoneNumber(contact.extension)}</div>
          </div>
        </div>
        <div class="contact-actions">
          <button 
            class="contact-call-btn audio" 
            @click=${() => this.callContact(contact, false)} 
            ?disabled=${!this.registered}
            title="Audio call"
          >
            <ha-icon icon="mdi:phone"></ha-icon>
          </button>
          ${supportsVideo ? html`
            <button 
              class="contact-call-btn video" 
              @click=${() => this.callContact(contact, true)} 
              ?disabled=${!this.registered}
              title="Video call"
            >
              <ha-icon icon="mdi:video"></ha-icon>
            </button>
          ` : ''}
        </div>
      </div>
    `;
  }

  private renderManualDial(): TemplateResult {
    return html`
      <div class="manual-dial">
        <div class="dial-input-container">
          <ha-textfield .value=${this.currentInput} @input=${this.handleInputChange} placeholder="Enter number..." ?disabled=${!this.registered}></ha-textfield>
          <ha-icon-button @click=${this.toggleKeypad} icon="mdi:dialpad" ?disabled=${!this.registered}></ha-icon-button>
        </div>
        <div class="dial-actions">
          <ha-button @click=${this.makeCall} ?disabled=${!this.registered || !this.currentInput.trim()} class="primary">
            <ha-icon icon="mdi:phone" slot="icon"></ha-icon> Call
          </ha-button>
          <ha-button
            @click=${() => this.makeVideoCall()}
            ?disabled=${!this.registered || !this.currentInput.trim() || !this.config.video_enabled}
            class="video-call"
          >
            <ha-icon icon="mdi:video" slot="icon"></ha-icon> Video Call
          </ha-button>
          <ha-button @click=${this.clearInput} ?disabled=${!this.currentInput.length}> Clear </ha-button>
        </div>
      </div>
    `;
  }

  private renderKeypad(): TemplateResult {
    return html`
      <div class="keypad">
        ${DTMF_KEYS.flat().map((key) => html` <button class="keypad-button" @click=${() => this.handleKeypadPress(key)}>${key}</button> `)}
      </div>
    `;
  }

  private renderActiveCall(): TemplateResult {
    const isIncoming = this.callState.incoming && this.callState.status === "ringing";
    const isActive = this.callState.status === "answered";

    return html`
      <div class="active-call">
        ${this.renderCallInfo()} 
        ${this.renderVideoStatus()} 
        ${this.renderVideoArea()}
        ${isIncoming ? this.renderIncomingCallControls() : ""} 
        ${isActive ? this.renderCallControls() : ""}
        ${isActive && !this.config.hide_keypad ? this.renderInCallKeypad() : ""}
      </div>
    `;
  }

  private renderCallInfo(): TemplateResult {
    return html`
      <div class="call-info">
        <div class="caller-name">${this.callState.callerName || "Unknown"}</div>
        <div class="caller-number">${formatPhoneNumber(this.callState.callerId || "")}</div>
        <div class="call-status">${this.getCallStatusText()}</div>
        ${this.callState.status === "answered" ? html`<div class="call-duration">${this.callDuration}</div>` : ""}
      </div>
    `;
  }

  private renderVideoStatus(): TemplateResult {
    if (!this.config.video_enabled) {
      return html``;
    }

    return html`
      <div class="video-status">
        <div class="video-indicator ${this.callState.localVideoTransmitting ? "active" : "inactive"}">
          <ha-icon icon=${this.callState.localVideoTransmitting ? "mdi:video" : "mdi:video-off"}></ha-icon>
          <span>${this.callState.localVideoTransmitting ? "Camera On" : "Camera Off"}</span>
        </div>
        
        <div class="video-indicator ${this.remoteVideoAvailable ? "active" : "inactive"}">
          <ha-icon icon=${this.remoteVideoAvailable ? "mdi:video" : "mdi:video-off"}></ha-icon>
          <span>${this.remoteVideoAvailable ? "Remote Video" : "No Remote Video"}</span>
        </div>
      </div>
    `;
  }

  private renderVideoArea(): TemplateResult {
    return html`
      <div class="video-container ${this.remoteVideoAvailable ? 'has-video' : 'no-video'}">
        <video id="remote-video" autoplay playsinline ?muted=${false}></video>
        ${!this.remoteVideoAvailable
          ? html`
              <div class="video-overlay">
                <ha-icon icon="mdi:video-off"></ha-icon>
                <div>No remote video</div>
              </div>
            `
          : ""}
      </div>
    `;
  }

  private renderIncomingCallControls(): TemplateResult {
    return html`
      <div class="call-controls">
        <button class="control-button primary" @click=${this.answerCall}>
          <ha-icon icon="mdi:phone"></ha-icon>
        </button>
        ${this.config.video_enabled
          ? html`
              <button class="control-button video" @click=${() => this.answerCall(true)}>
                <ha-icon icon="mdi:video"></ha-icon>
              </button>
            `
          : ""}
        <button class="control-button danger" @click=${this.rejectCall}>
          <ha-icon icon="mdi:phone-hangup"></ha-icon>
        </button>
      </div>
    `;
  }

  private renderCallControls(): TemplateResult {
    return html`
      <div class="call-controls">
        <button class="control-button ${this.callState.muted ? "danger" : "secondary"}" @click=${this.toggleMute}>
          <ha-icon icon=${this.callState.muted ? "mdi:microphone-off" : "mdi:microphone"}></ha-icon>
        </button>

        ${this.config.video_enabled
          ? html`
              <button
                class="control-button ${this.callState.localVideoTransmitting ? "primary" : "secondary"}"
                @click=${this.toggleVideo}
                title=${this.callState.localVideoTransmitting ? "Turn off camera" : "Turn on camera"}
              >
                <ha-icon icon=${this.callState.localVideoTransmitting ? "mdi:video" : "mdi:video-off"}></ha-icon>
              </button>
            `
          : ""}

        <button class="control-button ${this.callState.onHold ? "primary" : "secondary"}" @click=${this.toggleHold}>
          <ha-icon icon=${this.callState.onHold ? "mdi:play" : "mdi:pause"}></ha-icon>
        </button>

        <button class="control-button danger" @click=${this.hangupCall}>
          <ha-icon icon="mdi:phone-hangup"></ha-icon>
        </button>

        <button class="control-button secondary" @click=${() => (this.showKeypad = !this.showKeypad)}>
          <ha-icon icon="mdi:dialpad"></ha-icon>
        </button>
      </div>
    `;
  }

  private renderInCallKeypad(): TemplateResult {
    if (!this.showKeypad) return html``;

    return html`
      <div class="in-call-keypad">
        <div class="keypad">${DTMF_KEYS.flat().map((key) => html` <button class="keypad-button" @click=${() => this.sendDTMF(key)}>${key}</button> `)}</div>
      </div>
    `;
  }

  private renderIncomingCallModal(): TemplateResult {
    if (!this.callState.incoming || this.callState.status !== "ringing") {
      return html``;
    }

    return html`
      <div class="incoming-call-modal">
        <div class="incoming-call-content">
          <div class="incoming-call-avatar">
            <ha-icon icon="mdi:account"></ha-icon>
          </div>
          <div class="caller-name">${this.callState.callerName || "Unknown Caller"}</div>
          <div class="caller-number">${formatPhoneNumber(this.callState.callerId || "")}</div>
          <div class="incoming-call-actions">
            <button class="answer-button" @click=${this.answerCall}>
              <ha-icon icon="mdi:phone"></ha-icon>
            </button>
            ${this.config.video_enabled
              ? html`
                  <button class="video-answer-button" @click=${() => this.answerCall(true)}>
                    <ha-icon icon="mdi:video"></ha-icon>
                  </button>
                `
              : ""}
            <button class="reject-button" @click=${this.rejectCall}>
              <ha-icon icon="mdi:phone-hangup"></ha-icon>
            </button>
          </div>
        </div>
      </div>
    `;
  }

  private getCallStatusText(): string {
    switch (this.callState.status) {
      case "connecting":
        return "Connecting...";
      case "ringing":
        return this.callState.incoming ? "Incoming call" : "Ringing...";
      case "answered":
        return this.callState.onHold ? "On hold" : "Connected";
      case "ended":
        return "Call ended";
      case "error":
        return "Call failed";
      default:
        return "";
    }
  }

  private handleInputChange(event: Event): void {
    const target = event.target as HTMLInputElement;
    this.currentInput = sanitizeExtension(target.value);
  }

  private handleKeypadPress(key: string): void {
    this.currentInput += key;
    this.requestUpdate();
  }

  private toggleKeypad(): void {
    this.showKeypad = !this.showKeypad;
  }

  private clearInput(): void {
    this.currentInput = "";
  }

  private async callContact(contact: SIPContact, withVideo = false): Promise<void> {
    if (!this.callManager || !this.registered) return;

    try {
      await this.callManager.makeCall(contact.extension, withVideo);
      console.log(`${withVideo ? 'Video' : 'Audio'} call started to ${contact.name}`);
    } catch (error) {
      console.error("Failed to call contact:", error);
      this.error = `Failed to call ${contact.name}`;
    }
  }

  private async makeCall(): Promise<void> {
    if (!this.callManager || !this.registered || !this.currentInput.trim()) return;

    try {
      await this.callManager.makeCall(this.currentInput.trim());
      this.currentInput = "";
      this.showKeypad = false;
    } catch (error) {
      console.error("Failed to make call:", error);
      this.error = "Failed to make call";
    }
  }

  private async makeVideoCall(): Promise<void> {
    if (!this.callManager || !this.registered || !this.currentInput.trim()) return;

    try {
      await this.callManager.makeCall(this.currentInput.trim(), true);
      this.currentInput = "";
      this.showKeypad = false;
    } catch (error) {
      console.error("Failed to make video call:", error);
      this.error = "Failed to make video call";
    }
  }

  private async answerCall(withVideo = false): Promise<void> {
    if (!this.callManager) return;

    try {
      if (withVideo && this.config.video_enabled) {
        await this.callManager.enableVideo();
      }
      await this.callManager.answerCall();
    } catch (error) {
      console.error("Failed to answer call:", error);
      this.error = "Failed to answer call";
    }
  }

  private async rejectCall(): Promise<void> {
    if (!this.callManager) return;

    try {
      await this.callManager.rejectCall();
    } catch (error) {
      console.error("Failed to reject call:", error);
    }
  }

  private async hangupCall(): Promise<void> {
    if (!this.callManager) return;

    try {
      await this.callManager.hangupCall();
      this.showKeypad = false;
    } catch (error) {
      console.error("Failed to hangup call:", error);
    }
  }

  private async toggleMute(): Promise<void> {
    if (!this.callManager) return;

    try {
      await this.callManager.toggleMute();
    } catch (error) {
      console.error("Failed to toggle mute:", error);
      this.error = "Failed to toggle mute";
    }
  }

  private async toggleVideo(): Promise<void> {
    if (!this.callManager) return;

    try {
      await this.callManager.toggleVideo();
    } catch (error) {
      console.error("Toggle video failed:", error);
      this.error = "Failed to toggle video";
    }
  }

  private async toggleHold(): Promise<void> {
    if (!this.callManager) return;

    try {
      if (this.callState.onHold) {
        await this.callManager.unholdCall();
      } else {
        await this.callManager.holdCall();
      }
    } catch (error) {
      console.error("Failed to toggle hold:", error);
      this.error = "Failed to toggle hold";
    }
  }

  private sendDTMF(tone: string): void {
    if (!this.callManager) return;
    this.callManager.sendDTMF(tone);
  }

  static get styles(): CSSResultGroup {
    return [
      sharedStyles,
      css`
        .card-title {
          font-weight: 500;
          font-size: 16px;
        }

        .no-contacts {
          text-align: center;
          color: var(--sip-text-secondary-color);
          padding: 32px;
          font-style: italic;
        }

        .contacts-section h3 {
          margin: 0 0 16px 0;
          font-size: 18px;
          font-weight: 500;
        }

        .contact-card {
          display: flex;
          align-items: center;
          justify-content: space-between;
          padding: 12px 16px;
          margin-bottom: 8px;
          background: var(--card-background-color);
          border: 1px solid var(--divider-color);
          border-radius: 12px;
          transition: all 0.2s ease;
        }

        .contact-card:hover:not([disabled]) {
          background: var(--secondary-background-color);
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .contact-card[disabled] {
          opacity: 0.6;
          pointer-events: none;
        }

        .contact-info {
          display: flex;
          align-items: center;
          gap: 12px;
          flex: 1;
        }

        .contact-icon {
          font-size: 24px;
          color: var(--primary-color);
        }

        .contact-details {
          display: flex;
          flex-direction: column;
        }

        .contact-name {
          font-weight: 500;
          font-size: 14px;
          color: var(--primary-text-color);
        }

        .contact-extension {
          font-size: 12px;
          color: var(--secondary-text-color);
          margin-top: 2px;
        }

        .contact-actions {
          display: flex;
          gap: 8px;
        }

        .contact-call-btn {
          width: 40px;
          height: 40px;
          border: none;
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
          cursor: pointer;
          transition: all 0.2s ease;
          font-size: 18px;
        }

        .contact-call-btn:disabled {
          opacity: 0.5;
          cursor: not-allowed;
        }

        .contact-call-btn.audio {
          background: var(--sip-success-color);
          color: white;
        }

        .contact-call-btn.audio:hover:not(:disabled) {
          background: var(--sip-success-color);
          transform: scale(1.1);
          box-shadow: 0 2px 8px rgba(var(--sip-success-color-rgb, 76, 175, 80), 0.3);
        }

        .contact-call-btn.video {
          background: var(--primary-color);
          color: white;
        }

        .contact-call-btn.video:hover:not(:disabled) {
          background: var(--primary-color);
          transform: scale(1.1);
          box-shadow: 0 2px 8px rgba(var(--primary-color-rgb, 33, 150, 243), 0.3);
        }

        .manual-dial {
          margin-top: 24px;
          padding-top: 24px;
          border-top: 1px solid var(--sip-divider-color);
        }

        .dial-input-container {
          display: flex;
          gap: 8px;
          margin-bottom: 16px;
        }

        .dial-input-container ha-textfield {
          flex: 1;
        }

        .dial-actions {
          display: flex;
          gap: 12px;
          justify-content: center;
          flex-wrap: wrap;
        }

        .active-call {
          padding: 16px;
        }

        .call-status {
          font-size: 14px;
          color: var(--sip-text-secondary-color);
          margin-bottom: 8px;
        }

        .in-call-keypad {
          margin-top: 16px;
          padding-top: 16px;
          border-top: 1px solid var(--sip-divider-color);
        }

        .video-container {
          position: relative;
          width: 100%;
          height: 240px;
          background: #000;
          border-radius: 12px;
          overflow: hidden;
          margin-bottom: 16px;
          display: flex;
          align-items: center;
          justify-content: center;
        }

        .video-container video {
          width: 100%;
          height: 100%;
          object-fit: contain;
          background: #000;
          border-radius: 12px;
        }

        .video-container.has-video video {
          opacity: 1;
        }

        .video-container.no-video video {
          opacity: 0;
        }

        .video-overlay {
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          text-align: center;
          color: var(--primary-text-color);
          opacity: 0.7;
        }

        .video-overlay ha-icon {
          font-size: 48px;
          margin-bottom: 8px;
        }

        .video-status {
          display: flex;
          justify-content: center;
          gap: 16px;
          padding: 8px 16px;
          background: var(--secondary-background-color);
          border-radius: 8px;
          margin-bottom: 16px;
        }

        .video-indicator {
          display: flex;
          align-items: center;
          gap: 8px;
          padding: 4px 12px;
          border-radius: 16px;
          font-size: 12px;
          font-weight: 500;
          transition: all 0.2s ease;
        }

        .video-indicator.active {
          background: rgba(var(--success-color-rgb, 76, 175, 80), 0.1);
          color: var(--success-color, #4caf50);
        }

        .video-indicator.active ha-icon {
          color: var(--success-color, #4caf50);
        }

        .video-indicator.inactive {
          background: rgba(var(--disabled-text-color-rgb, 128, 128, 128), 0.1);
          color: var(--disabled-text-color, #808080);
        }

        .video-indicator.inactive ha-icon {
          color: var(--disabled-text-color, #808080);
        }

        .control-button.primary {
          background: var(--sip-success-color);
          color: white;
        }

        .control-button.video {
          background: var(--primary-color);
          color: white;
        }

        .control-button.secondary {
          background: var(--secondary-background-color);
          color: var(--primary-text-color);
        }

        .control-button.danger {
          background: var(--sip-danger-color);
          color: white;
        }

        .incoming-call-actions {
          display: flex;
          justify-content: center;
          gap: 24px;
        }

        .video-answer-button {
          background: var(--primary-color);
          border: none;
          border-radius: 50%;
          width: 64px;
          height: 64px;
          color: white;
          font-size: 24px;
          cursor: pointer;
          transition: all 0.2s ease;
        }

        .video-answer-button:hover {
          transform: scale(1.1);
        }

        ha-button.primary {
          --mdc-theme-primary: var(--sip-success-color);
        }

        ha-button.video-call {
          --mdc-theme-primary: var(--primary-color);
        }

        ha-textfield {
          width: 100%;
        }

        ha-icon-button {
          --mdc-icon-button-size: 40px;
        }

        @media (max-width: 600px) {
          .contact-card {
            padding: 10px 12px;
          }

          .contact-call-btn {
            width: 36px;
            height: 36px;
            font-size: 16px;
          }

          .video-container {
            height: 200px;
          }
        }

        @media (max-width: 400px) {
          .video-container {
            height: 160px;
          }
        }
      `,
    ];
  }
}

declare global {
  interface HTMLElementTagNameMap {
    "ha-webrtc-sip-card": WebRTCSipCard;
  }
}

(window as any).customCards = (window as any).customCards || [];
(window as any).customCards.push({
  type: "ha-webrtc-sip-card",
  name: "WebRTC SIP Card",
  description: "A modern WebRTC SIP client card for Home Assistant",
  version: CARD_VERSION,
});

console.info(
  `%c HA-WEBRTC-SIP-CARD %c ${CARD_VERSION} `,
  "color: white; background: #03a9f4; font-weight: bold;",
  "color: #03a9f4; background: white; font-weight: bold;"
);
---

=== Object: e723d8c55c1b3ea111dfcdea68db6d62d7e6ba14 | Date: 2025-09-22 13:48:45 | Type: blob ===

import type { CallInfo } from "./sip-manager";
import { SipManager } from "./sip-manager";
import { formatDuration, playRingtone, stopRingtone, getContactByExtension } from "./utils";
import type { SIPContact } from "./types";

export interface CallState {
  active: boolean;
  incoming: boolean;
  outgoing: boolean;
  onHold: boolean;
  muted: boolean;
  remoteVideoEnabled: boolean;
  localVideoTransmitting: boolean;
  callerId?: string;
  callerName?: string;
  duration: number;
  status: "idle" | "connecting" | "ringing" | "answered" | "held" | "ended" | "error";
}

export class CallManager extends EventTarget {
  private sipManager: SipManager;
  private callState: CallState;
  private ringtone: HTMLAudioElement | null = null;
  private ringTimeout: number | null = null;
  private contacts: SIPContact[] = [];

  constructor(sipManager: SipManager, contacts: SIPContact[] = []) {
    super();
    this.sipManager = sipManager;
    this.contacts = contacts;
    this.callState = this.getInitialState();
    this.setupSipEventHandlers();
  }

  /**
   * Update the contacts list for caller ID lookup
   */
  public updateContacts(contacts: SIPContact[]): void {
    this.contacts = contacts;
  }

  private getInitialState(): CallState {
    return {
      active: false,
      incoming: false,
      outgoing: false,
      onHold: false,
      muted: false,
      remoteVideoEnabled: false,
      localVideoTransmitting: false,
      duration: 0,
      status: "idle",
    };
  }

  private setupSipEventHandlers(): void {
    this.sipManager.addEventListener("incomingCall", this.handleIncomingCall.bind(this) as EventListener);
    this.sipManager.addEventListener("callStarted", this.handleCallStarted.bind(this) as EventListener);
    this.sipManager.addEventListener("callAnswered", this.handleCallAnswered.bind(this) as EventListener);
    this.sipManager.addEventListener("callEnded", this.handleCallEnded.bind(this) as EventListener);
    this.sipManager.addEventListener("callFailed", this.handleCallFailed.bind(this) as EventListener);
    this.sipManager.addEventListener("localVideoChanged", this.handleLocalVideoChanged.bind(this) as EventListener);
    this.sipManager.addEventListener("remoteVideoChanged", this.handleRemoteVideoChanged.bind(this) as EventListener);

    // CHANGED: Handle timer separately to prevent full re-renders
    this.sipManager.addEventListener("callTimer", this.handleCallTimer.bind(this) as EventListener);

    this.sipManager.addEventListener("callHold", this.handleCallHold.bind(this) as EventListener);
  }

  /**
   * Clean up extension to extract the numeric part
   */
  private cleanExtension(rawExtension: string): string {
    if (!rawExtension || rawExtension === "unknown") return rawExtension;

    // Remove common prefixes like "Extension "
    let cleaned = rawExtension.replace(/^Extension\s+/i, "");

    // Remove common suffixes like "-screen", "-web", "-mobile", etc.
    cleaned = cleaned.replace(/-screen$|-web$|-mobile$|-phone$/i, "");

    // Extract numeric part if it contains numbers
    const numericMatch = cleaned.match(/(\d+)/);
    if (numericMatch) {
      return numericMatch[1];
    }

    // If no numeric part found, return the cleaned version
    return cleaned;
  }

  /**
   * Clean up display name to remove redundant words
   */
  private cleanDisplayName(displayName: string, extension: string): string {
    if (!displayName || displayName === "unknown" || displayName === "Unknown Caller") {
      return extension;
    }

    // Remove "Extension " prefix and the extension number itself
    let cleaned = displayName.replace(/^Extension\s+/i, "");
    cleaned = cleaned.replace(new RegExp(`\\b${extension}\\b`, "g"), "").trim();

    // If nothing meaningful left, use extension
    if (!cleaned || cleaned === extension) {
      return extension;
    }

    return cleaned;
  }

  private handleIncomingCall(event: CustomEvent): void {
    const { from, displayName, callInfo } = event.detail;

    // Clean up the extension to get just the number
    const cleanedExtension = this.cleanExtension(from);

    // Clean up the display name
    const cleanedDisplayName = this.cleanDisplayName(displayName, cleanedExtension);

    // Try to find contact by the cleaned extension
    const contact = this.contacts ? getContactByExtension(this.contacts, cleanedExtension) : null;

    // Use contact name if found, otherwise use cleaned display name
    const finalCallerName = contact ? contact.name : cleanedDisplayName;

    this.callState = {
      ...this.callState,
      active: true,
      incoming: true,
      outgoing: false,
      callerId: cleanedExtension,
      callerName: finalCallerName,
      status: "ringing",
      duration: 0,
    };

    // Start ringtone
    this.ringtone = playRingtone();

    // FIXED: Auto-reject with proper state checking
    this.ringTimeout = window.setTimeout(() => {
      // Only reject if call is still ringing and incoming
      if (this.callState.status === "ringing" && this.callState.incoming) {
        this.rejectCall().catch((error) => {
          console.error("Auto-reject failed:", error);
          // Force cleanup if rejection fails
          this.forceCallCleanup();
        });
      }
    }, 30000);

    this.dispatchCallStateUpdate();
  }

  /**
   * Force cleanup call state when normal rejection fails
   */
  private forceCallCleanup(): void {
    this.stopRinging();
    this.clearRingTimeout();

    // Reset state
    this.callState = this.getInitialState();
    this.callState.status = "ended";

    this.dispatchCallStateUpdate();

    // Reset to idle after brief moment
    setTimeout(() => {
      this.callState.status = "idle";
      this.dispatchCallStateUpdate();
    }, 1000);
  }

  private handleCallStarted(event: CustomEvent): void {
    const { target } = event.detail;

    // Clean up the extension for outgoing calls too
    const cleanedExtension = this.cleanExtension(target);

    // Try to find contact by extension for outgoing calls
    const contact = this.contacts ? getContactByExtension(this.contacts, cleanedExtension) : null;
    const finalCallerName = contact ? contact.name : cleanedExtension;

    this.callState = {
      ...this.callState,
      active: true,
      incoming: false,
      outgoing: true,
      callerId: cleanedExtension,
      callerName: finalCallerName,
      status: "connecting",
      duration: 0, // Reset duration
    };

    this.dispatchCallStateUpdate();
  }

  private handleCallAnswered(_event: CustomEvent): void {
    this.stopRinging();

    this.callState = {
      ...this.callState,
      status: "answered",
      incoming: false,
      outgoing: false,
      duration: 0, // Reset duration when answered
    };

    // Check if remote video is available
    const remoteVideo = this.sipManager.getRemoteVideo();
    if (remoteVideo && remoteVideo.srcObject) {
      const stream = remoteVideo.srcObject as MediaStream;
      this.callState.remoteVideoEnabled = stream.getVideoTracks().length > 0;
    }

    this.dispatchCallStateUpdate();
  }

  private handleCallEnded(_event: CustomEvent): void {
    this.stopRinging();
    this.clearRingTimeout();

    this.callState = this.getInitialState();
    this.callState.status = "ended";

    this.dispatchCallStateUpdate();

    // Reset to idle after a brief moment
    setTimeout(() => {
      this.callState.status = "idle";
      this.dispatchCallStateUpdate();
    }, 2000);
  }

  private handleCallFailed(_event: CustomEvent): void {
    this.stopRinging();
    this.clearRingTimeout();

    this.callState = this.getInitialState();
    this.callState.status = "error";

    this.dispatchCallStateUpdate();
  }

  // CHANGED: Only update duration internally, dispatch separate timer event
  private handleCallTimer(event: CustomEvent): void {
    const { duration } = event.detail;

    // Update duration silently without dispatching state change
    this.callState.duration = duration;

    // Dispatch ONLY a timer event, not a full state change
    this.dispatchEvent(
      new CustomEvent("callTimerUpdate", {
        detail: {
          duration: duration,
          formattedDuration: formatDuration(duration),
        },
      })
    );
  }

  private handleCallHold(event: CustomEvent): void {
    const { held } = event.detail;
    this.callState.onHold = held;
    this.callState.status = held ? "held" : "answered";
    this.dispatchCallStateUpdate();
  }

  private handleLocalVideoChanged(event: CustomEvent): void {
    const { transmitting } = event.detail;
    this.callState.localVideoTransmitting = transmitting;
    this.dispatchCallStateUpdate();
  }

  private handleRemoteVideoChanged(event: CustomEvent): void {
    const { enabled } = event.detail;
    this.callState.remoteVideoEnabled = enabled;
    this.dispatchCallStateUpdate();
  }

  /**
   * Toggle video on/off
   */
  public async toggleVideo(): Promise<boolean> {
    try {
      const enabled = await this.sipManager.toggleVideo();
      return enabled;
    } catch (error) {
      console.error("Failed to toggle video:", error);
      throw error;
    }
  }

  /**
   * Enable video
   */
  public async enableVideo(): Promise<void> {
    try {
      await this.sipManager.enableVideo();
    } catch (error) {
      console.error("Failed to enable video:", error);
      throw error;
    }
  }

  /**
   * Disable video
   */
  public async disableVideo(): Promise<void> {
    try {
      await this.sipManager.disableVideo();
    } catch (error) {
      console.error("Failed to disable video:", error);
      throw error;
    }
  }

  private stopRinging(): void {
    if (this.ringtone) {
      stopRingtone(this.ringtone);
      this.ringtone = null;
    }
  }

  private clearRingTimeout(): void {
    if (this.ringTimeout) {
      clearTimeout(this.ringTimeout);
      this.ringTimeout = null;
    }
  }

  // CHANGED: Only dispatch full state changes when actually needed
  private dispatchCallStateUpdate(): void {
    this.dispatchEvent(
      new CustomEvent("callStateChanged", {
        detail: { callState: { ...this.callState } },
      })
    );
  }

  // Public methods for call control
  async makeCall(target: string, includeVideo?: boolean): Promise<void> {
    try {
      await this.sipManager.makeCall(target, includeVideo);
    } catch (error) {
      this.callState.status = "error";
      this.dispatchCallStateUpdate();
      throw error;
    }
  }

  async answerCall(): Promise<void> {
    try {
      await this.sipManager.answerCall();
    } catch (error) {
      this.callState.status = "error";
      this.dispatchCallStateUpdate();
      throw error;
    }
  }

  async rejectCall(): Promise<void> {
    this.stopRinging();
    this.clearRingTimeout();

    try {
      // Only try to reject if we have an active SIP manager and the call is in a rejectable state
      if (this.sipManager && (this.callState.status === "ringing" || this.callState.incoming)) {
        await this.sipManager.rejectCall();
      } else {
        console.warn("Cannot reject call - invalid state:", this.callState.status);
        // Force cleanup instead
        this.forceCallCleanup();
        return;
      }
    } catch (error) {
      console.error("Reject call failed:", error);
      // Force cleanup if rejection fails
      this.forceCallCleanup();
      throw error; // Still throw so UI can handle if needed
    }
  }

  async hangupCall(): Promise<void> {
    try {
      await this.sipManager.hangup();
    } catch (error) {
      // Force end call state even if hangup fails
      this.callState = this.getInitialState();
      this.dispatchCallStateUpdate();
      throw error;
    }
  }

  async holdCall(): Promise<void> {
    try {
      await this.sipManager.hold();
    } catch (error) {
      throw error;
    }
  }

  async unholdCall(): Promise<void> {
    try {
      await this.sipManager.unhold();
    } catch (error) {
      throw error;
    }
  }

  async toggleMute(): Promise<boolean> {
    try {
      if (this.callState.muted) {
        await this.sipManager.unmute();
        this.callState.muted = false;
      } else {
        await this.sipManager.mute();
        this.callState.muted = true;
      }

      this.dispatchCallStateUpdate();
      return this.callState.muted;
    } catch (error) {
      throw error;
    }
  }

  sendDTMF(tone: string): void {
    if (this.callState.active && this.callState.status === "answered") {
      this.sipManager.sendDTMF(tone);
    }
  }

  getCallState(): CallState {
    return { ...this.callState };
  }

  getRemoteVideo(): HTMLVideoElement | null {
    return this.sipManager.getRemoteVideo();
  }

  getCurrentCall(): CallInfo | null {
    return this.sipManager.getCurrentCall();
  }

  getFormattedDuration(): string {
    return formatDuration(this.callState.duration);
  }
}

---

=== Object: 7c106f17da06ff913cd84e4d510e38ba8faeae29 | Date: 2025-09-22 13:48:45 | Type: blob ===

import { debugLog, errorLog } from "./utils";

type SimpleUser = any;
type SimpleUserOptions = any;
let Web: any = null;

export interface SipConfig {
  server: string;
  username: string;
  password: string;
  domain: string;
  websocket_port: number;
  use_secure: boolean;
  display_name?: string;
  debug?: boolean;
}

export interface CallInfo {
  id: string;
  remoteIdentity: string;
  displayName: string;
  state: "incoming" | "outgoing" | "connected" | "ended";
  startTime?: Date;
  duration: number;
}

export class SipManager extends EventTarget {
  private simpleUser: SimpleUser | null = null;
  private config: SipConfig | null = null;
  private isRegistered = false;
  private isConnected = false;
  private connectionTimer: number | null = null;
  private currentCall: CallInfo | null = null;
  private remoteAudio: HTMLAudioElement | null = null;
  private remoteVideo: HTMLVideoElement | null = null;
  private localVideo: HTMLVideoElement | null = null;
  private localStream: MediaStream | null = null;
  private videoEnabled = false;
  private isInitialized = false;
  private isInitializing = false;

  constructor() {
    super();
    this.setupMediaElements();
  }

  private setupMediaElements(): void {
    // Setup remote audio element
    this.remoteAudio = document.createElement("audio");
    this.remoteAudio.autoplay = true;
    this.remoteAudio.style.display = "none";
    document.body.appendChild(this.remoteAudio);

    // Setup remote video element
    this.remoteVideo = document.createElement("video");
    this.remoteVideo.autoplay = true;
    this.remoteVideo.playsInline = true;
    this.remoteVideo.style.display = "none";
    document.body.appendChild(this.remoteVideo);

    // Setup local video element (hidden, for capture only)
    this.localVideo = document.createElement("video");
    this.localVideo.autoplay = true;
    this.localVideo.muted = true;
    this.localVideo.playsInline = true;
    this.localVideo.style.display = "none";
    document.body.appendChild(this.localVideo);
  }

  /**
   * Get user media with video constraints
   */
  private async getUserMedia(includeVideo: boolean = false): Promise<MediaStream> {
    const constraints: MediaStreamConstraints = {
      audio: {
        echoCancellation: true,
        noiseSuppression: true,
        autoGainControl: true,
        sampleRate: 48000,
      },
      video: includeVideo
        ? {
            width: { ideal: 640, min: 320, max: 1280 },
            height: { ideal: 480, min: 240, max: 720 },
            frameRate: { ideal: 30, min: 15, max: 30 },
            facingMode: "user",
          }
        : false,
    };

    return navigator.mediaDevices.getUserMedia(constraints);
  }

  /**
   * Enable local video stream
   */
  public async enableVideo(): Promise<void> {
    try {
      // Get new media stream with video
      const stream = await this.getUserMedia(true);

      // Update local video element
      if (this.localVideo) {
        this.localVideo.srcObject = stream;
      }

      // Store stream and update state
      this.localStream = stream;
      this.videoEnabled = true;

      debugLog(this.config?.debug || false, "Local video enabled with stream:", {
        videoTracks: stream.getVideoTracks().length,
        audioTracks: stream.getAudioTracks().length,
      });

      // If in call, replace tracks in the current session
      if (this.simpleUser?.session && this.currentCall?.state === "connected") {
        await this.replaceMediaTracks(stream);
      }

      // Notify that video state changed
      this.dispatchEvent(
        new CustomEvent("localVideoChanged", {
          detail: {
            enabled: true,
            transmitting: stream.getVideoTracks().some((track) => track.enabled && track.readyState === "live"),
          },
        })
      );
    } catch (error) {
      errorLog("Enable video failed", error);
      throw error;
    }
  }

  /**
   * Disable local video stream
   */
  public async disableVideo(): Promise<void> {
    try {
      if (!this.localStream) return;

      // Get new media stream without video (audio only)
      const audioOnlyStream = await this.getUserMedia(false);

      // Update local video element
      if (this.localVideo) {
        this.localVideo.srcObject = null;
      }

      // Stop video tracks from old stream
      this.localStream.getVideoTracks().forEach((track) => track.stop());

      // Update stream and state
      this.localStream = audioOnlyStream;
      this.videoEnabled = false;

      debugLog(this.config?.debug || false, "Local video disabled");

      // If in call, replace tracks in the current session
      if (this.simpleUser?.session && this.currentCall?.state === "connected") {
        await this.replaceMediaTracks(audioOnlyStream);
      }

      this.dispatchEvent(
        new CustomEvent("localVideoChanged", {
          detail: {
            enabled: false,
            transmitting: false,
          },
        })
      );
    } catch (error) {
      errorLog("Disable video failed", error);
      throw error;
    }
  }

  /**
   * Replace media tracks in current session
   */
  private async replaceMediaTracks(newStream: MediaStream): Promise<void> {
    try {
      const session = this.simpleUser?.session;
      if (!session || !session.sessionDescriptionHandler) {
        debugLog(this.config?.debug || false, "No active session to replace tracks");
        return;
      }

      const pc = session.sessionDescriptionHandler.peerConnection;
      if (!pc) {
        debugLog(this.config?.debug || false, "No peer connection found");
        return;
      }

      // Get current senders
      const senders = pc.getSenders();

      // Replace audio track
      const audioTrack = newStream.getAudioTracks()[0];
      const audioSender = senders.find((sender: any) => sender.track && sender.track.kind === "audio");
      if (audioSender && audioTrack) {
        await audioSender.replaceTrack(audioTrack);
        debugLog(this.config?.debug || false, "Audio track replaced");
      }

      // Handle video track
      const videoTrack = newStream.getVideoTracks()[0] || null;
      const videoSender = senders.find((sender: any) => sender.track && sender.track.kind === "video");

      if (videoSender) {
        // FIXED: Replace track without renegotiation
        await videoSender.replaceTrack(videoTrack);
        debugLog(this.config?.debug || false, videoTrack ? "Video track replaced" : "Video track removed");
      } else if (videoTrack) {
        // FIXED: Only add track if we don't already have a video sender
        try {
          pc.addTrack(videoTrack, newStream);
          debugLog(this.config?.debug || false, "Video track added to peer connection");

          // FIXED: Use proper SIP.js renegotiation method instead of session.invite()
          if (session.sessionDescriptionHandler && typeof session.sessionDescriptionHandler.sendReinvite === "function") {
            await session.sessionDescriptionHandler.sendReinvite();
            debugLog(this.config?.debug || false, "Session renegotiated for video using sendReinvite");
          } else {
            debugLog(this.config?.debug || false, "Cannot renegotiate - sendReinvite not available");
          }
        } catch (error) {
          debugLog(this.config?.debug || false, "Failed to add video track or renegotiate:", error);
          // Don't throw - video toggle failure shouldn't kill the call
        }
      }
    } catch (error) {
      errorLog("Replace media tracks failed", error);
      // FIXED: Don't throw error - video toggle failure shouldn't kill the call
      debugLog(this.config?.debug || false, "Video toggle failed but call continues");
    }
  }

  /**
   * Toggle video state
   */
  public async toggleVideo(): Promise<boolean> {
    if (this.videoEnabled) {
      await this.disableVideo();
      return false;
    } else {
      await this.enableVideo();
      return true;
    }
  }

  /**
   * Get current video state
   */
  public getLocalVideoState(): { enabled: boolean; transmitting: boolean } {
    return {
      enabled: this.videoEnabled,
      transmitting: this.localStream ? this.localStream.getVideoTracks().some((track) => track.enabled && track.readyState === "live") : false,
    };
  }

  /**
   * Setup remote stream handlers for the session
   */
  private setupRemoteStreamHandlers(session: any): void {
    try {
      const sessionDescriptionHandler = session.sessionDescriptionHandler;
      if (!sessionDescriptionHandler) return;

      const pc = sessionDescriptionHandler.peerConnection;
      if (!pc) return;

      // Handle remote streams
      pc.ontrack = (event: RTCTrackEvent) => {
        debugLog(this.config?.debug || false, "Remote track received:", event.track.kind);

        const stream = event.streams[0];
        if (!stream) return;

        if (event.track.kind === "audio") {
          // Handle remote audio
          if (this.remoteAudio) {
            this.remoteAudio.srcObject = stream;
            debugLog(this.config?.debug || false, "Remote audio stream attached");
          }
        } else if (event.track.kind === "video") {
          // Handle remote video
          if (this.remoteVideo) {
            this.remoteVideo.srcObject = stream;
            debugLog(this.config?.debug || false, "Remote video stream attached");

            // Notify about remote video availability
            this.dispatchEvent(
              new CustomEvent("remoteVideoChanged", {
                detail: {
                  enabled: true,
                  stream: stream,
                },
              })
            );
          }
        }
      };

      // Handle stream removal
      pc.onremovetrack = (event: RTCTrackEvent) => {
        debugLog(this.config?.debug || false, "Remote track removed:", event.track.kind);

        if (event.track.kind === "video" && this.remoteVideo) {
          this.remoteVideo.srcObject = null;

          this.dispatchEvent(
            new CustomEvent("remoteVideoChanged", {
              detail: {
                enabled: false,
                stream: null,
              },
            })
          );
        }
      };
    } catch (error) {
      errorLog("Failed to setup remote stream handlers:", error);
    }
  }

  /**
   * Wait for SIP.js library to be fully loaded and functional
   */
  private async waitForSipLibrary(timeout = 15000): Promise<void> {
    return new Promise<void>(async (resolve, reject) => {
      const startTime = Date.now();
      const timeoutId = setTimeout(() => {
        reject(new Error(`SIP.js library loading timeout after ${timeout}ms`));
      }, timeout);

      const checkLibrary = async () => {
        try {
          if (!Web) {
            const SIP = await import("sip.js");
            Web = (SIP as any).Web || SIP;
          }

          const isFullyLoaded =
            Web &&
            Web.SimpleUser &&
            Web.SimpleUser.prototype &&
            typeof Web.SimpleUser.prototype.register === "function" &&
            typeof Web.SimpleUser.prototype.connect === "function" &&
            typeof Web.SimpleUser.prototype.disconnect === "function";

          if (isFullyLoaded) {
            clearTimeout(timeoutId);
            debugLog(this.config?.debug || false, "SIP.js library fully loaded and verified");
            resolve();
            return;
          }

          if (Date.now() - startTime > timeout) {
            clearTimeout(timeoutId);
            reject(new Error("SIP.js library verification timeout"));
            return;
          }

          setTimeout(checkLibrary, 100);
        } catch (error) {
          setTimeout(checkLibrary, 200);
        }
      };

      checkLibrary();
    });
  }

  /**
   * Ensure SIP client is initialized - lazy loading approach
   */
  private async ensureSipClient(): Promise<void> {
    if (this.isInitialized) return;

    if (this.isInitializing) {
      return new Promise((resolve, reject) => {
        const checkInterval = setInterval(() => {
          if (this.isInitialized) {
            clearInterval(checkInterval);
            resolve();
          } else if (!this.isInitializing) {
            clearInterval(checkInterval);
            reject(new Error("Initialization failed"));
          }
        }, 100);
      });
    }

    if (!this.config) {
      throw new Error("SIP configuration not set");
    }

    await this.initialize(this.config);
  }

  /**
   * Set configuration but don't initialize immediately
   */
  setConfig(config: SipConfig): void {
    this.config = config;
    debugLog(config.debug || false, "SIP configuration set, will initialize on first use");
  }

  /**
   * Initialize SIP client with full library loading verification
   */
  async initialize(config: SipConfig): Promise<void> {
    if (this.isInitializing || this.isInitialized) return;

    this.isInitializing = true;
    this.config = config;

    debugLog(config.debug || false, "Starting lazy SIP initialization");

    try {
      await this.waitForSipLibrary();
      await new Promise((resolve) => setTimeout(resolve, 500));

      const wsProtocol = config.use_secure ? "wss" : "ws";
      const wsPort = config.websocket_port || (config.use_secure ? 443 : 80);
      const wsServer = `${wsProtocol}://${config.server}:${wsPort}`;
      const sipAor = `sip:${config.username}@${config.domain}`;

      debugLog(config.debug || false, "WebSocket URL:", wsServer);
      debugLog(config.debug || false, "SIP AOR:", sipAor);

      // Create media helper function that supports video
      const getMediaOptions = (includeVideo: boolean = false) => ({
        constraints: includeVideo
          ? {
              audio: {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true,
              },
              video: {
                width: { ideal: 640 },
                height: { ideal: 480 },
                frameRate: { ideal: 30 },
              },
            }
          : {
              audio: {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true,
              },
              video: false,
            },
        remote: {
          audio: this.remoteAudio!,
          video: this.remoteVideo!,
        },
      });

      const options: SimpleUserOptions = {
        aor: sipAor,
        media: getMediaOptions(false), // Start with audio only
        userAgentOptions: {
          authorizationUsername: config.username,
          authorizationPassword: config.password,
          displayName: config.display_name || config.username,
          transportOptions: {
            server: wsServer,
            connectionTimeout: 15,
            maxReconnectionAttempts: 3,
            reconnectionTimeout: 4,
          },
          logLevel: config.debug ? "debug" : "error",
          sessionDescriptionHandlerFactoryOptions: {
            constraints: {
              audio: true,
              video: false,
            },
            peerConnectionConfiguration: {
              iceServers: [{ urls: "stun:stun.l.google.com:19302" }, { urls: "stun:stun1.l.google.com:19302" }],
            },
          },
        },
      };

      if (!Web || !Web.SimpleUser) {
        throw new Error("SIP.js Web.SimpleUser not available after loading");
      }

      this.simpleUser = new Web.SimpleUser(wsServer, options);

      if (!this.simpleUser) {
        throw new Error("Failed to create SimpleUser instance");
      }

      if (!this.simpleUser.register || typeof this.simpleUser.register !== "function") {
        throw new Error("SimpleUser register method not available - library incomplete");
      }

      debugLog(config.debug || false, "SimpleUser created and verified successfully");

      this.setupEventHandlers();

      debugLog(config.debug || false, `Connecting to: ${wsServer}`);
      await this.simpleUser.connect();

      this.isConnected = true;
      this.dispatchEvent(new CustomEvent("connected"));
      debugLog(config.debug || false, "Connected to WebSocket server");

      debugLog(config.debug || false, "Registering with SIP server...");
      await this.simpleUser.register();

      this.isRegistered = true;
      this.dispatchEvent(new CustomEvent("registered", { detail: { registered: true } }));

      this.startConnectionMonitoring();

      this.isInitialized = true;
      this.isInitializing = false;

      debugLog(config.debug || false, "SIP client lazy initialization completed successfully");
    } catch (error) {
      this.isInitializing = false;
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      errorLog("SIP lazy initialization failed:", errorMessage);

      this.isConnected = false;
      this.isRegistered = false;

      if (this.simpleUser) {
        try {
          await this.simpleUser.disconnect();
        } catch (cleanupError) {
          debugLog(config.debug || false, "Cleanup error", cleanupError);
        }
        this.simpleUser = null;
      }

      this.dispatchEvent(
        new CustomEvent("error", {
          detail: {
            error: errorMessage,
            type: "initialization",
          },
        })
      );

      throw new Error(`Failed to initialize SIP client: ${errorMessage}`);
    }
  }

  private setupEventHandlers(): void {
    if (!this.simpleUser) {
      errorLog("Cannot setup event handlers: SimpleUser is null");
      return;
    }

    debugLog(this.config?.debug || false, "Setting up event handlers");

    this.simpleUser.delegate = {
      onCallCreated: () => {
        debugLog(this.config?.debug || false, "Call created");
        this.dispatchEvent(new CustomEvent("callCreated"));
      },

      onCallReceived: () => {
        debugLog(this.config?.debug || false, "Incoming call received");

        let remoteIdentity = "unknown";
        let displayName = "Unknown Caller";

        try {
          const session = this.simpleUser?.session;
          debugLog(this.config?.debug || false, "Current session:", session);

          if (session) {
            // Setup remote stream handlers for this session
            this.setupRemoteStreamHandlers(session);

            if (session.request) {
              const fromHeader = session.request.getHeader("From");
              debugLog(this.config?.debug || false, "From header:", fromHeader);

              if (fromHeader) {
                const uriMatches = fromHeader.match(/<sip:([^@]+)@/) || fromHeader.match(/sip:([^@]+)@/);
                if (uriMatches && uriMatches[1]) {
                  remoteIdentity = uriMatches[1];
                  debugLog(this.config?.debug || false, "Extracted extension from From:", remoteIdentity);
                }

                const nameMatches = fromHeader.match(/^"([^"]*)"/) || fromHeader.match(/^([^<]*)</);
                if (nameMatches && nameMatches[1] && nameMatches[1].trim()) {
                  displayName = nameMatches[1].trim();
                  debugLog(this.config?.debug || false, "Extracted display name:", displayName);
                } else if (remoteIdentity !== "unknown") {
                  displayName = remoteIdentity;
                }
              }
            }

            if (remoteIdentity === "unknown" && session.remoteIdentity) {
              debugLog(this.config?.debug || false, "Trying session.remoteIdentity:", session.remoteIdentity);

              if (session.remoteIdentity.uri) {
                const uriString = session.remoteIdentity.uri.toString();
                debugLog(this.config?.debug || false, "Remote URI:", uriString);

                const matches = uriString.match(/sip:([^@]+)@/);
                if (matches && matches[1]) {
                  remoteIdentity = matches[1];
                  debugLog(this.config?.debug || false, "Extracted from remote URI:", remoteIdentity);
                }
              }

              if (session.remoteIdentity.displayName) {
                displayName = session.remoteIdentity.displayName;
                debugLog(this.config?.debug || false, "Remote display name:", displayName);
              } else if (remoteIdentity !== "unknown") {
                displayName = remoteIdentity;
              }
            }
          }
        } catch (error) {
          debugLog(this.config?.debug || false, "Error parsing caller info:", error);
        }

        debugLog(this.config?.debug || false, "Final parsed caller info:", { remoteIdentity, displayName });

        this.currentCall = {
          id: Date.now().toString(),
          remoteIdentity: remoteIdentity,
          displayName: displayName,
          state: "incoming",
          duration: 0,
        };

        this.dispatchEvent(
          new CustomEvent("incomingCall", {
            detail: {
              from: remoteIdentity,
              displayName: displayName,
              callInfo: this.currentCall,
            },
          })
        );
      },

      onCallAnswered: () => {
        if (this.currentCall) {
          this.currentCall.state = "connected";
          this.currentCall.startTime = new Date();
        }

        debugLog(this.config?.debug || false, "Call answered");

        // Setup remote stream handlers for the active session
        if (this.simpleUser?.session) {
          this.setupRemoteStreamHandlers(this.simpleUser.session);
        }

        this.dispatchEvent(
          new CustomEvent("callAnswered", {
            detail: { callInfo: this.currentCall },
          })
        );

        this.startCallTimer();
      },

      onCallHangup: () => {
        debugLog(this.config?.debug || false, "Call ended");

        // Clear remote video when call ends
        if (this.remoteVideo) {
          this.remoteVideo.srcObject = null;
        }

        if (this.currentCall) {
          this.currentCall.state = "ended";
        }

        this.stopCallTimer();
        this.dispatchEvent(
          new CustomEvent("callEnded", {
            detail: { callInfo: this.currentCall },
          })
        );

        this.currentCall = null;
      },

      onCallHold: (held: boolean) => {
        debugLog(this.config?.debug || false, "Call hold state changed", held);
        this.dispatchEvent(
          new CustomEvent("callHold", {
            detail: { held, callInfo: this.currentCall },
          })
        );
      },

      onRegistered: () => {
        this.isRegistered = true;
        debugLog(this.config?.debug || false, "Registration successful");
        this.dispatchEvent(new CustomEvent("registered", { detail: { registered: true } }));
      },

      onUnregistered: () => {
        this.isRegistered = false;
        debugLog(this.config?.debug || false, "Unregistered");
        this.dispatchEvent(new CustomEvent("registered", { detail: { registered: false } }));
      },

      onServerConnect: () => {
        this.isConnected = true;
        debugLog(this.config?.debug || false, "Server connected");
        this.dispatchEvent(new CustomEvent("connected"));
      },

      onServerDisconnect: () => {
        this.isConnected = false;
        this.isRegistered = false;
        debugLog(this.config?.debug || false, "Server disconnected");
        this.dispatchEvent(new CustomEvent("disconnected"));
      },
    };
  }

  private callTimer: number | null = null;

  private startCallTimer(): void {
    this.stopCallTimer();
    this.callTimer = window.setInterval(() => {
      if (this.currentCall && this.currentCall.startTime) {
        this.currentCall.duration = Math.floor((Date.now() - this.currentCall.startTime.getTime()) / 1000);
        this.dispatchEvent(
          new CustomEvent("callTimer", {
            detail: { duration: this.currentCall.duration, callInfo: this.currentCall },
          })
        );
      }
    }, 1000);
  }

  private stopCallTimer(): void {
    if (this.callTimer) {
      clearInterval(this.callTimer);
      this.callTimer = null;
    }
  }

  private startConnectionMonitoring(): void {
    this.connectionTimer = window.setInterval(() => {
      const connected = this.simpleUser?.isConnected() || false;

      if (connected !== this.isConnected) {
        this.isConnected = connected;
        this.dispatchEvent(
          new CustomEvent("heartbeat", {
            detail: {
              connected,
              registered: this.isRegistered,
            },
          })
        );
      }
    }, 5000);
  }

  /**
   * Make a call to the specified target
   */
  async makeCall(target: string, includeVideo = false): Promise<void> {
    await this.ensureSipClient();

    if (!this.simpleUser || !this.isRegistered) {
      throw new Error("SIP client not registered");
    }

    if (this.currentCall) {
      throw new Error("Another call is already in progress");
    }

    try {
      const targetUri = `sip:${target}@${this.config!.domain}`;
      debugLog(this.config?.debug || false, "Making call to", targetUri, "with video:", includeVideo);

      // Get media stream for the call
      let mediaStream: MediaStream;
      if (includeVideo) {
        // Enable video if requested and get stream
        if (!this.videoEnabled) {
          await this.enableVideo();
        }
        mediaStream = this.localStream!;
      } else {
        // Get audio-only stream
        mediaStream = await this.getUserMedia(false);
      }

      this.currentCall = {
        id: Date.now().toString(),
        remoteIdentity: target,
        displayName: target,
        state: "outgoing",
        duration: 0,
      };

      // Call with proper media stream
      const callOptions = {
        sessionDescriptionHandlerOptions: {
          constraints: {
            audio: true,
            video: includeVideo,
          },
        },
        sessionDescriptionHandlerFactory: (session: any, options: any) => {
          // Pass our media stream to the session
          options.localStream = mediaStream;
          return session.sessionDescriptionHandlerFactory(session, options);
        },
      };

      await this.simpleUser.call(targetUri, callOptions);

      // Setup remote stream handlers for outgoing calls too
      if (this.simpleUser.session) {
        this.setupRemoteStreamHandlers(this.simpleUser.session);
      }

      this.dispatchEvent(
        new CustomEvent("callStarted", {
          detail: {
            target,
            callInfo: this.currentCall,
            videoEnabled: includeVideo,
          },
        })
      );
    } catch (error) {
      errorLog("Call failed", error);
      this.currentCall = null;
      this.dispatchEvent(
        new CustomEvent("callFailed", {
          detail: {
            error: error instanceof Error ? error.message : "Call failed",
            target,
          },
        })
      );
      throw error;
    }
  }

  async answerCall(): Promise<void> {
    await this.ensureSipClient();

    if (!this.simpleUser) {
      throw new Error("SIP client not available");
    }

    try {
      // If video is enabled, get video stream before answering
      let mediaStream: MediaStream;
      if (this.videoEnabled) {
        mediaStream = this.localStream!;
      } else {
        mediaStream = await this.getUserMedia(false);
      }

      const answerOptions = {
        sessionDescriptionHandlerOptions: {
          constraints: {
            audio: true,
            video: this.videoEnabled,
          },
        },
        sessionDescriptionHandlerFactory: (session: any, options: any) => {
          options.localStream = mediaStream;
          return session.sessionDescriptionHandlerFactory(session, options);
        },
      };

      await this.simpleUser.answer(answerOptions);
      debugLog(this.config?.debug || false, "Call answered");
    } catch (error) {
      errorLog("Answer call failed", error);
      throw error;
    }
  }

  async rejectCall(): Promise<void> {
    await this.ensureSipClient();

    if (!this.simpleUser) {
      throw new Error("SIP client not available");
    }

    try {
      await this.simpleUser.decline();

      if (this.currentCall) {
        this.currentCall.state = "ended";
      }

      this.currentCall = null;
      debugLog(this.config?.debug || false, "Call rejected");
    } catch (error) {
      errorLog("Reject call failed", error);
      throw error;
    }
  }

  async hangup(): Promise<void> {
    if (!this.simpleUser) return;

    try {
      await this.simpleUser.hangup();
      debugLog(this.config?.debug || false, "Call hung up");
    } catch (error) {
      errorLog("Hangup failed", error);
      throw error;
    }
  }

  async hold(): Promise<void> {
    if (!this.simpleUser) return;

    try {
      await this.simpleUser.hold();
      debugLog(this.config?.debug || false, "Call put on hold");
    } catch (error) {
      errorLog("Hold failed", error);
      throw error;
    }
  }

  async unhold(): Promise<void> {
    if (!this.simpleUser) return;

    try {
      await this.simpleUser.unhold();
      debugLog(this.config?.debug || false, "Call removed from hold");
    } catch (error) {
      errorLog("Unhold failed", error);
      throw error;
    }
  }

  async mute(): Promise<void> {
    if (!this.simpleUser) return;

    try {
      await this.simpleUser.mute();
      debugLog(this.config?.debug || false, "Call muted");
    } catch (error) {
      errorLog("Mute failed", error);
      throw error;
    }
  }

  async unmute(): Promise<void> {
    if (!this.simpleUser) return;

    try {
      await this.simpleUser.unmute();
      debugLog(this.config?.debug || false, "Call unmuted");
    } catch (error) {
      errorLog("Unmute failed", error);
      throw error;
    }
  }

  sendDTMF(tone: string): void {
    if (!this.simpleUser || !this.currentCall) return;

    try {
      if (typeof this.simpleUser.sendDTMF === "function") {
        this.simpleUser.sendDTMF(tone);
        debugLog(this.config?.debug || false, "DTMF sent", tone);

        this.dispatchEvent(
          new CustomEvent("dtmfSent", {
            detail: { tone, callInfo: this.currentCall },
          })
        );
      }
    } catch (error) {
      errorLog("DTMF send failed", error);
    }
  }

  getRemoteVideo(): HTMLVideoElement | null {
    return this.remoteVideo;
  }

  getRemoteAudio(): HTMLAudioElement | null {
    return this.remoteAudio;
  }

  getCurrentCall(): CallInfo | null {
    return this.currentCall;
  }

  getConnectionStatus(): { connected: boolean; registered: boolean; initialized: boolean } {
    return {
      connected: this.isConnected,
      registered: this.isRegistered,
      initialized: this.isInitialized,
    };
  }

  async connect(): Promise<void> {
    await this.ensureSipClient();
  }

  async disconnect(): Promise<void> {
    if (this.connectionTimer) {
      clearInterval(this.connectionTimer);
      this.connectionTimer = null;
    }

    this.stopCallTimer();

    if (this.simpleUser) {
      try {
        if (this.currentCall) {
          await this.hangup();
        }

        if (this.isRegistered) {
          await this.simpleUser.unregister();
        }

        if (this.isConnected) {
          await this.simpleUser.disconnect();
        }
      } catch (error) {
        errorLog("Disconnect error", error);
      }

      this.simpleUser = null;
    }

    // Cleanup video and audio resources
    try {
      if (this.localStream) {
        this.localStream.getTracks().forEach((track) => track.stop());
        this.localStream = null;
      }

      if (this.localVideo && this.localVideo.parentNode) {
        this.localVideo.pause();
        this.localVideo.srcObject = null;
        this.localVideo.parentNode.removeChild(this.localVideo);
        this.localVideo = null;
      }

      if (this.remoteVideo && this.remoteVideo.parentNode) {
        this.remoteVideo.pause();
        this.remoteVideo.srcObject = null;
        this.remoteVideo.parentNode.removeChild(this.remoteVideo);
        this.remoteVideo = null;
      }

      this.videoEnabled = false;

      if (this.remoteAudio && this.remoteAudio.parentNode) {
        this.remoteAudio.pause();
        this.remoteAudio.srcObject = null;
        this.remoteAudio.parentNode.removeChild(this.remoteAudio);
        this.remoteAudio = null;
      }
    } catch (error) {
      errorLog("Error cleaning up media resources:", error);
    }

    this.isConnected = false;
    this.isRegistered = false;
    this.isInitialized = false;
    this.isInitializing = false;
    this.currentCall = null;

    debugLog(this.config?.debug || false, "SIP client disconnected");
  }
}

---

=== Object: 6c3a0b028bf3147743f541a85ac3e1cdc77d520a | Date: 2025-09-22 13:48:45 | Type: blob ===

import { LitElement, html, css, type CSSResultGroup, type TemplateResult } from "lit";
import { customElement, property, state, query } from "lit/decorators.js";
import type { HomeAssistant, SIPCardConfig, SIPContact } from "./types";
import { SipManager, type SipConfig } from "./sip-manager";
import { CallManager, type CallState } from "./call-manager";
import { sharedStyles } from "./styles";
import { CARD_VERSION, DEFAULT_CONFIG, DTMF_KEYS } from "./constants";
import { mergeConfig, validateConfig, formatPhoneNumber, sanitizeExtension } from "./utils";

@customElement("ha-webrtc-sip-card")
export class WebRTCSipCard extends LitElement {
  @property({ attribute: false }) public hass!: HomeAssistant;
  @state() private config!: SIPCardConfig;
  @state() private connected = false;
  @state() private registered = false;
  @state() private error: string | null = null;
  @state() private callState!: CallState;
  @state() private showKeypad = false;
  @state() private currentInput = "";

  // Separate state for call duration to prevent full re-renders
  @state() private callDuration = "00:00";

  // FIXED: Add remote video state to trigger re-renders
  @state() private remoteVideoAvailable = false;

  @query("#remote-video") private remoteVideoElement?: HTMLVideoElement;

  private sipManager: SipManager | null = null;
  private callManager: CallManager | null = null;
  private remoteVideoCheckInterval: number | null = null;

  public static getConfigElement() {
    return document.createElement("ha-webrtc-sip-card-editor");
  }

  public static getStubConfig(): SIPCardConfig {
    return { ...DEFAULT_CONFIG };
  }

  public setConfig(config: SIPCardConfig): void {
    try {
      validateConfig(config);
      this.config = mergeConfig(config);
      this.initializeSipClient();
    } catch (error) {
      this.error = error instanceof Error ? error.message : "Invalid configuration";
      throw new Error(this.error);
    }
  }

  public getCardSize(): number {
    return this.callState && this.callState.active ? 6 : 4;
  }

  private async initializeSipClient(): Promise<void> {
    try {
      // Cleanup existing connections
      if (this.sipManager) {
        await this.sipManager.disconnect();
      }

      this.error = null;
      this.connected = false;
      this.registered = false;

      const sipConfig: SipConfig = {
        server: this.config.server_url.replace(/^wss?:\/\//, "").replace(/:\d+$/, ""),
        username: this.config.username,
        password: this.config.password,
        domain: this.config.domain || this.config.server_url.replace(/^wss?:\/\//, "").replace(/:\d+$/, ""),
        websocket_port: this.config.websocket_port ? Number(this.config.websocket_port) : this.config.server_url.includes("wss://") ? 443 : 80,
        use_secure: this.config.server_url.startsWith("wss://"),
        display_name: this.config.display_name,
        debug: this.config.debug,
      };

      this.sipManager = new SipManager();
      this.callManager = new CallManager(this.sipManager, this.config.contacts);

      // Setup event handlers
      this.setupEventHandlers();

      // Initialize call state
      this.callState = this.callManager.getCallState();

      // Set config for lazy loading
      this.sipManager.setConfig(sipConfig);

      // Auto-connect after a brief delay to allow UI to load
      setTimeout(async () => {
        try {
          await this.sipManager!.connect();
          console.log("SIP client auto-connected successfully");
        } catch (error) {
          console.error("Auto-connect failed:", error);
          this.error = error instanceof Error ? error.message : "Connection failed";
          this.requestUpdate();
        }
      }, 1000);
    } catch (error) {
      this.error = error instanceof Error ? error.message : "Configuration failed";
      this.connected = false;
      this.registered = false;
      console.error("SIP configuration failed:", error);
    }
  }

  private setupEventHandlers(): void {
    if (!this.sipManager || !this.callManager) return;

    // SIP connection events
    this.sipManager.addEventListener("connected", () => {
      this.connected = true;
      this.requestUpdate();
    });

    this.sipManager.addEventListener("disconnected", () => {
      this.connected = false;
      this.registered = false;
      this.requestUpdate();
    });

    this.sipManager.addEventListener("registered", (event: any) => {
      this.registered = event.detail.registered;
      if (this.registered) {
        this.error = null;
      }
      this.requestUpdate();
    });

    this.sipManager.addEventListener("error", (event: any) => {
      this.error = event.detail.error;
      this.connected = false;
      this.registered = false;
      this.requestUpdate();
    });

    // Local video state events
    this.sipManager.addEventListener("localVideoChanged", (event: any) => {
      this.callState = this.callManager?.getCallState() || this.callState;
      this.requestUpdate();
    });

    // FIXED: Handle remote video changes with proper state updates
    this.sipManager.addEventListener("remoteVideoChanged", (event: any) => {
      console.log("Remote video changed:", event.detail);

      // Update remote video state to trigger re-render
      this.remoteVideoAvailable = event.detail.enabled && event.detail.hasVideoTracks;

      // Update call state
      this.callState = this.callManager?.getCallState() || this.callState;
      this.callState.remoteVideoEnabled = this.remoteVideoAvailable;

      // Force update of remote video element after render
      this.updateComplete.then(() => {
        this.updateRemoteVideo();
      });

      this.requestUpdate();
    });

    // Call state events
    this.callManager.addEventListener("callStateChanged", (event: any) => {
      const wasActive = this.callState?.active;
      this.callState = event.detail.callState;

      // FIXED: Start remote video monitoring when call becomes active
      if (this.callState.active && !wasActive) {
        this.startRemoteVideoMonitoring();
      } else if (!this.callState.active && wasActive) {
        this.stopRemoteVideoMonitoring();
        this.remoteVideoAvailable = false;
      }

      // Always try to update remote video when call state changes
      this.updateComplete.then(() => {
        this.updateRemoteVideo();
      });

      this.requestUpdate();
    });

    // Handle timer updates separately to prevent full re-renders
    this.callManager.addEventListener("callTimerUpdate", (event: any) => {
      // Only update the duration state - Lit will handle the re-render automatically
      this.callDuration = event.detail.formattedDuration;
    });
  }

  // FIXED: Monitor remote video availability
  private startRemoteVideoMonitoring(): void {
    this.stopRemoteVideoMonitoring(); // Clear any existing interval

    this.remoteVideoCheckInterval = window.setInterval(() => {
      const remoteVideo = this.callManager?.getRemoteVideo();
      if (remoteVideo && remoteVideo.srcObject) {
        const stream = remoteVideo.srcObject as MediaStream;
        const hasVideoTracks = stream.getVideoTracks().length > 0;

        // Update state if video availability changed
        if (hasVideoTracks !== this.remoteVideoAvailable) {
          this.remoteVideoAvailable = hasVideoTracks;
          this.callState.remoteVideoEnabled = hasVideoTracks;

          console.log("Remote video monitoring detected change:", {
            hasVideoTracks,
            streamId: stream.id,
          });

          // Force video update
          this.updateRemoteVideo();
          this.requestUpdate();
        }
      }
    }, 1000); // Check every second
  }

  private stopRemoteVideoMonitoring(): void {
    if (this.remoteVideoCheckInterval) {
      clearInterval(this.remoteVideoCheckInterval);
      this.remoteVideoCheckInterval = null;
    }
  }

  private updateRemoteVideo(): void {
    if (this.callState.active && this.remoteVideoElement) {
      const remoteVideo = this.callManager?.getRemoteVideo();
      if (remoteVideo && remoteVideo.srcObject) {
        console.log("Updating remote video element:", {
          hasStream: !!remoteVideo.srcObject,
          videoTracks: (remoteVideo.srcObject as MediaStream)?.getVideoTracks().length || 0,
        });

        // FIXED: Ensure the video stream is properly transferred
        this.remoteVideoElement.srcObject = remoteVideo.srcObject;

        // FIXED: Force video to play and ensure it's visible
        this.remoteVideoElement.play().catch(console.error);

        // FIXED: Set video element properties
        this.remoteVideoElement.autoplay = true;
        this.remoteVideoElement.playsInline = true;
        this.remoteVideoElement.muted = false;

        // Update state if not already set
        if (!this.remoteVideoAvailable) {
          const stream = remoteVideo.srcObject as MediaStream;
          this.remoteVideoAvailable = stream.getVideoTracks().length > 0;
          this.requestUpdate();
        }
      }
    }
  }

  connectedCallback() {
    super.connectedCallback();
    if (this.config) {
      this.initializeSipClient();
    }
  }

  disconnectedCallback() {
    super.disconnectedCallback();
    this.stopRemoteVideoMonitoring();
    if (this.sipManager) {
      this.sipManager.disconnect().catch(console.error);
    }
  }

  protected render(): TemplateResult {
    if (!this.config) {
      return html`<ha-card><div class="error">Configuration required</div></ha-card>`;
    }

    return html` <ha-card> ${this.renderStatusBar()} ${this.renderError()} ${this.renderContent()} ${this.renderIncomingCallModal()} </ha-card> `;
  }

  private renderStatusBar(): TemplateResult {
    const statusClass = this.registered ? "connected" : this.connected ? "connecting" : "disconnected";
    const statusText = this.registered ? "Connected" : this.connected ? "Connecting..." : "Disconnected";

    return html`
      <div class="status-bar">
        <div class="status-indicator">
          <div class="status-dot ${statusClass}"></div>
          <span>${statusText}</span>
        </div>
        <div class="card-title">${this.config.title || "WebRTC SIP Phone"}</div>
      </div>
    `;
  }

  private renderError(): TemplateResult {
    if (!this.error) return html``;

    return html`
      <div class="error-message">
        <ha-icon icon="mdi:alert-circle"></ha-icon>
        ${this.error}
      </div>
    `;
  }

  private renderContent(): TemplateResult {
    if (this.callState.active) {
      return this.renderActiveCall();
    }

    return html` <div class="card-content">${this.renderContacts()} ${this.renderManualDial()} ${this.showKeypad ? this.renderKeypad() : ""}</div> `;
  }

  private renderContacts(): TemplateResult {
    if (!this.config.contacts.length) {
      return html`<div class="no-contacts">No contacts configured</div>`;
    }

    return html`
      <div class="contacts-section">
        <h3>Quick Dial</h3>
        <div class="contacts-grid">${this.config.contacts.map((contact) => this.renderContact(contact))}</div>
      </div>
    `;
  }

  private renderContact(contact: SIPContact): TemplateResult {
    return html`
      <button class="contact-button" @click=${() => this.callContact(contact)} ?disabled=${!this.registered}>
        <ha-icon class="contact-icon" icon=${contact.icon || "mdi:phone"}></ha-icon>
        <div class="contact-name">${contact.name}</div>
        <div class="contact-extension">${formatPhoneNumber(contact.extension)}</div>
      </button>
    `;
  }

  private renderManualDial(): TemplateResult {
    return html`
      <div class="manual-dial">
        <div class="dial-input-container">
          <ha-textfield .value=${this.currentInput} @input=${this.handleInputChange} placeholder="Enter number..." ?disabled=${!this.registered}></ha-textfield>
          <ha-icon-button @click=${this.toggleKeypad} icon="mdi:dialpad" ?disabled=${!this.registered}></ha-icon-button>
        </div>
        <div class="dial-actions">
          <ha-button @click=${this.makeCall} ?disabled=${!this.registered || !this.currentInput.trim()} class="primary">
            <ha-icon icon="mdi:phone" slot="icon"></ha-icon> Call
          </ha-button>
          <ha-button
            @click=${() => this.makeVideoCall()}
            ?disabled=${!this.registered || !this.currentInput.trim() || !this.config.video_enabled}
            class="video-call"
          >
            <ha-icon icon="mdi:video" slot="icon"></ha-icon> Video Call
          </ha-button>
          <ha-button @click=${this.clearInput} ?disabled=${!this.currentInput.length}> Clear </ha-button>
        </div>
      </div>
    `;
  }

  private renderKeypad(): TemplateResult {
    return html`
      <div class="keypad">
        ${DTMF_KEYS.flat().map((key) => html` <button class="keypad-button" @click=${() => this.handleKeypadPress(key)}>${key}</button> `)}
      </div>
    `;
  }

  private renderActiveCall(): TemplateResult {
    const isIncoming = this.callState.incoming && this.callState.status === "ringing";
    const isActive = this.callState.status === "answered";

    return html`
      <div class="active-call">
        ${this.renderCallInfo()} ${this.renderVideoStatus()} ${this.renderVideoArea()} ${isIncoming ? this.renderIncomingCallControls() : ""}
        ${isActive ? this.renderCallControls() : ""} ${isActive && !this.config.hide_keypad ? this.renderInCallKeypad() : ""}
      </div>
    `;
  }

  private renderCallInfo(): TemplateResult {
    return html`
      <div class="call-info">
        <div class="caller-name">${this.callState.callerName || "Unknown"}</div>
        <div class="caller-number">${formatPhoneNumber(this.callState.callerId || "")}</div>
        <div class="call-status">${this.getCallStatusText()}</div>
        ${this.callState.status === "answered" ? html`<div class="call-duration">${this.callDuration}</div>` : ""}
      </div>
    `;
  }

  private renderVideoStatus(): TemplateResult {
    if (!this.config.video_enabled) {
      return html``;
    }

    return html`
      <div class="video-status">
        <div class="video-indicator ${this.callState.localVideoTransmitting ? "active" : "inactive"}">
          <ha-icon icon=${this.callState.localVideoTransmitting ? "mdi:video" : "mdi:video-off"}></ha-icon>
          <span>${this.callState.localVideoTransmitting ? "Camera On" : "Camera Off"}</span>
        </div>

        <div class="video-indicator ${this.remoteVideoAvailable ? "active" : "inactive"}">
          <ha-icon icon=${this.remoteVideoAvailable ? "mdi:video" : "mdi:video-off"}></ha-icon>
          <span>${this.remoteVideoAvailable ? "Remote Video" : "No Remote Video"}</span>
        </div>
      </div>
    `;
  }

  // FIXED: Always render video area, show/hide based on availability
  private renderVideoArea(): TemplateResult {
    return html`
      <div class="video-container ${this.remoteVideoAvailable ? "has-video" : "no-video"}">
        <video id="remote-video" autoplay playsinline ?muted=${false}></video>
        ${!this.remoteVideoAvailable
          ? html`
              <div class="video-overlay">
                <ha-icon icon="mdi:video-off"></ha-icon>
                <div>No remote video</div>
              </div>
            `
          : ""}
      </div>
    `;
  }

  private renderIncomingCallControls(): TemplateResult {
    return html`
      <div class="call-controls">
        <button class="control-button primary" @click=${this.answerCall}>
          <ha-icon icon="mdi:phone"></ha-icon>
        </button>
        ${this.config.video_enabled
          ? html`
              <button class="control-button video" @click=${() => this.answerCall(true)}>
                <ha-icon icon="mdi:video"></ha-icon>
              </button>
            `
          : ""}
        <button class="control-button danger" @click=${this.rejectCall}>
          <ha-icon icon="mdi:phone-hangup"></ha-icon>
        </button>
      </div>
    `;
  }

  private renderCallControls(): TemplateResult {
    return html`
      <div class="call-controls">
        <button class="control-button ${this.callState.muted ? "danger" : "secondary"}" @click=${this.toggleMute}>
          <ha-icon icon=${this.callState.muted ? "mdi:microphone-off" : "mdi:microphone"}></ha-icon>
        </button>

        ${this.config.video_enabled
          ? html`
              <button
                class="control-button ${this.callState.localVideoTransmitting ? "primary" : "secondary"}"
                @click=${this.toggleVideo}
                title=${this.callState.localVideoTransmitting ? "Turn off camera" : "Turn on camera"}
              >
                <ha-icon icon=${this.callState.localVideoTransmitting ? "mdi:video" : "mdi:video-off"}></ha-icon>
              </button>
            `
          : ""}

        <button class="control-button ${this.callState.onHold ? "primary" : "secondary"}" @click=${this.toggleHold}>
          <ha-icon icon=${this.callState.onHold ? "mdi:play" : "mdi:pause"}></ha-icon>
        </button>

        <button class="control-button danger" @click=${this.hangupCall}>
          <ha-icon icon="mdi:phone-hangup"></ha-icon>
        </button>

        <button class="control-button secondary" @click=${() => (this.showKeypad = !this.showKeypad)}>
          <ha-icon icon="mdi:dialpad"></ha-icon>
        </button>
      </div>
    `;
  }

  private renderInCallKeypad(): TemplateResult {
    if (!this.showKeypad) return html``;

    return html`
      <div class="in-call-keypad">
        <div class="keypad">${DTMF_KEYS.flat().map((key) => html` <button class="keypad-button" @click=${() => this.sendDTMF(key)}>${key}</button> `)}</div>
      </div>
    `;
  }

  private renderIncomingCallModal(): TemplateResult {
    if (!this.callState.incoming || this.callState.status !== "ringing") {
      return html``;
    }

    return html`
      <div class="incoming-call-modal">
        <div class="incoming-call-content">
          <div class="incoming-call-avatar">
            <ha-icon icon="mdi:account"></ha-icon>
          </div>
          <div class="caller-name">${this.callState.callerName || "Unknown Caller"}</div>
          <div class="caller-number">${formatPhoneNumber(this.callState.callerId || "")}</div>
          <div class="incoming-call-actions">
            <button class="answer-button" @click=${this.answerCall}>
              <ha-icon icon="mdi:phone"></ha-icon>
            </button>
            ${this.config.video_enabled
              ? html`
                  <button class="video-answer-button" @click=${() => this.answerCall(true)}>
                    <ha-icon icon="mdi:video"></ha-icon>
                  </button>
                `
              : ""}
            <button class="reject-button" @click=${this.rejectCall}>
              <ha-icon icon="mdi:phone-hangup"></ha-icon>
            </button>
          </div>
        </div>
      </div>
    `;
  }

  private getCallStatusText(): string {
    switch (this.callState.status) {
      case "connecting":
        return "Connecting...";
      case "ringing":
        return this.callState.incoming ? "Incoming call" : "Ringing...";
      case "answered":
        return this.callState.onHold ? "On hold" : "Connected";
      case "ended":
        return "Call ended";
      case "error":
        return "Call failed";
      default:
        return "";
    }
  }

  // Event handlers
  private handleInputChange(event: Event): void {
    const target = event.target as HTMLInputElement;
    this.currentInput = sanitizeExtension(target.value);
  }

  private handleKeypadPress(key: string): void {
    this.currentInput += key;
    this.requestUpdate();
  }

  private toggleKeypad(): void {
    this.showKeypad = !this.showKeypad;
  }

  private clearInput(): void {
    this.currentInput = "";
  }

  private async callContact(contact: SIPContact): Promise<void> {
    if (!this.callManager || !this.registered) return;

    try {
      await this.callManager.makeCall(contact.extension);
    } catch (error) {
      console.error("Failed to call contact:", error);
      this.error = `Failed to call ${contact.name}`;
    }
  }

  private async makeCall(): Promise<void> {
    if (!this.callManager || !this.registered || !this.currentInput.trim()) return;

    try {
      await this.callManager.makeCall(this.currentInput.trim());
      this.currentInput = "";
      this.showKeypad = false;
    } catch (error) {
      console.error("Failed to make call:", error);
      this.error = "Failed to make call";
    }
  }

  private async makeVideoCall(): Promise<void> {
    if (!this.callManager || !this.registered || !this.currentInput.trim()) return;

    try {
      await this.callManager.makeCall(this.currentInput.trim(), true);
      this.currentInput = "";
      this.showKeypad = false;
    } catch (error) {
      console.error("Failed to make video call:", error);
      this.error = "Failed to make video call";
    }
  }

  private async answerCall(withVideo = false): Promise<void> {
    if (!this.callManager) return;

    try {
      if (withVideo && this.config.video_enabled) {
        await this.callManager.enableVideo();
      }
      await this.callManager.answerCall();
    } catch (error) {
      console.error("Failed to answer call:", error);
      this.error = "Failed to answer call";
    }
  }

  private async rejectCall(): Promise<void> {
    if (!this.callManager) return;

    try {
      await this.callManager.rejectCall();
    } catch (error) {
      console.error("Failed to reject call:", error);
    }
  }

  private async hangupCall(): Promise<void> {
    if (!this.callManager) return;

    try {
      await this.callManager.hangupCall();
      this.showKeypad = false;
    } catch (error) {
      console.error("Failed to hangup call:", error);
    }
  }

  private async toggleMute(): Promise<void> {
    if (!this.callManager) return;

    try {
      await this.callManager.toggleMute();
    } catch (error) {
      console.error("Failed to toggle mute:", error);
      this.error = "Failed to toggle mute";
    }
  }

  private async toggleVideo(): Promise<void> {
    if (!this.callManager) return;

    try {
      await this.callManager.toggleVideo();
    } catch (error) {
      console.error("Toggle video failed:", error);
      this.error = "Failed to toggle video";
    }
  }

  private async toggleHold(): Promise<void> {
    if (!this.callManager) return;

    try {
      if (this.callState.onHold) {
        await this.callManager.unholdCall();
      } else {
        await this.callManager.holdCall();
      }
    } catch (error) {
      console.error("Failed to toggle hold:", error);
      this.error = "Failed to toggle hold";
    }
  }

  private sendDTMF(tone: string): void {
    if (!this.callManager) return;
    this.callManager.sendDTMF(tone);
  }

  static get styles(): CSSResultGroup {
    return [
      sharedStyles,
      css`
        .card-title {
          font-weight: 500;
          font-size: 16px;
        }

        .no-contacts {
          text-align: center;
          color: var(--sip-text-secondary-color);
          padding: 32px;
          font-style: italic;
        }

        .contacts-section h3 {
          margin: 0 0 16px 0;
          font-size: 18px;
          font-weight: 500;
        }

        .manual-dial {
          margin-top: 24px;
          padding-top: 24px;
          border-top: 1px solid var(--sip-divider-color);
        }

        .dial-input-container {
          display: flex;
          gap: 8px;
          margin-bottom: 16px;
        }

        .dial-input-container ha-textfield {
          flex: 1;
        }

        .dial-actions {
          display: flex;
          gap: 12px;
          justify-content: center;
          flex-wrap: wrap;
        }

        .active-call {
          padding: 16px;
        }

        .call-status {
          font-size: 14px;
          color: var(--sip-text-secondary-color);
          margin-bottom: 8px;
        }

        .in-call-keypad {
          margin-top: 16px;
          padding-top: 16px;
          border-top: 1px solid var(--sip-divider-color);
        }

        /* FIXED: Video container with states */
        .video-container {
          position: relative;
          width: 100%;
          height: 240px;
          background: #000;
          border-radius: 12px;
          overflow: hidden;
          margin-bottom: 16px;
          display: flex;
          align-items: center;
          justify-content: center;
        }

        .video-container video {
          width: 100%;
          height: 100%;
          object-fit: contain;
          background: #000;
          border-radius: 12px;
        }

        /* Show video when available */
        .video-container.has-video video {
          opacity: 1;
        }

        /* Hide video when not available */
        .video-container.no-video video {
          opacity: 0;
        }

        .video-overlay {
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          text-align: center;
          color: var(--primary-text-color);
          opacity: 0.7;
        }

        .video-overlay ha-icon {
          font-size: 48px;
          margin-bottom: 8px;
        }

        /* FIXED: Video status with remote video indicator */
        .video-status {
          display: flex;
          justify-content: center;
          gap: 16px;
          padding: 8px 16px;
          background: var(--secondary-background-color);
          border-radius: 8px;
          margin-bottom: 16px;
        }

        .video-indicator {
          display: flex;
          align-items: center;
          gap: 8px;
          padding: 4px 12px;
          border-radius: 16px;
          font-size: 12px;
          font-weight: 500;
          transition: all 0.2s ease;
        }

        .video-indicator.active {
          background: rgba(var(--success-color-rgb, 76, 175, 80), 0.1);
          color: var(--success-color, #4caf50);
        }

        .video-indicator.active ha-icon {
          color: var(--success-color, #4caf50);
        }

        .video-indicator.inactive {
          background: rgba(var(--disabled-text-color-rgb, 128, 128, 128), 0.1);
          color: var(--disabled-text-color, #808080);
        }

        .video-indicator.inactive ha-icon {
          color: var(--disabled-text-color, #808080);
        }

        /* Call controls enhancements */
        .control-button.primary {
          background: var(--sip-success-color);
          color: white;
        }

        .control-button.video {
          background: var(--primary-color);
          color: white;
        }

        .control-button.secondary {
          background: var(--secondary-background-color);
          color: var(--primary-text-color);
        }

        .control-button.danger {
          background: var(--sip-danger-color);
          color: white;
        }

        /* Incoming call modal enhancements */
        .incoming-call-actions {
          display: flex;
          justify-content: center;
          gap: 24px;
        }

        .video-answer-button {
          background: var(--primary-color);
          border: none;
          border-radius: 50%;
          width: 64px;
          height: 64px;
          color: white;
          font-size: 24px;
          cursor: pointer;
          transition: all 0.2s ease;
        }

        .video-answer-button:hover {
          transform: scale(1.1);
        }

        ha-button.primary {
          --mdc-theme-primary: var(--sip-success-color);
        }

        ha-button.video-call {
          --mdc-theme-primary: var(--primary-color);
        }

        ha-textfield {
          width: 100%;
        }

        ha-icon-button {
          --mdc-icon-button-size: 40px;
        }

        /* Responsive video container */
        @media (max-width: 600px) {
          .video-container {
            height: 200px;
          }
        }

        @media (max-width: 400px) {
          .video-container {
            height: 160px;
          }
        }
      `,
    ];
  }
}

declare global {
  interface HTMLElementTagNameMap {
    "ha-webrtc-sip-card": WebRTCSipCard;
  }
}

// Register the card with Home Assistant
(window as any).customCards = (window as any).customCards || [];
(window as any).customCards.push({
  type: "ha-webrtc-sip-card",
  name: "WebRTC SIP Card",
  description: "A modern WebRTC SIP client card for Home Assistant",
  version: CARD_VERSION,
});

console.info(
  `%c HA-WEBRTC-SIP-CARD %c ${CARD_VERSION} `,
  "color: white; background: #03a9f4; font-weight: bold;",
  "color: #03a9f4; background: white; font-weight: bold;"
);

---

=== Object: d82e5946448c9d216055d23dfa139eaadc491f3c | Date: 2025-09-22 13:08:05 | Type: blob ===

import { LitElement, html, css, type CSSResultGroup, type TemplateResult } from "lit";
import { customElement, property, state, query } from "lit/decorators.js";
import type { HomeAssistant, SIPCardConfig, SIPContact } from "./types";
import { SipManager, type SipConfig } from "./sip-manager";
import { CallManager, type CallState } from "./call-manager";
import { sharedStyles } from "./styles";
import { CARD_VERSION, DEFAULT_CONFIG, DTMF_KEYS } from "./constants";
import { mergeConfig, validateConfig, formatPhoneNumber, sanitizeExtension } from "./utils";

@customElement("ha-webrtc-sip-card")
export class WebRTCSipCard extends LitElement {
  @property({ attribute: false }) public hass!: HomeAssistant;
  @state() private config!: SIPCardConfig;
  @state() private connected = false;
  @state() private registered = false;
  @state() private error: string | null = null;
  @state() private callState!: CallState;
  @state() private showKeypad = false;
  @state() private currentInput = "";

  @query("#remote-video") private remoteVideoElement?: HTMLVideoElement;

  private sipManager: SipManager | null = null;
  private callManager: CallManager | null = null;

  public static getConfigElement() {
    return document.createElement("ha-webrtc-sip-card-editor");
  }

  public static getStubConfig(): SIPCardConfig {
    return { ...DEFAULT_CONFIG };
  }

  public setConfig(config: SIPCardConfig): void {
    try {
      validateConfig(config);
      this.config = mergeConfig(config);
      this.initializeSipClient();
    } catch (error) {
      this.error = error instanceof Error ? error.message : "Invalid configuration";
      throw new Error(this.error);
    }
  }

  public getCardSize(): number {
    return this.callState && this.callState.active ? 6 : 4;
  }

  private async initializeSipClient(): Promise<void> {
    try {
      // Cleanup existing connections
      if (this.sipManager) {
        await this.sipManager.disconnect();
      }

      this.error = null;
      this.connected = false;
      this.registered = false;

      const sipConfig: SipConfig = {
        server: this.config.server_url.replace(/^wss?:\/\//, "").replace(/:\d+$/, ""),
        username: this.config.username,
        password: this.config.password,
        domain: this.config.domain || this.config.server_url.replace(/^wss?:\/\//, "").replace(/:\d+$/, ""),
        websocket_port: this.config.websocket_port ? Number(this.config.websocket_port) : this.config.server_url.includes("wss://") ? 443 : 80,
        use_secure: this.config.server_url.startsWith("wss://"),
        display_name: this.config.display_name,
        debug: this.config.debug,
      };

      this.sipManager = new SipManager();
      this.callManager = new CallManager(this.sipManager, this.config.contacts);

      // Setup event handlers
      this.setupEventHandlers();

      // Initialize call state
      this.callState = this.callManager.getCallState();

      await this.sipManager.initialize(sipConfig);
    } catch (error) {
      this.error = error instanceof Error ? error.message : "Configuration failed";
      this.connected = false;
      this.registered = false;
      console.error("SIP initialization failed:", error);
    }
  }

  private setupEventHandlers(): void {
    if (!this.sipManager || !this.callManager) return;

    // SIP connection events
    this.sipManager.addEventListener("connected", () => {
      this.connected = true;
      this.requestUpdate();
    });

    this.sipManager.addEventListener("disconnected", () => {
      this.connected = false;
      this.registered = false;
      this.requestUpdate();
    });

    this.sipManager.addEventListener("registered", (event: any) => {
      this.registered = event.detail.registered;
      if (this.registered) {
        this.error = null;
      }
      this.requestUpdate();
    });

    this.sipManager.addEventListener("error", (event: any) => {
      this.error = event.detail.error;
      this.connected = false;
      this.registered = false;
      this.requestUpdate();
    });

    // Local video state events
    this.sipManager.addEventListener("localVideoChanged", (event: any) => {
      // Update call state when local video changes
      this.callState = this.callManager?.getCallState() || this.callState;
      this.requestUpdate();
    });

    // Call state events
    this.callManager.addEventListener("callStateChanged", (event: any) => {
      this.callState = event.detail.callState;
      this.updateRemoteVideo();
      this.requestUpdate();
    });
  }

  private updateRemoteVideo(): void {
    if (this.callState.active && this.remoteVideoElement) {
      const remoteVideo = this.callManager?.getRemoteVideo();
      if (remoteVideo && remoteVideo.srcObject) {
        this.remoteVideoElement.srcObject = remoteVideo.srcObject;
      }
    }
  }

  connectedCallback() {
    super.connectedCallback();
    if (this.config) {
      this.initializeSipClient();
    }
  }

  disconnectedCallback() {
    super.disconnectedCallback();
    if (this.sipManager) {
      this.sipManager.disconnect().catch(console.error);
    }
  }

  protected render(): TemplateResult {
    if (!this.config) {
      return html`<ha-card><div class="error">Configuration required</div></ha-card>`;
    }

    return html` <ha-card> ${this.renderStatusBar()} ${this.renderError()} ${this.renderContent()} ${this.renderIncomingCallModal()} </ha-card> `;
  }

  private renderStatusBar(): TemplateResult {
    const statusClass = this.registered ? "connected" : this.connected ? "connecting" : "disconnected";
    const statusText = this.registered ? "Connected" : this.connected ? "Connecting..." : "Disconnected";

    return html`
      <div class="status-bar">
        <div class="status-indicator">
          <div class="status-dot ${statusClass}"></div>
          <span>${statusText}</span>
        </div>
        <div class="card-title">${this.config.title || "WebRTC SIP Phone"}</div>
      </div>
    `;
  }

  private renderError(): TemplateResult {
    if (!this.error) return html``;

    return html`
      <div class="error-message">
        <ha-icon icon="mdi:alert-circle"></ha-icon>
        ${this.error}
      </div>
    `;
  }

  private renderContent(): TemplateResult {
    if (this.callState.active) {
      return this.renderActiveCall();
    }

    return html` <div class="card-content">${this.renderContacts()} ${this.renderManualDial()} ${this.showKeypad ? this.renderKeypad() : ""}</div> `;
  }

  private renderContacts(): TemplateResult {
    if (!this.config.contacts.length) {
      return html`<div class="no-contacts">No contacts configured</div>`;
    }

    return html`
      <div class="contacts-section">
        <h3>Quick Dial</h3>
        <div class="contacts-grid">${this.config.contacts.map((contact) => this.renderContact(contact))}</div>
      </div>
    `;
  }

  private renderContact(contact: SIPContact): TemplateResult {
    return html`
      <button class="contact-button" @click=${() => this.callContact(contact)} ?disabled=${!this.registered}>
        <ha-icon class="contact-icon" icon=${contact.icon || "mdi:phone"}></ha-icon>
        <div class="contact-name">${contact.name}</div>
        <div class="contact-extension">${formatPhoneNumber(contact.extension)}</div>
      </button>
    `;
  }

  private renderManualDial(): TemplateResult {
    return html`
      <div class="manual-dial">
        <div class="dial-input-container">
          <ha-textfield .value=${this.currentInput} @input=${this.handleInputChange} placeholder="Enter number..." ?disabled=${!this.registered}></ha-textfield>
          <ha-icon-button @click=${this.toggleKeypad} icon="mdi:dialpad" ?disabled=${!this.registered}></ha-icon-button>
        </div>
        <div class="dial-actions">
          <ha-button @click=${this.makeCall} ?disabled=${!this.registered || !this.currentInput.trim()} class="primary">
            <ha-icon icon="mdi:phone" slot="icon"></ha-icon> Call
          </ha-button>
          <ha-button
            @click=${() => this.makeVideoCall()}
            ?disabled=${!this.registered || !this.currentInput.trim() || !this.config.video_enabled}
            class="video-call"
          >
            <ha-icon icon="mdi:video" slot="icon"></ha-icon> Video Call
          </ha-button>
          <ha-button @click=${this.clearInput} ?disabled=${!this.currentInput.length}> Clear </ha-button>
        </div>
      </div>
    `;
  }

  private renderKeypad(): TemplateResult {
    return html`
      <div class="keypad">
        ${DTMF_KEYS.flat().map((key) => html` <button class="keypad-button" @click=${() => this.handleKeypadPress(key)}>${key}</button> `)}
      </div>
    `;
  }

  private renderActiveCall(): TemplateResult {
    const isIncoming = this.callState.incoming && this.callState.status === "ringing";
    const isActive = this.callState.status === "answered";

    return html`
      <div class="active-call">
        ${this.renderCallInfo()} ${this.renderVideoStatus()} ${this.callState.remoteVideoEnabled ? this.renderVideoArea() : ""}
        ${isIncoming ? this.renderIncomingCallControls() : ""} ${isActive ? this.renderCallControls() : ""}
        ${isActive && !this.config.hide_keypad ? this.renderInCallKeypad() : ""}
      </div>
    `;
  }

  private renderCallInfo(): TemplateResult {
    // Force update the duration by accessing it directly
    const duration = this.callManager?.getFormattedDuration() || "00:00";

    return html`
      <div class="call-info">
        <div class="caller-name">${this.callState.callerName || "Unknown"}</div>
        <div class="caller-number">${formatPhoneNumber(this.callState.callerId || "")}</div>
        <div class="call-status">${this.getCallStatusText()}</div>
        ${this.callState.status === "answered" ? html`<div class="call-duration">${duration}</div>` : ""}
      </div>
    `;
  }

  // NEW: Video status indicator
  private renderVideoStatus(): TemplateResult {
    if (!this.config.video_enabled) {
      return html``;
    }

    return html`
      <div class="video-status">
        <div class="video-indicator ${this.callState.localVideoTransmitting ? "active" : "inactive"}">
          <ha-icon icon=${this.callState.localVideoTransmitting ? "mdi:video" : "mdi:video-off"}></ha-icon>
          <span>${this.callState.localVideoTransmitting ? "Camera On" : "Camera Off"}</span>
        </div>
      </div>
    `;
  }

  private renderVideoArea(): TemplateResult {
    return html`
      <div class="video-container letterbox">
        <video id="remote-video" autoplay playsinline ?muted=${false}></video>
        ${!this.callState.remoteVideoEnabled
          ? html`
              <div class="video-overlay">
                <ha-icon icon="mdi:video-off"></ha-icon>
                <div>No remote video</div>
              </div>
            `
          : ""}
      </div>
    `;
  }

  private renderIncomingCallControls(): TemplateResult {
    return html`
      <div class="call-controls">
        <button class="control-button primary" @click=${this.answerCall}>
          <ha-icon icon="mdi:phone"></ha-icon>
        </button>
        ${this.config.video_enabled
          ? html`
              <button class="control-button video" @click=${() => this.answerCall(true)}>
                <ha-icon icon="mdi:video"></ha-icon>
              </button>
            `
          : ""}
        <button class="control-button danger" @click=${this.rejectCall}>
          <ha-icon icon="mdi:phone-hangup"></ha-icon>
        </button>
      </div>
    `;
  }

  private renderCallControls(): TemplateResult {
    return html`
      <div class="call-controls">
        <button class="control-button ${this.callState.muted ? "danger" : "secondary"}" @click=${this.toggleMute}>
          <ha-icon icon=${this.callState.muted ? "mdi:microphone-off" : "mdi:microphone"}></ha-icon>
        </button>

        ${this.config.video_enabled
          ? html`
              <button
                class="control-button ${this.callState.localVideoTransmitting ? "primary" : "secondary"}"
                @click=${this.toggleVideo}
                title=${this.callState.localVideoTransmitting ? "Turn off camera" : "Turn on camera"}
              >
                <ha-icon icon=${this.callState.localVideoTransmitting ? "mdi:video" : "mdi:video-off"}></ha-icon>
              </button>
            `
          : ""}

        <button class="control-button ${this.callState.onHold ? "primary" : "secondary"}" @click=${this.toggleHold}>
          <ha-icon icon=${this.callState.onHold ? "mdi:play" : "mdi:pause"}></ha-icon>
        </button>

        <button class="control-button danger" @click=${this.hangupCall}>
          <ha-icon icon="mdi:phone-hangup"></ha-icon>
        </button>

        <button class="control-button secondary" @click=${() => (this.showKeypad = !this.showKeypad)}>
          <ha-icon icon="mdi:dialpad"></ha-icon>
        </button>
      </div>
    `;
  }

  private renderInCallKeypad(): TemplateResult {
    if (!this.showKeypad) return html``;

    return html`
      <div class="in-call-keypad">
        <div class="keypad">${DTMF_KEYS.flat().map((key) => html` <button class="keypad-button" @click=${() => this.sendDTMF(key)}>${key}</button> `)}</div>
      </div>
    `;
  }

  private renderIncomingCallModal(): TemplateResult {
    if (!this.callState.incoming || this.callState.status !== "ringing") {
      return html``;
    }

    return html`
      <div class="incoming-call-modal">
        <div class="incoming-call-content">
          <div class="incoming-call-avatar">
            <ha-icon icon="mdi:account"></ha-icon>
          </div>
          <div class="caller-name">${this.callState.callerName || "Unknown Caller"}</div>
          <div class="caller-number">${formatPhoneNumber(this.callState.callerId || "")}</div>
          <div class="incoming-call-actions">
            <button class="answer-button" @click=${this.answerCall}>
              <ha-icon icon="mdi:phone"></ha-icon>
            </button>
            ${this.config.video_enabled
              ? html`
                  <button class="video-answer-button" @click=${() => this.answerCall(true)}>
                    <ha-icon icon="mdi:video"></ha-icon>
                  </button>
                `
              : ""}
            <button class="reject-button" @click=${this.rejectCall}>
              <ha-icon icon="mdi:phone-hangup"></ha-icon>
            </button>
          </div>
        </div>
      </div>
    `;
  }

  private getCallStatusText(): string {
    switch (this.callState.status) {
      case "connecting":
        return "Connecting...";
      case "ringing":
        return this.callState.incoming ? "Incoming call" : "Ringing...";
      case "answered":
        return this.callState.onHold ? "On hold" : "Connected";
      case "ended":
        return "Call ended";
      case "error":
        return "Call failed";
      default:
        return "";
    }
  }

  // Event handlers
  private handleInputChange(event: Event): void {
    const target = event.target as HTMLInputElement;
    this.currentInput = sanitizeExtension(target.value);
  }

  private handleKeypadPress(key: string): void {
    this.currentInput += key;
    this.requestUpdate();
  }

  private toggleKeypad(): void {
    this.showKeypad = !this.showKeypad;
  }

  private clearInput(): void {
    this.currentInput = "";
  }

  private async callContact(contact: SIPContact): Promise<void> {
    if (!this.callManager || !this.registered) return;

    try {
      await this.callManager.makeCall(contact.extension);
    } catch (error) {
      console.error("Failed to call contact:", error);
      this.error = `Failed to call ${contact.name}`;
    }
  }

  private async makeCall(): Promise<void> {
    if (!this.callManager || !this.registered || !this.currentInput.trim()) return;

    try {
      await this.callManager.makeCall(this.currentInput.trim());
      this.currentInput = "";
      this.showKeypad = false;
    } catch (error) {
      console.error("Failed to make call:", error);
      this.error = "Failed to make call";
    }
  }

  // NEW: Video call method
  private async makeVideoCall(): Promise<void> {
    if (!this.callManager || !this.registered || !this.currentInput.trim()) return;

    try {
      await this.callManager.makeCall(this.currentInput.trim(), true); // Include video
      this.currentInput = "";
      this.showKeypad = false;
    } catch (error) {
      console.error("Failed to make video call:", error);
      this.error = "Failed to make video call";
    }
  }

  private async answerCall(withVideo = false): Promise<void> {
    if (!this.callManager) return;

    try {
      if (withVideo && this.config.video_enabled) {
        // Enable video before answering
        await this.callManager.enableVideo();
      }
      await this.callManager.answerCall();
    } catch (error) {
      console.error("Failed to answer call:", error);
      this.error = "Failed to answer call";
    }
  }

  private async rejectCall(): Promise<void> {
    if (!this.callManager) return;

    try {
      await this.callManager.rejectCall();
    } catch (error) {
      console.error("Failed to reject call:", error);
    }
  }

  private async hangupCall(): Promise<void> {
    if (!this.callManager) return;

    try {
      await this.callManager.hangupCall();
      this.showKeypad = false;
    } catch (error) {
      console.error("Failed to hangup call:", error);
    }
  }

  private async toggleMute(): Promise<void> {
    if (!this.callManager) return;

    try {
      await this.callManager.toggleMute();
    } catch (error) {
      console.error("Failed to toggle mute:", error);
      this.error = "Failed to toggle mute";
    }
  }

  // NEW: Video toggle method
  private async toggleVideo(): Promise<void> {
    if (!this.callManager) return;

    try {
      await this.callManager.toggleVideo();
    } catch (error) {
      console.error("Toggle video failed:", error);
      this.error = "Failed to toggle video";
    }
  }

  private async toggleHold(): Promise<void> {
    if (!this.callManager) return;

    try {
      if (this.callState.onHold) {
        await this.callManager.unholdCall();
      } else {
        await this.callManager.holdCall();
      }
    } catch (error) {
      console.error("Failed to toggle hold:", error);
      this.error = "Failed to toggle hold";
    }
  }

  private sendDTMF(tone: string): void {
    if (!this.callManager) return;
    this.callManager.sendDTMF(tone);
  }

  static get styles(): CSSResultGroup {
    return [
      sharedStyles,
      css`
        .card-title {
          font-weight: 500;
          font-size: 16px;
        }

        .no-contacts {
          text-align: center;
          color: var(--sip-text-secondary-color);
          padding: 32px;
          font-style: italic;
        }

        .contacts-section h3 {
          margin: 0 0 16px 0;
          font-size: 18px;
          font-weight: 500;
        }

        .manual-dial {
          margin-top: 24px;
          padding-top: 24px;
          border-top: 1px solid var(--sip-divider-color);
        }

        .dial-input-container {
          display: flex;
          gap: 8px;
          margin-bottom: 16px;
        }

        .dial-input-container ha-textfield {
          flex: 1;
        }

        .dial-actions {
          display: flex;
          gap: 12px;
          justify-content: center;
          flex-wrap: wrap;
        }

        .active-call {
          padding: 16px;
        }

        .call-status {
          font-size: 14px;
          color: var(--sip-text-secondary-color);
          margin-bottom: 8px;
        }

        .in-call-keypad {
          margin-top: 16px;
          padding-top: 16px;
          border-top: 1px solid var(--sip-divider-color);
        }

        /* Video container styles - FIXED FOR NO CROPPING */
        .video-container {
          position: relative;
          width: 100%;
          height: 240px; /* Fixed height */
          background: #000;
          border-radius: 12px;
          overflow: hidden;
          margin-bottom: 16px;
          display: flex;
          align-items: center;
          justify-content: center;
        }

        .video-container video {
          width: 100%;
          height: 100%;
          object-fit: contain; /* CHANGED FROM cover TO contain - shows full video without cropping */
          background: #000;
          border-radius: 12px;
        }

        /* Alternative: If you want to fill container but maintain aspect ratio */
        .video-container.fill video {
          object-fit: cover; /* Fills container but may crop */
        }

        /* Alternative: If you want letterbox/pillarbox effect */
        .video-container.letterbox {
          background: #1a1a1a;
        }

        .video-container.letterbox video {
          object-fit: contain;
          background: transparent;
        }

        .video-overlay {
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          text-align: center;
          color: var(--primary-text-color);
          opacity: 0.7;
        }

        .video-overlay ha-icon {
          font-size: 48px;
          margin-bottom: 8px;
        }

        /* Video status styles */
        .video-status {
          display: flex;
          justify-content: center;
          padding: 8px 16px;
          background: var(--secondary-background-color);
          border-radius: 8px;
          margin-bottom: 16px;
        }

        .video-indicator {
          display: flex;
          align-items: center;
          gap: 8px;
          padding: 4px 12px;
          border-radius: 16px;
          font-size: 12px;
          font-weight: 500;
          transition: all 0.2s ease;
        }

        .video-indicator.active {
          background: rgba(var(--success-color-rgb, 76, 175, 80), 0.1);
          color: var(--success-color, #4caf50);
        }

        .video-indicator.active ha-icon {
          color: var(--success-color, #4caf50);
        }

        .video-indicator.inactive {
          background: rgba(var(--disabled-text-color-rgb, 128, 128, 128), 0.1);
          color: var(--disabled-text-color, #808080);
        }

        .video-indicator.inactive ha-icon {
          color: var(--disabled-text-color, #808080);
        }

        /* Call controls enhancements */
        .control-button.primary {
          background: var(--sip-success-color);
          color: white;
        }

        .control-button.video {
          background: var(--primary-color);
          color: white;
        }

        .control-button.secondary {
          background: var(--secondary-background-color);
          color: var(--primary-text-color);
        }

        .control-button.danger {
          background: var(--sip-danger-color);
          color: white;
        }

        /* Incoming call modal enhancements */
        .incoming-call-actions {
          display: flex;
          justify-content: center;
          gap: 24px;
        }

        .video-answer-button {
          background: var(--primary-color);
          border: none;
          border-radius: 50%;
          width: 64px;
          height: 64px;
          color: white;
          font-size: 24px;
          cursor: pointer;
          transition: all 0.2s ease;
        }

        .video-answer-button:hover {
          transform: scale(1.1);
        }

        ha-button.primary {
          --mdc-theme-primary: var(--sip-success-color);
        }

        ha-button.video-call {
          --mdc-theme-primary: var(--primary-color);
        }

        ha-textfield {
          width: 100%;
        }

        ha-icon-button {
          --mdc-icon-button-size: 40px;
        }

        /* Responsive video container */
        @media (max-width: 600px) {
          .video-container {
            height: 200px;
          }
        }

        @media (max-width: 400px) {
          .video-container {
            height: 160px;
          }
        }
      `,
    ];
  }
}

declare global {
  interface HTMLElementTagNameMap {
    "ha-webrtc-sip-card": WebRTCSipCard;
  }
}

// Register the card with Home Assistant
(window as any).customCards = (window as any).customCards || [];
(window as any).customCards.push({
  type: "ha-webrtc-sip-card",
  name: "WebRTC SIP Card",
  description: "A modern WebRTC SIP client card for Home Assistant",
  version: CARD_VERSION,
});

console.info(
  `%c HA-WEBRTC-SIP-CARD %c ${CARD_VERSION} `,
  "color: white; background: #03a9f4; font-weight: bold;",
  "color: #03a9f4; background: white; font-weight: bold;"
);

---

=== Object: 9edb7f2c88a22b1da2db028024e7c85cae88b31a | Date: 2025-09-22 13:08:05 | Type: blob ===

import type { CallInfo } from "./sip-manager";
import { SipManager } from "./sip-manager";
import { formatDuration, playRingtone, stopRingtone, getContactByExtension } from "./utils";
import type { SIPContact } from "./types";

export interface CallState {
  active: boolean;
  incoming: boolean;
  outgoing: boolean;
  onHold: boolean;
  muted: boolean;
  remoteVideoEnabled: boolean;
  localVideoTransmitting: boolean;
  callerId?: string;
  callerName?: string;
  duration: number;
  status: "idle" | "connecting" | "ringing" | "answered" | "held" | "ended" | "error";
}

export class CallManager extends EventTarget {
  private sipManager: SipManager;
  private callState: CallState;
  private ringtone: HTMLAudioElement | null = null;
  private ringTimeout: number | null = null;
  private contacts: SIPContact[] = [];

  constructor(sipManager: SipManager, contacts: SIPContact[] = []) {
    super();
    this.sipManager = sipManager;
    this.contacts = contacts;
    this.callState = this.getInitialState();
    this.setupSipEventHandlers();
  }

  /**
   * Update the contacts list for caller ID lookup
   */
  public updateContacts(contacts: SIPContact[]): void {
    this.contacts = contacts;
  }

  private getInitialState(): CallState {
    return {
      active: false,
      incoming: false,
      outgoing: false,
      onHold: false,
      muted: false,
      remoteVideoEnabled: false,
      localVideoTransmitting: false,
      duration: 0,
      status: "idle",
    };
  }

  private setupSipEventHandlers(): void {
    this.sipManager.addEventListener("incomingCall", this.handleIncomingCall.bind(this) as EventListener);
    this.sipManager.addEventListener("callStarted", this.handleCallStarted.bind(this) as EventListener);
    this.sipManager.addEventListener("callAnswered", this.handleCallAnswered.bind(this) as EventListener);
    this.sipManager.addEventListener("callEnded", this.handleCallEnded.bind(this) as EventListener);
    this.sipManager.addEventListener("callFailed", this.handleCallFailed.bind(this) as EventListener);
    this.sipManager.addEventListener("localVideoChanged", this.handleLocalVideoChanged.bind(this) as EventListener);
    this.sipManager.addEventListener("remoteVideoChanged", this.handleRemoteVideoChanged.bind(this) as EventListener);
    this.sipManager.addEventListener("callTimer", this.handleCallTimer.bind(this) as EventListener);
    this.sipManager.addEventListener("callHold", this.handleCallHold.bind(this) as EventListener);
  }

  /**
   * Clean up extension to extract the numeric part
   * @param rawExtension - The raw extension from SIP (e.g., "1012-screen", "Extension 1012", "1012")
   * @returns Clean extension number (e.g., "1012")
   */
  private cleanExtension(rawExtension: string): string {
    if (!rawExtension || rawExtension === "unknown") return rawExtension;

    // Remove common prefixes like "Extension "
    let cleaned = rawExtension.replace(/^Extension\s+/i, "");

    // Remove common suffixes like "-screen", "-web", "-mobile", etc.
    cleaned = cleaned.replace(/-screen$|-web$|-mobile$|-phone$/i, "");

    // Extract numeric part if it contains numbers
    const numericMatch = cleaned.match(/(\d+)/);
    if (numericMatch) {
      return numericMatch[1];
    }

    // If no numeric part found, return the cleaned version
    return cleaned;
  }

  /**
   * Clean up display name to remove redundant words
   * @param displayName - The display name from SIP
   * @param extension - The clean extension number
   * @returns Cleaned display name
   */
  private cleanDisplayName(displayName: string, extension: string): string {
    if (!displayName || displayName === "unknown" || displayName === "Unknown Caller") {
      return extension;
    }

    // Remove "Extension " prefix and the extension number itself
    let cleaned = displayName.replace(/^Extension\s+/i, "");
    cleaned = cleaned.replace(new RegExp(`\\b${extension}\\b`, "g"), "").trim();

    // If nothing meaningful left, use extension
    if (!cleaned || cleaned === extension) {
      return extension;
    }

    return cleaned;
  }

  private handleIncomingCall(event: CustomEvent): void {
    const { from, displayName, callInfo } = event.detail;

    // Clean up the extension to get just the number
    const cleanedExtension = this.cleanExtension(from);

    // Clean up the display name
    const cleanedDisplayName = this.cleanDisplayName(displayName, cleanedExtension);

    // Try to find contact by the cleaned extension
    const contact = this.contacts ? getContactByExtension(this.contacts, cleanedExtension) : null;

    // Use contact name if found, otherwise use cleaned display name
    const finalCallerName = contact ? contact.name : cleanedDisplayName;

    this.callState = {
      ...this.callState,
      active: true,
      incoming: true,
      outgoing: false,
      callerId: cleanedExtension, // Show clean extension (e.g., "1012")
      callerName: finalCallerName, // Show contact name (e.g., "Kid") or cleaned display
      status: "ringing",
    };

    // Start ringtone
    this.ringtone = playRingtone();

    // Auto-reject after timeout (configurable)
    this.ringTimeout = window.setTimeout(() => {
      this.rejectCall();
    }, 30000); // 30 seconds default

    this.dispatchCallStateUpdate();
  }

  private handleCallStarted(event: CustomEvent): void {
    const { target } = event.detail;

    // Clean up the extension for outgoing calls too
    const cleanedExtension = this.cleanExtension(target);

    // Try to find contact by extension for outgoing calls
    const contact = this.contacts ? getContactByExtension(this.contacts, cleanedExtension) : null;
    const finalCallerName = contact ? contact.name : cleanedExtension;

    this.callState = {
      ...this.callState,
      active: true,
      incoming: false,
      outgoing: true,
      callerId: cleanedExtension,
      callerName: finalCallerName,
      status: "connecting",
    };

    this.dispatchCallStateUpdate();
  }

  private handleCallAnswered(_event: CustomEvent): void {
    this.stopRinging();

    this.callState = {
      ...this.callState,
      status: "answered",
      incoming: false,
      outgoing: false,
    };

    // Check if remote video is available
    const remoteVideo = this.sipManager.getRemoteVideo();
    if (remoteVideo && remoteVideo.srcObject) {
      const stream = remoteVideo.srcObject as MediaStream;
      this.callState.remoteVideoEnabled = stream.getVideoTracks().length > 0;
    }

    this.dispatchCallStateUpdate();
  }

  private handleCallEnded(_event: CustomEvent): void {
    this.stopRinging();
    this.clearRingTimeout();

    this.callState = this.getInitialState();
    this.callState.status = "ended";

    this.dispatchCallStateUpdate();

    // Reset to idle after a brief moment
    setTimeout(() => {
      this.callState.status = "idle";
      this.dispatchCallStateUpdate();
    }, 2000);
  }

  private handleCallFailed(_event: CustomEvent): void {
    this.stopRinging();
    this.clearRingTimeout();

    this.callState = this.getInitialState();
    this.callState.status = "error";

    this.dispatchCallStateUpdate();
  }

  private handleRemoteVideoChanged(event: CustomEvent): void {
    const { enabled } = event.detail;
    this.callState.remoteVideoEnabled = enabled;
    this.dispatchCallStateUpdate();
  }

  private handleCallTimer(event: CustomEvent): void {
    const { duration } = event.detail;
    this.callState.duration = duration;
    this.dispatchCallStateUpdate();
  }

  private handleCallHold(event: CustomEvent): void {
    const { held } = event.detail;
    this.callState.onHold = held;
    this.callState.status = held ? "held" : "answered";
    this.dispatchCallStateUpdate();
  }

  private handleLocalVideoChanged(event: CustomEvent): void {
    const { transmitting } = event.detail;
    this.callState.localVideoTransmitting = transmitting;
    this.dispatchCallStateUpdate();
  }

  /**
   * Toggle video on/off
   */
  public async toggleVideo(): Promise<boolean> {
    try {
      const enabled = await this.sipManager.toggleVideo();
      return enabled;
    } catch (error) {
      console.error("Failed to toggle video:", error);
      throw error;
    }
  }

  /**
   * Enable video
   */
  public async enableVideo(): Promise<void> {
    try {
      await this.sipManager.enableVideo();
    } catch (error) {
      console.error("Failed to enable video:", error);
      throw error;
    }
  }

  /**
   * Disable video
   */
  public async disableVideo(): Promise<void> {
    try {
      await this.sipManager.disableVideo();
    } catch (error) {
      console.error("Failed to disable video:", error);
      throw error;
    }
  }

  /**
   * Make a call with optional video
   * @param target The SIP address or extension to call
   * @param withVideo Whether to start the call with video
   */
  public async makeCallWithVideo(target: string, withVideo = false): Promise<void> {
    try {
      await this.sipManager.makeCall(target, withVideo);
    } catch (error) {
      this.callState.status = "error";
      this.dispatchCallStateUpdate();
      throw error;
    }
  }

  private stopRinging(): void {
    if (this.ringtone) {
      stopRingtone(this.ringtone);
      this.ringtone = null;
    }
  }

  private clearRingTimeout(): void {
    if (this.ringTimeout) {
      clearTimeout(this.ringTimeout);
      this.ringTimeout = null;
    }
  }

  private dispatchCallStateUpdate(): void {
    this.dispatchEvent(
      new CustomEvent("callStateChanged", {
        detail: { callState: { ...this.callState } },
      })
    );
  }

  // Public methods for call control
  async makeCall(target: string, includeVideo?: boolean): Promise<void> {
    try {
      await this.sipManager.makeCall(target, includeVideo);
    } catch (error) {
      this.callState.status = "error";
      this.dispatchCallStateUpdate();
      throw error;
    }
  }

  async answerCall(): Promise<void> {
    try {
      await this.sipManager.answerCall();
    } catch (error) {
      this.callState.status = "error";
      this.dispatchCallStateUpdate();
      throw error;
    }
  }

  async rejectCall(): Promise<void> {
    this.stopRinging();
    this.clearRingTimeout();

    try {
      await this.sipManager.rejectCall();
    } catch (error) {
      // Still update state even if rejection fails
      this.callState = this.getInitialState();
      this.dispatchCallStateUpdate();
      throw error;
    }
  }

  async hangupCall(): Promise<void> {
    try {
      await this.sipManager.hangup();
    } catch (error) {
      // Force end call state even if hangup fails
      this.callState = this.getInitialState();
      this.dispatchCallStateUpdate();
      throw error;
    }
  }

  async holdCall(): Promise<void> {
    try {
      await this.sipManager.hold();
    } catch (error) {
      throw error;
    }
  }

  async unholdCall(): Promise<void> {
    try {
      await this.sipManager.unhold();
    } catch (error) {
      throw error;
    }
  }

  async toggleMute(): Promise<boolean> {
    try {
      if (this.callState.muted) {
        await this.sipManager.unmute();
        this.callState.muted = false;
      } else {
        await this.sipManager.mute();
        this.callState.muted = true;
      }

      this.dispatchCallStateUpdate();
      return this.callState.muted;
    } catch (error) {
      throw error;
    }
  }

  sendDTMF(tone: string): void {
    if (this.callState.active && this.callState.status === "answered") {
      this.sipManager.sendDTMF(tone);
    }
  }

  getCallState(): CallState {
    return { ...this.callState };
  }

  getRemoteVideo(): HTMLVideoElement | null {
    return this.sipManager.getRemoteVideo();
  }

  getCurrentCall(): CallInfo | null {
    return this.sipManager.getCurrentCall();
  }

  getFormattedDuration(): string {
    return formatDuration(this.callState.duration);
  }
}

---

=== Object: 3ade8726adef8ecf182b04207d69b18f94eba0cc | Date: 2025-09-22 13:08:05 | Type: blob ===

import { debugLog, errorLog } from "./utils";

type SimpleUser = any;
type SimpleUserOptions = any;
let Web: any = null;

export interface SipConfig {
  server: string;
  username: string;
  password: string;
  domain: string;
  websocket_port: number;
  use_secure: boolean;
  display_name?: string;
  debug?: boolean;
}

export interface CallInfo {
  id: string;
  remoteIdentity: string;
  displayName: string;
  state: "incoming" | "outgoing" | "connected" | "ended";
  startTime?: Date;
  duration: number;
}

export class SipManager extends EventTarget {
  private simpleUser: SimpleUser | null = null;
  private config: SipConfig | null = null;
  private isRegistered = false;
  private isConnected = false;
  private connectionTimer: number | null = null;
  private currentCall: CallInfo | null = null;
  private remoteAudio: HTMLAudioElement | null = null;
  private remoteVideo: HTMLVideoElement | null = null;
  private localVideo: HTMLVideoElement | null = null;
  private localStream: MediaStream | null = null;
  private videoEnabled = false;
  private isInitialized = false;
  private isInitializing = false;

  constructor() {
    super();
    this.setupMediaElements();
  }

  private setupMediaElements(): void {
    // Setup remote audio element
    this.remoteAudio = document.createElement("audio");
    this.remoteAudio.autoplay = true;
    this.remoteAudio.style.display = "none";
    document.body.appendChild(this.remoteAudio);

    // Setup remote video element
    this.remoteVideo = document.createElement("video");
    this.remoteVideo.autoplay = true;
    this.remoteVideo.playsInline = true;
    this.remoteVideo.style.display = "none";
    document.body.appendChild(this.remoteVideo);

    // Setup local video element (hidden, for capture only)
    this.localVideo = document.createElement("video");
    this.localVideo.autoplay = true;
    this.localVideo.muted = true;
    this.localVideo.playsInline = true;
    this.localVideo.style.display = "none";
    document.body.appendChild(this.localVideo);
  }

  /**
   * Get user media with video constraints
   */
  private async getUserMedia(includeVideo: boolean = false): Promise<MediaStream> {
    const constraints: MediaStreamConstraints = {
      audio: {
        echoCancellation: true,
        noiseSuppression: true,
        autoGainControl: true,
        sampleRate: 48000,
      },
      video: includeVideo
        ? {
            width: { ideal: 640, min: 320, max: 1280 },
            height: { ideal: 480, min: 240, max: 720 },
            frameRate: { ideal: 30, min: 15, max: 30 },
            facingMode: "user",
          }
        : false,
    };

    return navigator.mediaDevices.getUserMedia(constraints);
  }

  /**
   * Enable local video stream
   */
  public async enableVideo(): Promise<void> {
    try {
      // Get new media stream with video
      const stream = await this.getUserMedia(true);

      // Update local video element
      if (this.localVideo) {
        this.localVideo.srcObject = stream;
      }

      // Store stream and update state
      this.localStream = stream;
      this.videoEnabled = true;

      debugLog(this.config?.debug || false, "Local video enabled with stream:", {
        videoTracks: stream.getVideoTracks().length,
        audioTracks: stream.getAudioTracks().length,
      });

      // If in call, replace tracks in the current session
      if (this.simpleUser?.session && this.currentCall?.state === "connected") {
        await this.replaceMediaTracks(stream);
      }

      // Notify that video state changed
      this.dispatchEvent(
        new CustomEvent("localVideoChanged", {
          detail: {
            enabled: true,
            transmitting: stream.getVideoTracks().some((track) => track.enabled && track.readyState === "live"),
          },
        })
      );
    } catch (error) {
      errorLog("Enable video failed", error);
      throw error;
    }
  }

  /**
   * Disable local video stream
   */
  public async disableVideo(): Promise<void> {
    try {
      if (!this.localStream) return;

      // Get new media stream without video (audio only)
      const audioOnlyStream = await this.getUserMedia(false);

      // Update local video element
      if (this.localVideo) {
        this.localVideo.srcObject = null;
      }

      // Stop video tracks from old stream
      this.localStream.getVideoTracks().forEach((track) => track.stop());

      // Update stream and state
      this.localStream = audioOnlyStream;
      this.videoEnabled = false;

      debugLog(this.config?.debug || false, "Local video disabled");

      // If in call, replace tracks in the current session
      if (this.simpleUser?.session && this.currentCall?.state === "connected") {
        await this.replaceMediaTracks(audioOnlyStream);
      }

      this.dispatchEvent(
        new CustomEvent("localVideoChanged", {
          detail: {
            enabled: false,
            transmitting: false,
          },
        })
      );
    } catch (error) {
      errorLog("Disable video failed", error);
      throw error;
    }
  }

  /**
   * Replace media tracks in current session
   */
  private async replaceMediaTracks(newStream: MediaStream): Promise<void> {
    try {
      const session = this.simpleUser?.session;
      if (!session || !session.sessionDescriptionHandler) {
        debugLog(this.config?.debug || false, "No active session to replace tracks");
        return;
      }

      const pc = session.sessionDescriptionHandler.peerConnection;
      if (!pc) {
        debugLog(this.config?.debug || false, "No peer connection found");
        return;
      }

      // Get current senders
      const senders = pc.getSenders();

      // Replace audio track
      const audioTrack = newStream.getAudioTracks()[0];
      const audioSender = senders.find((sender: any) => sender.track && sender.track.kind === "audio");
      if (audioSender && audioTrack) {
        await audioSender.replaceTrack(audioTrack);
        debugLog(this.config?.debug || false, "Audio track replaced");
      }

      // Handle video track
      const videoTrack = newStream.getVideoTracks()[0] || null;
      const videoSender = senders.find((sender: any) => sender.track && sender.track.kind === "video");

      if (videoSender) {
        await videoSender.replaceTrack(videoTrack);
        debugLog(this.config?.debug || false, videoTrack ? "Video track replaced" : "Video track removed");
      } else if (videoTrack) {
        // Add video track if no sender exists
        pc.addTrack(videoTrack, newStream);
        debugLog(this.config?.debug || false, "Video track added to peer connection");

        // Renegotiate to establish video
        if (session.invite) {
          await session.invite();
          debugLog(this.config?.debug || false, "Session renegotiated for video");
        }
      }
    } catch (error) {
      errorLog("Replace media tracks failed", error);
      throw error;
    }
  }

  /**
   * Toggle video state
   */
  public async toggleVideo(): Promise<boolean> {
    if (this.videoEnabled) {
      await this.disableVideo();
      return false;
    } else {
      await this.enableVideo();
      return true;
    }
  }

  /**
   * Get current video state
   */
  public getLocalVideoState(): { enabled: boolean; transmitting: boolean } {
    return {
      enabled: this.videoEnabled,
      transmitting: this.localStream ? this.localStream.getVideoTracks().some((track) => track.enabled && track.readyState === "live") : false,
    };
  }

  /**
   * Setup remote stream handlers for the session
   */
  private setupRemoteStreamHandlers(session: any): void {
    try {
      const sessionDescriptionHandler = session.sessionDescriptionHandler;
      if (!sessionDescriptionHandler) return;

      const pc = sessionDescriptionHandler.peerConnection;
      if (!pc) return;

      // Handle remote streams
      pc.ontrack = (event: RTCTrackEvent) => {
        debugLog(this.config?.debug || false, "Remote track received:", event.track.kind);

        const stream = event.streams[0];
        if (!stream) return;

        if (event.track.kind === "audio") {
          // Handle remote audio
          if (this.remoteAudio) {
            this.remoteAudio.srcObject = stream;
            debugLog(this.config?.debug || false, "Remote audio stream attached");
          }
        } else if (event.track.kind === "video") {
          // Handle remote video
          if (this.remoteVideo) {
            this.remoteVideo.srcObject = stream;
            debugLog(this.config?.debug || false, "Remote video stream attached");

            // Notify about remote video availability
            this.dispatchEvent(
              new CustomEvent("remoteVideoChanged", {
                detail: {
                  enabled: true,
                  stream: stream,
                },
              })
            );
          }
        }
      };

      // Handle stream removal
      pc.onremovetrack = (event: RTCTrackEvent) => {
        debugLog(this.config?.debug || false, "Remote track removed:", event.track.kind);

        if (event.track.kind === "video" && this.remoteVideo) {
          this.remoteVideo.srcObject = null;

          this.dispatchEvent(
            new CustomEvent("remoteVideoChanged", {
              detail: {
                enabled: false,
                stream: null,
              },
            })
          );
        }
      };
    } catch (error) {
      errorLog("Failed to setup remote stream handlers:", error);
    }
  }

  /**
   * Wait for SIP.js library to be fully loaded and functional
   */
  private async waitForSipLibrary(timeout = 15000): Promise<void> {
    return new Promise<void>(async (resolve, reject) => {
      const startTime = Date.now();
      const timeoutId = setTimeout(() => {
        reject(new Error(`SIP.js library loading timeout after ${timeout}ms`));
      }, timeout);

      const checkLibrary = async () => {
        try {
          if (!Web) {
            const SIP = await import("sip.js");
            Web = (SIP as any).Web || SIP;
          }

          const isFullyLoaded =
            Web &&
            Web.SimpleUser &&
            Web.SimpleUser.prototype &&
            typeof Web.SimpleUser.prototype.register === "function" &&
            typeof Web.SimpleUser.prototype.connect === "function" &&
            typeof Web.SimpleUser.prototype.disconnect === "function";

          if (isFullyLoaded) {
            clearTimeout(timeoutId);
            debugLog(this.config?.debug || false, "SIP.js library fully loaded and verified");
            resolve();
            return;
          }

          if (Date.now() - startTime > timeout) {
            clearTimeout(timeoutId);
            reject(new Error("SIP.js library verification timeout"));
            return;
          }

          setTimeout(checkLibrary, 100);
        } catch (error) {
          setTimeout(checkLibrary, 200);
        }
      };

      checkLibrary();
    });
  }

  /**
   * Ensure SIP client is initialized - lazy loading approach
   */
  private async ensureSipClient(): Promise<void> {
    if (this.isInitialized) return;

    if (this.isInitializing) {
      return new Promise((resolve, reject) => {
        const checkInterval = setInterval(() => {
          if (this.isInitialized) {
            clearInterval(checkInterval);
            resolve();
          } else if (!this.isInitializing) {
            clearInterval(checkInterval);
            reject(new Error("Initialization failed"));
          }
        }, 100);
      });
    }

    if (!this.config) {
      throw new Error("SIP configuration not set");
    }

    await this.initialize(this.config);
  }

  /**
   * Set configuration but don't initialize immediately
   */
  setConfig(config: SipConfig): void {
    this.config = config;
    debugLog(config.debug || false, "SIP configuration set, will initialize on first use");
  }

  /**
   * Initialize SIP client with full library loading verification
   */
  async initialize(config: SipConfig): Promise<void> {
    if (this.isInitializing || this.isInitialized) return;

    this.isInitializing = true;
    this.config = config;

    debugLog(config.debug || false, "Starting lazy SIP initialization");

    try {
      await this.waitForSipLibrary();
      await new Promise((resolve) => setTimeout(resolve, 500));

      const wsProtocol = config.use_secure ? "wss" : "ws";
      const wsPort = config.websocket_port || (config.use_secure ? 443 : 80);
      const wsServer = `${wsProtocol}://${config.server}:${wsPort}`;
      const sipAor = `sip:${config.username}@${config.domain}`;

      debugLog(config.debug || false, "WebSocket URL:", wsServer);
      debugLog(config.debug || false, "SIP AOR:", sipAor);

      // Create media helper function that supports video
      const getMediaOptions = (includeVideo: boolean = false) => ({
        constraints: includeVideo
          ? {
              audio: {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true,
              },
              video: {
                width: { ideal: 640 },
                height: { ideal: 480 },
                frameRate: { ideal: 30 },
              },
            }
          : {
              audio: {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true,
              },
              video: false,
            },
        remote: {
          audio: this.remoteAudio!,
          video: this.remoteVideo!,
        },
      });

      const options: SimpleUserOptions = {
        aor: sipAor,
        media: getMediaOptions(false), // Start with audio only
        userAgentOptions: {
          authorizationUsername: config.username,
          authorizationPassword: config.password,
          displayName: config.display_name || config.username,
          transportOptions: {
            server: wsServer,
            connectionTimeout: 15,
            maxReconnectionAttempts: 3,
            reconnectionTimeout: 4,
          },
          logLevel: config.debug ? "debug" : "error",
          sessionDescriptionHandlerFactoryOptions: {
            constraints: {
              audio: true,
              video: false,
            },
            peerConnectionConfiguration: {
              iceServers: [{ urls: "stun:stun.l.google.com:19302" }, { urls: "stun:stun1.l.google.com:19302" }],
            },
          },
        },
      };

      if (!Web || !Web.SimpleUser) {
        throw new Error("SIP.js Web.SimpleUser not available after loading");
      }

      this.simpleUser = new Web.SimpleUser(wsServer, options);

      if (!this.simpleUser) {
        throw new Error("Failed to create SimpleUser instance");
      }

      if (!this.simpleUser.register || typeof this.simpleUser.register !== "function") {
        throw new Error("SimpleUser register method not available - library incomplete");
      }

      debugLog(config.debug || false, "SimpleUser created and verified successfully");

      this.setupEventHandlers();

      debugLog(config.debug || false, `Connecting to: ${wsServer}`);
      await this.simpleUser.connect();

      this.isConnected = true;
      this.dispatchEvent(new CustomEvent("connected"));
      debugLog(config.debug || false, "Connected to WebSocket server");

      debugLog(config.debug || false, "Registering with SIP server...");
      await this.simpleUser.register();

      this.isRegistered = true;
      this.dispatchEvent(new CustomEvent("registered", { detail: { registered: true } }));

      this.startConnectionMonitoring();

      this.isInitialized = true;
      this.isInitializing = false;

      debugLog(config.debug || false, "SIP client lazy initialization completed successfully");
    } catch (error) {
      this.isInitializing = false;
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      errorLog("SIP lazy initialization failed:", errorMessage);

      this.isConnected = false;
      this.isRegistered = false;

      if (this.simpleUser) {
        try {
          await this.simpleUser.disconnect();
        } catch (cleanupError) {
          debugLog(config.debug || false, "Cleanup error", cleanupError);
        }
        this.simpleUser = null;
      }

      this.dispatchEvent(
        new CustomEvent("error", {
          detail: {
            error: errorMessage,
            type: "initialization",
          },
        })
      );

      throw new Error(`Failed to initialize SIP client: ${errorMessage}`);
    }
  }

  private setupEventHandlers(): void {
    if (!this.simpleUser) {
      errorLog("Cannot setup event handlers: SimpleUser is null");
      return;
    }

    debugLog(this.config?.debug || false, "Setting up event handlers");

    this.simpleUser.delegate = {
      onCallCreated: () => {
        debugLog(this.config?.debug || false, "Call created");
        this.dispatchEvent(new CustomEvent("callCreated"));
      },

      onCallReceived: () => {
        debugLog(this.config?.debug || false, "Incoming call received");

        let remoteIdentity = "unknown";
        let displayName = "Unknown Caller";

        try {
          const session = this.simpleUser?.session;
          debugLog(this.config?.debug || false, "Current session:", session);

          if (session) {
            // Setup remote stream handlers for this session
            this.setupRemoteStreamHandlers(session);

            if (session.request) {
              const fromHeader = session.request.getHeader("From");
              debugLog(this.config?.debug || false, "From header:", fromHeader);

              if (fromHeader) {
                const uriMatches = fromHeader.match(/<sip:([^@]+)@/) || fromHeader.match(/sip:([^@]+)@/);
                if (uriMatches && uriMatches[1]) {
                  remoteIdentity = uriMatches[1];
                  debugLog(this.config?.debug || false, "Extracted extension from From:", remoteIdentity);
                }

                const nameMatches = fromHeader.match(/^"([^"]*)"/) || fromHeader.match(/^([^<]*)</);
                if (nameMatches && nameMatches[1] && nameMatches[1].trim()) {
                  displayName = nameMatches[1].trim();
                  debugLog(this.config?.debug || false, "Extracted display name:", displayName);
                } else if (remoteIdentity !== "unknown") {
                  displayName = remoteIdentity;
                }
              }
            }

            if (remoteIdentity === "unknown" && session.remoteIdentity) {
              debugLog(this.config?.debug || false, "Trying session.remoteIdentity:", session.remoteIdentity);

              if (session.remoteIdentity.uri) {
                const uriString = session.remoteIdentity.uri.toString();
                debugLog(this.config?.debug || false, "Remote URI:", uriString);

                const matches = uriString.match(/sip:([^@]+)@/);
                if (matches && matches[1]) {
                  remoteIdentity = matches[1];
                  debugLog(this.config?.debug || false, "Extracted from remote URI:", remoteIdentity);
                }
              }

              if (session.remoteIdentity.displayName) {
                displayName = session.remoteIdentity.displayName;
                debugLog(this.config?.debug || false, "Remote display name:", displayName);
              } else if (remoteIdentity !== "unknown") {
                displayName = remoteIdentity;
              }
            }
          }
        } catch (error) {
          debugLog(this.config?.debug || false, "Error parsing caller info:", error);
        }

        debugLog(this.config?.debug || false, "Final parsed caller info:", { remoteIdentity, displayName });

        this.currentCall = {
          id: Date.now().toString(),
          remoteIdentity: remoteIdentity,
          displayName: displayName,
          state: "incoming",
          duration: 0,
        };

        this.dispatchEvent(
          new CustomEvent("incomingCall", {
            detail: {
              from: remoteIdentity,
              displayName: displayName,
              callInfo: this.currentCall,
            },
          })
        );
      },

      onCallAnswered: () => {
        if (this.currentCall) {
          this.currentCall.state = "connected";
          this.currentCall.startTime = new Date();
        }

        debugLog(this.config?.debug || false, "Call answered");

        // Setup remote stream handlers for the active session
        if (this.simpleUser?.session) {
          this.setupRemoteStreamHandlers(this.simpleUser.session);
        }

        this.dispatchEvent(
          new CustomEvent("callAnswered", {
            detail: { callInfo: this.currentCall },
          })
        );

        this.startCallTimer();
      },

      onCallHangup: () => {
        debugLog(this.config?.debug || false, "Call ended");

        // Clear remote video when call ends
        if (this.remoteVideo) {
          this.remoteVideo.srcObject = null;
        }

        if (this.currentCall) {
          this.currentCall.state = "ended";
        }

        this.stopCallTimer();
        this.dispatchEvent(
          new CustomEvent("callEnded", {
            detail: { callInfo: this.currentCall },
          })
        );

        this.currentCall = null;
      },

      onCallHold: (held: boolean) => {
        debugLog(this.config?.debug || false, "Call hold state changed", held);
        this.dispatchEvent(
          new CustomEvent("callHold", {
            detail: { held, callInfo: this.currentCall },
          })
        );
      },

      onRegistered: () => {
        this.isRegistered = true;
        debugLog(this.config?.debug || false, "Registration successful");
        this.dispatchEvent(new CustomEvent("registered", { detail: { registered: true } }));
      },

      onUnregistered: () => {
        this.isRegistered = false;
        debugLog(this.config?.debug || false, "Unregistered");
        this.dispatchEvent(new CustomEvent("registered", { detail: { registered: false } }));
      },

      onServerConnect: () => {
        this.isConnected = true;
        debugLog(this.config?.debug || false, "Server connected");
        this.dispatchEvent(new CustomEvent("connected"));
      },

      onServerDisconnect: () => {
        this.isConnected = false;
        this.isRegistered = false;
        debugLog(this.config?.debug || false, "Server disconnected");
        this.dispatchEvent(new CustomEvent("disconnected"));
      },
    };
  }

  private callTimer: number | null = null;

  private startCallTimer(): void {
    this.stopCallTimer();
    this.callTimer = window.setInterval(() => {
      if (this.currentCall && this.currentCall.startTime) {
        this.currentCall.duration = Math.floor((Date.now() - this.currentCall.startTime.getTime()) / 1000);
        this.dispatchEvent(
          new CustomEvent("callTimer", {
            detail: { duration: this.currentCall.duration, callInfo: this.currentCall },
          })
        );
      }
    }, 1000);
  }

  private stopCallTimer(): void {
    if (this.callTimer) {
      clearInterval(this.callTimer);
      this.callTimer = null;
    }
  }

  private startConnectionMonitoring(): void {
    this.connectionTimer = window.setInterval(() => {
      const connected = this.simpleUser?.isConnected() || false;

      if (connected !== this.isConnected) {
        this.isConnected = connected;
        this.dispatchEvent(
          new CustomEvent("heartbeat", {
            detail: {
              connected,
              registered: this.isRegistered,
            },
          })
        );
      }
    }, 5000);
  }

  /**
   * Make a call to the specified target
   */
  async makeCall(target: string, includeVideo = false): Promise<void> {
    await this.ensureSipClient();

    if (!this.simpleUser || !this.isRegistered) {
      throw new Error("SIP client not registered");
    }

    if (this.currentCall) {
      throw new Error("Another call is already in progress");
    }

    try {
      const targetUri = `sip:${target}@${this.config!.domain}`;
      debugLog(this.config?.debug || false, "Making call to", targetUri, "with video:", includeVideo);

      // Get media stream for the call
      let mediaStream: MediaStream;
      if (includeVideo) {
        // Enable video if requested and get stream
        if (!this.videoEnabled) {
          await this.enableVideo();
        }
        mediaStream = this.localStream!;
      } else {
        // Get audio-only stream
        mediaStream = await this.getUserMedia(false);
      }

      this.currentCall = {
        id: Date.now().toString(),
        remoteIdentity: target,
        displayName: target,
        state: "outgoing",
        duration: 0,
      };

      // Call with proper media stream
      const callOptions = {
        sessionDescriptionHandlerOptions: {
          constraints: {
            audio: true,
            video: includeVideo,
          },
        },
        sessionDescriptionHandlerFactory: (session: any, options: any) => {
          // Pass our media stream to the session
          options.localStream = mediaStream;
          return session.sessionDescriptionHandlerFactory(session, options);
        },
      };

      await this.simpleUser.call(targetUri, callOptions);

      // Setup remote stream handlers for outgoing calls too
      if (this.simpleUser.session) {
        this.setupRemoteStreamHandlers(this.simpleUser.session);
      }

      this.dispatchEvent(
        new CustomEvent("callStarted", {
          detail: {
            target,
            callInfo: this.currentCall,
            videoEnabled: includeVideo,
          },
        })
      );
    } catch (error) {
      errorLog("Call failed", error);
      this.currentCall = null;
      this.dispatchEvent(
        new CustomEvent("callFailed", {
          detail: {
            error: error instanceof Error ? error.message : "Call failed",
            target,
          },
        })
      );
      throw error;
    }
  }

  async answerCall(): Promise<void> {
    await this.ensureSipClient();

    if (!this.simpleUser) {
      throw new Error("SIP client not available");
    }

    try {
      // If video is enabled, get video stream before answering
      let mediaStream: MediaStream;
      if (this.videoEnabled) {
        mediaStream = this.localStream!;
      } else {
        mediaStream = await this.getUserMedia(false);
      }

      const answerOptions = {
        sessionDescriptionHandlerOptions: {
          constraints: {
            audio: true,
            video: this.videoEnabled,
          },
        },
        sessionDescriptionHandlerFactory: (session: any, options: any) => {
          options.localStream = mediaStream;
          return session.sessionDescriptionHandlerFactory(session, options);
        },
      };

      await this.simpleUser.answer(answerOptions);
      debugLog(this.config?.debug || false, "Call answered");
    } catch (error) {
      errorLog("Answer call failed", error);
      throw error;
    }
  }

  async rejectCall(): Promise<void> {
    await this.ensureSipClient();

    if (!this.simpleUser) {
      throw new Error("SIP client not available");
    }

    try {
      await this.simpleUser.decline();

      if (this.currentCall) {
        this.currentCall.state = "ended";
      }

      this.currentCall = null;
      debugLog(this.config?.debug || false, "Call rejected");
    } catch (error) {
      errorLog("Reject call failed", error);
      throw error;
    }
  }

  async hangup(): Promise<void> {
    if (!this.simpleUser) return;

    try {
      await this.simpleUser.hangup();
      debugLog(this.config?.debug || false, "Call hung up");
    } catch (error) {
      errorLog("Hangup failed", error);
      throw error;
    }
  }

  async hold(): Promise<void> {
    if (!this.simpleUser) return;

    try {
      await this.simpleUser.hold();
      debugLog(this.config?.debug || false, "Call put on hold");
    } catch (error) {
      errorLog("Hold failed", error);
      throw error;
    }
  }

  async unhold(): Promise<void> {
    if (!this.simpleUser) return;

    try {
      await this.simpleUser.unhold();
      debugLog(this.config?.debug || false, "Call removed from hold");
    } catch (error) {
      errorLog("Unhold failed", error);
      throw error;
    }
  }

  async mute(): Promise<void> {
    if (!this.simpleUser) return;

    try {
      await this.simpleUser.mute();
      debugLog(this.config?.debug || false, "Call muted");
    } catch (error) {
      errorLog("Mute failed", error);
      throw error;
    }
  }

  async unmute(): Promise<void> {
    if (!this.simpleUser) return;

    try {
      await this.simpleUser.unmute();
      debugLog(this.config?.debug || false, "Call unmuted");
    } catch (error) {
      errorLog("Unmute failed", error);
      throw error;
    }
  }

  sendDTMF(tone: string): void {
    if (!this.simpleUser || !this.currentCall) return;

    try {
      if (typeof this.simpleUser.sendDTMF === "function") {
        this.simpleUser.sendDTMF(tone);
        debugLog(this.config?.debug || false, "DTMF sent", tone);

        this.dispatchEvent(
          new CustomEvent("dtmfSent", {
            detail: { tone, callInfo: this.currentCall },
          })
        );
      }
    } catch (error) {
      errorLog("DTMF send failed", error);
    }
  }

  getRemoteVideo(): HTMLVideoElement | null {
    return this.remoteVideo;
  }

  getRemoteAudio(): HTMLAudioElement | null {
    return this.remoteAudio;
  }

  getCurrentCall(): CallInfo | null {
    return this.currentCall;
  }

  getConnectionStatus(): { connected: boolean; registered: boolean; initialized: boolean } {
    return {
      connected: this.isConnected,
      registered: this.isRegistered,
      initialized: this.isInitialized,
    };
  }

  async connect(): Promise<void> {
    await this.ensureSipClient();
  }

  async disconnect(): Promise<void> {
    if (this.connectionTimer) {
      clearInterval(this.connectionTimer);
      this.connectionTimer = null;
    }

    this.stopCallTimer();

    if (this.simpleUser) {
      try {
        if (this.currentCall) {
          await this.hangup();
        }

        if (this.isRegistered) {
          await this.simpleUser.unregister();
        }

        if (this.isConnected) {
          await this.simpleUser.disconnect();
        }
      } catch (error) {
        errorLog("Disconnect error", error);
      }

      this.simpleUser = null;
    }

    // Cleanup video and audio resources
    try {
      if (this.localStream) {
        this.localStream.getTracks().forEach((track) => track.stop());
        this.localStream = null;
      }

      if (this.localVideo && this.localVideo.parentNode) {
        this.localVideo.pause();
        this.localVideo.srcObject = null;
        this.localVideo.parentNode.removeChild(this.localVideo);
        this.localVideo = null;
      }

      if (this.remoteVideo && this.remoteVideo.parentNode) {
        this.remoteVideo.pause();
        this.remoteVideo.srcObject = null;
        this.remoteVideo.parentNode.removeChild(this.remoteVideo);
        this.remoteVideo = null;
      }

      this.videoEnabled = false;

      if (this.remoteAudio && this.remoteAudio.parentNode) {
        this.remoteAudio.pause();
        this.remoteAudio.srcObject = null;
        this.remoteAudio.parentNode.removeChild(this.remoteAudio);
        this.remoteAudio = null;
      }
    } catch (error) {
      errorLog("Error cleaning up media resources:", error);
    }

    this.isConnected = false;
    this.isRegistered = false;
    this.isInitialized = false;
    this.isInitializing = false;
    this.currentCall = null;

    debugLog(this.config?.debug || false, "SIP client disconnected");
  }
}

---

=== Object: f997d639fea7c72cba7e63e1abf25e2bced4cd7a | Date: 2025-09-22 13:01:13 | Type: blob ===

import type { SIPCardConfig, SIPContact } from "./types";
import { DEFAULT_CONFIG } from "./constants";

export function mergeConfig(userConfig: Partial<SIPCardConfig>): SIPCardConfig {
  return {
    ...DEFAULT_CONFIG,
    ...userConfig,
    contacts: userConfig.contacts || DEFAULT_CONFIG.contacts,
    stun_servers: userConfig.stun_servers || DEFAULT_CONFIG.stun_servers,
    turn_servers: userConfig.turn_servers || DEFAULT_CONFIG.turn_servers,
  };
}

export function validateConfig(config: SIPCardConfig): void {
  if (!config.server_url) {
    throw new Error("server_url is required");
  }
  if (!config.username) {
    throw new Error("username is required");
  }
  if (!config.password) {
    throw new Error("password is required");
  }

  // Validate WebSocket URL
  try {
    const url = new URL(config.server_url);
    if (!["ws:", "wss:"].includes(url.protocol)) {
      throw new Error("server_url must use ws:// or wss:// protocol");
    }
  } catch (error) {
    throw new Error("Invalid server_url format");
  }
}

export function formatDuration(seconds: number): string {
  const mins = Math.floor(seconds / 60);
  const secs = seconds % 60;
  return `${mins.toString().padStart(2, "0")}:${secs.toString().padStart(2, "0")}`;
}

export function formatPhoneNumber(number: string): string {
  // Simple formatting - can be enhanced based on requirements
  const cleaned = number.replace(/\D/g, "");
  if (cleaned.length === 10) {
    return `(${cleaned.slice(0, 3)}) ${cleaned.slice(3, 6)}-${cleaned.slice(6)}`;
  }
  return number;
}

export function playRingtone(): HTMLAudioElement | null {
  try {
    const audio = new Audio();
    audio.src =
      "data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBQ==";
    audio.loop = true;
    audio.play().catch(() => {
      // Ignore autoplay policy errors
    });
    return audio;
  } catch (error) {
    console.warn("Failed to play ringtone:", error);
    return null;
  }
}

export function stopRingtone(audio: HTMLAudioElement | null): void {
  if (audio) {
    audio.pause();
    audio.currentTime = 0;
  }
}

export function getContactByExtension(contacts: SIPContact[], extension: string): SIPContact | undefined {
  return contacts.find((contact) => contact.extension === extension);
}

export function sanitizeExtension(extension: string): string {
  return extension.replace(/[^\d*#+]/g, "");
}

export function debugLog(debug: boolean, message: string, ...args: any[]): void {
  if (debug) {
    console.log(`[WebRTC SIP Card] ${message}`, ...args);
  }
}

export function errorLog(message: string, error?: any): void {
  console.error(`[WebRTC SIP Card] ${message}`, error);
}

---

=== Object: f1ba95c2e18fe15d521c7045ffdd4ccdf92ebe87 | Date: 2025-09-22 13:01:13 | Type: blob ===

-----BEGIN CERTIFICATE-----
MIIDwTCCAqmgAwIBAgIUBlOwZlTBi1xylS/JPBMSqdBx838wDQYJKoZIhvcNAQEL
BQAwWjELMAkGA1UEBhMCVVMxDjAMBgNVBAgMBUxvY2FsMQ4wDAYDVQQHDAVMb2Nh
bDEXMBUGA1UECgwOSG9tZSBBc3Npc3RhbnQxEjAQBgNVBAMMCWxvY2FsaG9zdDAe
Fw0yNTA5MDEwMTI3MDVaFw0yNjA5MDEwMTI3MDVaMFoxCzAJBgNVBAYTAlVTMQ4w
DAYDVQQIDAVMb2NhbDEOMAwGA1UEBwwFTG9jYWwxFzAVBgNVBAoMDkhvbWUgQXNz
aXN0YW50MRIwEAYDVQQDDAlsb2NhbGhvc3QwggEiMA0GCSqGSIb3DQEBAQUAA4IB
DwAwggEKAoIBAQCH0KEbBMA8VOm7gtu6eyMrmchUIJgK1w/T6ZUKNKs/Vu7ImOFT
biq57v4nTaaPgXXB2iKIqJhlnDZvcyaCZfp6hRdYgq8NEoRa4Y9d1Azg+oNJKg/K
+vH5II4/HuUHB9+WxUxwfmbtVk8UIcb6Pfx5BKs/nrCRQZCaRYbm9VXSs4ZdCV+9
fQXpQCpNzhBEd/0y2b5EZ/atjJCnrBTagmjjgLyWFp5pgmAphHZkEuOzbXh/z7vo
tffeVNEz/ZSmrmDA1nq105pq9+Ef59haHbbJM7opMxvmJUi9V/GUC/TEMHaUB/mi
O1t6TY13luD4fq03P+YQZgEUVIQ6zJOrAvwXAgMBAAGjfzB9MAkGA1UdEwQCMAAw
CwYDVR0PBAQDAgXgMBMGA1UdJQQMMAoGCCsGAQUFBwMBMC8GA1UdEQQoMCaCCWxv
Y2FsaG9zdIITaG9tZWFzc2lzdGFudC5sb2NhbIcEfwAAATAdBgNVHQ4EFgQUAaY0
02f9laDWIQnCyMQHd8qK8vEwDQYJKoZIhvcNAQELBQADggEBAIOEDucfm6hsW94S
+6cKxDB51GgRBTJay4c2vUF61t4dhb8Kvp3ZcVyoAM1QR0BPv2DoqLveNh+Yyxtb
0xazBRdGi/xsOT1cVDiImXYPrWQyUF12aXaV5pW3vH701t6adN82sIHXFlv6op30
paJuk/y5hQwgIRqqkGDoXXa79kK5jVcrS7zsGdnPdSwCTebXEr3L+H5kaoiw287Z
XkoYGkQ8qK/PINLkKih+pn19Wg3xzXAX5txEg+7WQ+N9kqwlBgBAfHaGsTeiKOmP
Pe3fLE7jGKGih5mCXyV4u9kVgjIHXHA2HoeABpiEGlAoRencU4FXkGM9H8r5UyDz
1bTUerI=
-----END CERTIFICATE-----

---

=== Object: e5596d32b9c276cd6a2505fe0726011722785606 | Date: 2025-09-22 13:01:13 | Type: blob ===

import type { CallInfo } from "./sip-manager";
import { SipManager } from "./sip-manager";
import { formatDuration, playRingtone, stopRingtone, getContactByExtension } from "./utils";
import type { SIPContact } from "./types";

export interface CallState {
  active: boolean;
  incoming: boolean;
  outgoing: boolean;
  onHold: boolean;
  muted: boolean;
  remoteVideoEnabled: boolean;
  localVideoTransmitting: boolean;
  callerId?: string;
  callerName?: string;
  duration: number;
  status: "idle" | "connecting" | "ringing" | "answered" | "held" | "ended" | "error";
}

export class CallManager extends EventTarget {
  private sipManager: SipManager;
  private callState: CallState;
  private ringtone: HTMLAudioElement | null = null;
  private ringTimeout: number | null = null;
  private contacts: SIPContact[] = [];

  constructor(sipManager: SipManager, contacts: SIPContact[] = []) {
    super();
    this.sipManager = sipManager;
    this.contacts = contacts;
    this.callState = this.getInitialState();
    this.setupSipEventHandlers();
  }

  /**
   * Update the contacts list for caller ID lookup
   */
  public updateContacts(contacts: SIPContact[]): void {
    this.contacts = contacts;
  }

  private getInitialState(): CallState {
    return {
      active: false,
      incoming: false,
      outgoing: false,
      onHold: false,
      muted: false,
      remoteVideoEnabled: false,
      localVideoTransmitting: false,
      duration: 0,
      status: "idle",
    };
  }

  private setupSipEventHandlers(): void {
    this.sipManager.addEventListener("incomingCall", this.handleIncomingCall.bind(this) as EventListener);
    this.sipManager.addEventListener("callStarted", this.handleCallStarted.bind(this) as EventListener);
    this.sipManager.addEventListener("callAnswered", this.handleCallAnswered.bind(this) as EventListener);
    this.sipManager.addEventListener("callEnded", this.handleCallEnded.bind(this) as EventListener);
    this.sipManager.addEventListener("callFailed", this.handleCallFailed.bind(this) as EventListener);
    this.sipManager.addEventListener("localVideoChanged", this.handleLocalVideoChanged.bind(this) as EventListener);
    this.sipManager.addEventListener("callTimer", this.handleCallTimer.bind(this) as EventListener);
    this.sipManager.addEventListener("callHold", this.handleCallHold.bind(this) as EventListener);
  }

  /**
   * Clean up extension to extract the numeric part
   * @param rawExtension - The raw extension from SIP (e.g., "1012-screen", "Extension 1012", "1012")
   * @returns Clean extension number (e.g., "1012")
   */
  private cleanExtension(rawExtension: string): string {
    if (!rawExtension || rawExtension === "unknown") return rawExtension;

    // Remove common prefixes like "Extension "
    let cleaned = rawExtension.replace(/^Extension\s+/i, '');
    
    // Remove common suffixes like "-screen", "-web", "-mobile", etc.
    cleaned = cleaned.replace(/-screen$|-web$|-mobile$|-phone$/i, '');
    
    // Extract numeric part if it contains numbers
    const numericMatch = cleaned.match(/(\d+)/);
    if (numericMatch) {
      return numericMatch[1];
    }
    
    // If no numeric part found, return the cleaned version
    return cleaned;
  }

  /**
   * Clean up display name to remove redundant words
   * @param displayName - The display name from SIP
   * @param extension - The clean extension number
   * @returns Cleaned display name
   */
  private cleanDisplayName(displayName: string, extension: string): string {
    if (!displayName || displayName === "unknown" || displayName === "Unknown Caller") {
      return extension;
    }

    // Remove "Extension " prefix and the extension number itself
    let cleaned = displayName.replace(/^Extension\s+/i, '');
    cleaned = cleaned.replace(new RegExp(`\\b${extension}\\b`, 'g'), '').trim();
    
    // If nothing meaningful left, use extension
    if (!cleaned || cleaned === extension) {
      return extension;
    }
    
    return cleaned;
  }

  private handleIncomingCall(event: CustomEvent): void {
    const { from, displayName, callInfo } = event.detail;

    // Clean up the extension to get just the number
    const cleanedExtension = this.cleanExtension(from);
    
    // Clean up the display name
    const cleanedDisplayName = this.cleanDisplayName(displayName, cleanedExtension);

    // Try to find contact by the cleaned extension
    const contact = this.contacts ? getContactByExtension(this.contacts, cleanedExtension) : null;

    // Use contact name if found, otherwise use cleaned display name
    const finalCallerName = contact ? contact.name : cleanedDisplayName;

    this.callState = {
      ...this.callState,
      active: true,
      incoming: true,
      outgoing: false,
      callerId: cleanedExtension, // Show clean extension (e.g., "1012")
      callerName: finalCallerName, // Show contact name (e.g., "Kid") or cleaned display
      status: "ringing",
    };

    // Start ringtone
    this.ringtone = playRingtone();

    // Auto-reject after timeout (configurable)
    this.ringTimeout = window.setTimeout(() => {
      this.rejectCall();
    }, 30000); // 30 seconds default

    this.dispatchCallStateUpdate();
  }

  private handleCallStarted(event: CustomEvent): void {
    const { target } = event.detail;

    // Clean up the extension for outgoing calls too
    const cleanedExtension = this.cleanExtension(target);

    // Try to find contact by extension for outgoing calls
    const contact = this.contacts ? getContactByExtension(this.contacts, cleanedExtension) : null;
    const finalCallerName = contact ? contact.name : cleanedExtension;

    this.callState = {
      ...this.callState,
      active: true,
      incoming: false,
      outgoing: true,
      callerId: cleanedExtension,
      callerName: finalCallerName,
      status: "connecting",
    };

    this.dispatchCallStateUpdate();
  }

  private handleCallAnswered(_event: CustomEvent): void {
    this.stopRinging();

    this.callState = {
      ...this.callState,
      status: "answered",
      incoming: false,
      outgoing: false,
    };

    // Check if remote video is available
    const remoteVideo = this.sipManager.getRemoteVideo();
    if (remoteVideo && remoteVideo.srcObject) {
      const stream = remoteVideo.srcObject as MediaStream;
      this.callState.remoteVideoEnabled = stream.getVideoTracks().length > 0;
    }

    this.dispatchCallStateUpdate();
  }

  private handleCallEnded(_event: CustomEvent): void {
    this.stopRinging();
    this.clearRingTimeout();

    this.callState = this.getInitialState();
    this.callState.status = "ended";

    this.dispatchCallStateUpdate();

    // Reset to idle after a brief moment
    setTimeout(() => {
      this.callState.status = "idle";
      this.dispatchCallStateUpdate();
    }, 2000);
  }

  private handleCallFailed(_event: CustomEvent): void {
    this.stopRinging();
    this.clearRingTimeout();

    this.callState = this.getInitialState();
    this.callState.status = "error";

    this.dispatchCallStateUpdate();
  }

  private handleCallTimer(event: CustomEvent): void {
    const { duration } = event.detail;
    this.callState.duration = duration;
    this.dispatchCallStateUpdate();
  }

  private handleCallHold(event: CustomEvent): void {
    const { held } = event.detail;
    this.callState.onHold = held;
    this.callState.status = held ? "held" : "answered";
    this.dispatchCallStateUpdate();
  }

  private handleLocalVideoChanged(event: CustomEvent): void {
    const { transmitting } = event.detail;
    this.callState.localVideoTransmitting = transmitting;
    this.dispatchCallStateUpdate();
  }

  /**
   * Toggle video on/off
   */
  public async toggleVideo(): Promise<boolean> {
    try {
      const enabled = await this.sipManager.toggleVideo();
      return enabled;
    } catch (error) {
      console.error("Failed to toggle video:", error);
      throw error;
    }
  }

  /**
   * Enable video
   */
  public async enableVideo(): Promise<void> {
    try {
      await this.sipManager.enableVideo();
    } catch (error) {
      console.error("Failed to enable video:", error);
      throw error;
    }
  }

  /**
   * Disable video
   */
  public async disableVideo(): Promise<void> {
    try {
      await this.sipManager.disableVideo();
    } catch (error) {
      console.error("Failed to disable video:", error);
      throw error;
    }
  }

  /**
   * Make a call with optional video
   * @param target The SIP address or extension to call
   * @param withVideo Whether to start the call with video
   */
  public async makeCallWithVideo(target: string, withVideo = false): Promise<void> {
    try {
      await this.sipManager.makeCall(target, withVideo);
    } catch (error) {
      this.callState.status = "error";
      this.dispatchCallStateUpdate();
      throw error;
    }
  }

  private stopRinging(): void {
    if (this.ringtone) {
      stopRingtone(this.ringtone);
      this.ringtone = null;
    }
  }

  private clearRingTimeout(): void {
    if (this.ringTimeout) {
      clearTimeout(this.ringTimeout);
      this.ringTimeout = null;
    }
  }

  private dispatchCallStateUpdate(): void {
    this.dispatchEvent(
      new CustomEvent("callStateChanged", {
        detail: { callState: { ...this.callState } },
      })
    );
  }

  // Public methods for call control
  async makeCall(target: string, includeVideo?: boolean): Promise<void> {
    try {
      await this.sipManager.makeCall(target, includeVideo);
    } catch (error) {
      this.callState.status = "error";
      this.dispatchCallStateUpdate();
      throw error;
    }
  }

  async answerCall(): Promise<void> {
    try {
      await this.sipManager.answerCall();
    } catch (error) {
      this.callState.status = "error";
      this.dispatchCallStateUpdate();
      throw error;
    }
  }

  async rejectCall(): Promise<void> {
    this.stopRinging();
    this.clearRingTimeout();

    try {
      await this.sipManager.rejectCall();
    } catch (error) {
      // Still update state even if rejection fails
      this.callState = this.getInitialState();
      this.dispatchCallStateUpdate();
      throw error;
    }
  }

  async hangupCall(): Promise<void> {
    try {
      await this.sipManager.hangup();
    } catch (error) {
      // Force end call state even if hangup fails
      this.callState = this.getInitialState();
      this.dispatchCallStateUpdate();
      throw error;
    }
  }

  async holdCall(): Promise<void> {
    try {
      await this.sipManager.hold();
    } catch (error) {
      throw error;
    }
  }

  async unholdCall(): Promise<void> {
    try {
      await this.sipManager.unhold();
    } catch (error) {
      throw error;
    }
  }

  async toggleMute(): Promise<boolean> {
    try {
      if (this.callState.muted) {
        await this.sipManager.unmute();
        this.callState.muted = false;
      } else {
        await this.sipManager.mute();
        this.callState.muted = true;
      }

      this.dispatchCallStateUpdate();
      return this.callState.muted;
    } catch (error) {
      throw error;
    }
  }

  sendDTMF(tone: string): void {
    if (this.callState.active && this.callState.status === "answered") {
      this.sipManager.sendDTMF(tone);
    }
  }

  getCallState(): CallState {
    return { ...this.callState };
  }

  getRemoteVideo(): HTMLVideoElement | null {
    return this.sipManager.getRemoteVideo();
  }

  getCurrentCall(): CallInfo | null {
    return this.sipManager.getCurrentCall();
  }

  getFormattedDuration(): string {
    return formatDuration(this.callState.duration);
  }
}
---

=== Object: d3d7948ed817791f1f6250a329f616eb76c914e2 | Date: 2025-09-22 13:01:13 | Type: blob ===

import { css } from 'lit';

export const sharedStyles = css`
  :host {
    display: block;
    --sip-primary-color: var(--primary-color);
    --sip-secondary-color: var(--secondary-color);
    --sip-text-primary-color: var(--primary-text-color);
    --sip-text-secondary-color: var(--secondary-text-color);
    --sip-card-background-color: var(--card-background-color);
    --sip-divider-color: var(--divider-color);
    --sip-success-color: var(--success-color, #4caf50);
    --sip-warning-color: var(--warning-color, #ff9800);
    --sip-error-color: var(--error-color, #f44336);
    --sip-border-radius: var(--ha-card-border-radius, 12px);
  }

  .card-content {
    padding: 16px;
  }

  .status-bar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 8px 16px;
    background: var(--secondary-background-color);
    border-bottom: 1px solid var(--sip-divider-color);
    border-radius: var(--sip-border-radius) var(--sip-border-radius) 0 0;
  }

  .status-indicator {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 14px;
    font-weight: 500;
  }

  .status-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: var(--sip-error-color);
  }

  .status-dot.connected {
    background: var(--sip-success-color);
  }

  .status-dot.connecting {
    background: var(--sip-warning-color);
    animation: pulse 1.5s infinite;
  }

  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
  }

  .contacts-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
    gap: 12px;
    margin: 16px 0;
  }

  .contact-button {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    padding: 16px 8px;
    background: var(--sip-card-background-color);
    border: 1px solid var(--sip-divider-color);
    border-radius: var(--sip-border-radius);
    cursor: pointer;
    transition: all 0.2s ease;
    font-family: inherit;
    color: var(--sip-text-primary-color);
  }

  .contact-button:hover {
    background: var(--secondary-background-color);
    border-color: var(--sip-primary-color);
    transform: translateY(-2px);
  }

  .contact-button:active {
    transform: translateY(0);
  }

  .contact-icon {
    width: 32px;
    height: 32px;
    color: var(--sip-primary-color);
  }

  .contact-name {
    font-size: 12px;
    font-weight: 500;
    text-align: center;
    line-height: 1.2;
  }

  .contact-extension {
    font-size: 10px;
    color: var(--sip-text-secondary-color);
    opacity: 0.7;
  }

  .video-container {
    position: relative;
    background: #000;
    border-radius: var(--sip-border-radius);
    overflow: hidden;
    aspect-ratio: 4/3;
    margin: 16px 0;
  }

  .video-element {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  .video-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.7);
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-size: 18px;
  }

  .call-controls {
    display: flex;
    justify-content: center;
    gap: 16px;
    margin: 16px 0;
  }

  .control-button {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 48px;
    height: 48px;
    border-radius: 50%;
    border: none;
    cursor: pointer;
    transition: all 0.2s ease;
    font-family: inherit;
  }

  .control-button.primary {
    background: var(--sip-success-color);
    color: white;
  }

  .control-button.danger {
    background: var(--sip-error-color);
    color: white;
  }

  .control-button.secondary {
    background: var(--secondary-background-color);
    color: var(--sip-text-primary-color);
    border: 1px solid var(--sip-divider-color);
  }

  .control-button:hover {
    transform: scale(1.1);
  }

  .control-button:active {
    transform: scale(0.95);
  }

  .control-button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
  }

  .keypad {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 8px;
    margin: 16px 0;
    max-width: 240px;
    margin-left: auto;
    margin-right: auto;
  }

  .keypad-button {
    aspect-ratio: 1;
    border: none;
    border-radius: var(--sip-border-radius);
    background: var(--secondary-background-color);
    color: var(--sip-text-primary-color);
    font-size: 18px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.1s ease;
    font-family: inherit;
  }

  .keypad-button:hover {
    background: var(--sip-primary-color);
    color: white;
  }

  .keypad-button:active {
    transform: scale(0.95);
  }

  .call-info {
    text-align: center;
    margin: 16px 0;
  }

  .caller-name {
    font-size: 20px;
    font-weight: bold;
    margin-bottom: 4px;
  }

  .caller-number {
    font-size: 16px;
    color: var(--sip-text-secondary-color);
    margin-bottom: 8px;
  }

  .call-duration {
    font-size: 14px;
    color: var(--sip-text-secondary-color);
    font-family: monospace;
  }

  .error-message {
    background: var(--sip-error-color);
    color: white;
    padding: 12px;
    border-radius: var(--sip-border-radius);
    margin: 16px 0;
    text-align: center;
    font-weight: 500;
  }

  .hidden {
    display: none !important;
  }

  .incoming-call-modal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
  }

  .incoming-call-content {
    background: var(--sip-card-background-color);
    border-radius: var(--sip-border-radius);
    padding: 32px;
    text-align: center;
    max-width: 320px;
    width: 90%;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  }

  .incoming-call-avatar {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    background: var(--sip-primary-color);
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 0 auto 16px;
    color: white;
    font-size: 32px;
  }

  .incoming-call-actions {
    display: flex;
    justify-content: center;
    gap: 32px;
    margin-top: 24px;
  }

  .answer-button {
    width: 64px;
    height: 64px;
    border-radius: 50%;
    border: none;
    background: var(--sip-success-color);
    color: white;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
  }

  .reject-button {
    width: 64px;
    height: 64px;
    border-radius: 50%;
    border: none;
    background: var(--sip-error-color);
    color: white;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
  }

  .answer-button:hover,
  .reject-button:hover {
    transform: scale(1.1);
  }

  .answer-button:active,
  .reject-button:active {
    transform: scale(0.95);
  }
`;
---

=== Object: caba67c4f84acf5a2350c9d0357a172ee6c0d5cb | Date: 2025-09-22 13:01:13 | Type: blob ===

import { defineConfig } from "vite";
import { resolve } from "path";

export default defineConfig({
  build: {
    lib: {
      entry: {
        "ha-webrtc-sip-card": resolve(__dirname, "src/card.ts"),
        "ha-webrtc-sip-card-editor": resolve(__dirname, "src/editor.ts"),
      },
      formats: ["es"],
      fileName: (format, entryName) => `${entryName}.js`,
    },
    outDir: "./dist",
    emptyOutDir: true,
    rollupOptions: {
      external: [],
      output: {
        // Ensure each entry is a separate file
        manualChunks: undefined,
        format: "es",
      },
    },
    target: "es2017",
    minify: false,
    // Important: Generate sourcemaps for debugging
    sourcemap: true,
  },
  define: {
    __DEV__: JSON.stringify(process.env.NODE_ENV === "development"),
    __VERSION__: JSON.stringify(process.env.npm_package_version || "1.0.0"),
  },
});

---

=== Object: c68eaa5d10d9b6c6ff1d1649246c78b73eb8be8c | Date: 2025-09-22 13:01:13 | Type: blob ===

export const CARD_VERSION = '1.0.0';
export const CARD_NAME = 'ha-webrtc-sip-card';

export const DEFAULT_CONFIG = {
  type: 'custom:ha-webrtc-sip-card',
  title: 'WebRTC SIP Phone',
  server_url: '',
  username: '',
  password: '',
  domain: '',
  display_name: '',
  stun_servers: ['stun:stun.l.google.com:19302'],
  turn_servers: [],
  auto_answer: false,
  video_enabled: true,
  dtmf_enabled: true,
  call_history_enabled: true,
  theme: 'auto' as const,
  contacts: [],
  hide_keypad: false,
  hide_video_controls: false,
  ring_timeout: 30000,
  debug: false,
};

export const SIP_EVENTS = {
  REGISTERED: 'registered',
  UNREGISTERED: 'unregistered',
  REGISTRATION_FAILED: 'registrationFailed',
  INVITE: 'invite',
  PROGRESS: 'progress',
  ACCEPTED: 'accepted',
  REJECTED: 'rejected',
  CANCEL: 'cancel',
  BYE: 'bye',
  FAILED: 'failed',
  MUTED: 'muted',
  UNMUTED: 'unmuted',
} as const;

export const CALL_STATUS = {
  IDLE: 'idle',
  CONNECTING: 'connecting',
  RINGING: 'ringing',
  ANSWERED: 'answered',
  HELD: 'held',
  ENDED: 'ended',
  ERROR: 'error',
} as const;

export const DTMF_KEYS = [
  ['1', '2', '3'],
  ['4', '5', '6'],
  ['7', '8', '9'],
  ['*', '0', '#'],
] as const;

export const VIDEO_CONSTRAINTS = {
  video: {
    width: { ideal: 320 },
    height: { ideal: 240 },
    frameRate: { ideal: 15, max: 30 },
  },
  audio: {
    echoCancellation: true,
    noiseSuppression: true,
    autoGainControl: true,
  },
};

export const RING_TONE_URL = 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBjiR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmYdBQ==';
---

=== Object: adac3e2e9e3a0356c33690b6643e2ca04d84c771 | Date: 2025-09-22 13:01:13 | Type: blob ===

{
  "name": "ha-webrtc-sip-card",
  "version": "1.0.0",
  "description": "A modern WebRTC SIP client card for Home Assistant",
  "main": "dist/ha-webrtc-sip-card.js",
  "scripts": {
    "dev": "vite --host 0.0.0.0 --port 3000",
    "build": "vite build",
    "preview": "vite preview",
    "lint": "eslint src --ext .ts",
    "type-check": "tsc --noEmit",
    "serve": "vite build && vite preview"
  },
  "keywords": [
    "home-assistant",
    "custom-card",
    "webrtc",
    "sip",
    "voip",
    "hacs"
  ],
  "author": "Ahmed Waleed",
  "license": "MIT",
  "devDependencies": {
    "@typescript-eslint/eslint-plugin": "^6.21.0",
    "@typescript-eslint/parser": "^6.21.0",
    "eslint": "^8.57.0",
    "typescript": "^5.4.3",
    "vite": "^5.2.8"
  },
  "dependencies": {
    "custom-card-helpers": "^1.9.0",
    "lit": "^3.1.2",
    "sip.js": "^0.21.2"
  }
}

---

=== Object: 928f74716507e1346f344278f53d84c10265ed4b | Date: 2025-09-22 13:01:13 | Type: blob ===

import { LitElement, html, css, type CSSResultGroup, type TemplateResult } from "lit";
import { customElement, property, state, query } from "lit/decorators.js";
import type { HomeAssistant, SIPCardConfig, SIPContact } from "./types";
import { SipManager, type SipConfig } from "./sip-manager";
import { CallManager, type CallState } from "./call-manager";
import { sharedStyles } from "./styles";
import { CARD_VERSION, DEFAULT_CONFIG, DTMF_KEYS } from "./constants";
import { mergeConfig, validateConfig, formatPhoneNumber, sanitizeExtension } from "./utils";

@customElement("ha-webrtc-sip-card")
export class WebRTCSipCard extends LitElement {
  @property({ attribute: false }) public hass!: HomeAssistant;
  @state() private config!: SIPCardConfig;
  @state() private connected = false;
  @state() private registered = false;
  @state() private error: string | null = null;
  @state() private callState!: CallState;
  @state() private showKeypad = false;
  @state() private currentInput = "";

  @query("#remote-video") private remoteVideoElement?: HTMLVideoElement;

  private sipManager: SipManager | null = null;
  private callManager: CallManager | null = null;

  public static getConfigElement() {
    return document.createElement("ha-webrtc-sip-card-editor");
  }

  public static getStubConfig(): SIPCardConfig {
    return { ...DEFAULT_CONFIG };
  }

  public setConfig(config: SIPCardConfig): void {
    try {
      validateConfig(config);
      this.config = mergeConfig(config);
      this.initializeSipClient();
    } catch (error) {
      this.error = error instanceof Error ? error.message : "Invalid configuration";
      throw new Error(this.error);
    }
  }

  public getCardSize(): number {
    return this.callState && this.callState.active ? 6 : 4;
  }

  private async initializeSipClient(): Promise<void> {
    try {
      // Cleanup existing connections
      if (this.sipManager) {
        await this.sipManager.disconnect();
      }

      this.error = null;
      this.connected = false;
      this.registered = false;

      const sipConfig: SipConfig = {
        server: this.config.server_url.replace(/^wss?:\/\//, "").replace(/:\d+$/, ""),
        username: this.config.username,
        password: this.config.password,
        domain: this.config.domain || this.config.server_url.replace(/^wss?:\/\//, "").replace(/:\d+$/, ""),
        websocket_port: this.config.websocket_port ? Number(this.config.websocket_port) : this.config.server_url.includes("wss://") ? 443 : 80,
        use_secure: this.config.server_url.startsWith("wss://"),
        display_name: this.config.display_name,
        debug: this.config.debug,
      };

      this.sipManager = new SipManager();
      this.callManager = new CallManager(this.sipManager, this.config.contacts);

      // Setup event handlers
      this.setupEventHandlers();

      // Initialize call state
      this.callState = this.callManager.getCallState();

      await this.sipManager.initialize(sipConfig);
    } catch (error) {
      this.error = error instanceof Error ? error.message : "Configuration failed";
      this.connected = false;
      this.registered = false;
      console.error("SIP initialization failed:", error);
    }
  }

  private setupEventHandlers(): void {
    if (!this.sipManager || !this.callManager) return;

    // SIP connection events
    this.sipManager.addEventListener("connected", () => {
      this.connected = true;
      this.requestUpdate();
    });

    this.sipManager.addEventListener("disconnected", () => {
      this.connected = false;
      this.registered = false;
      this.requestUpdate();
    });

    this.sipManager.addEventListener("registered", (event: any) => {
      this.registered = event.detail.registered;
      if (this.registered) {
        this.error = null;
      }
      this.requestUpdate();
    });

    this.sipManager.addEventListener("error", (event: any) => {
      this.error = event.detail.error;
      this.connected = false;
      this.registered = false;
      this.requestUpdate();
    });

    // Local video state events
    this.sipManager.addEventListener("localVideoChanged", (event: any) => {
      // Update call state when local video changes
      this.callState = this.callManager?.getCallState() || this.callState;
      this.requestUpdate();
    });

    // Call state events
    this.callManager.addEventListener("callStateChanged", (event: any) => {
      this.callState = event.detail.callState;
      this.updateRemoteVideo();
      this.requestUpdate();
    });
  }

  private updateRemoteVideo(): void {
    if (this.callState.active && this.remoteVideoElement) {
      const remoteVideo = this.callManager?.getRemoteVideo();
      if (remoteVideo && remoteVideo.srcObject) {
        this.remoteVideoElement.srcObject = remoteVideo.srcObject;
      }
    }
  }

  connectedCallback() {
    super.connectedCallback();
    if (this.config) {
      this.initializeSipClient();
    }
  }

  disconnectedCallback() {
    super.disconnectedCallback();
    if (this.sipManager) {
      this.sipManager.disconnect().catch(console.error);
    }
  }

  protected render(): TemplateResult {
    if (!this.config) {
      return html`<ha-card><div class="error">Configuration required</div></ha-card>`;
    }

    return html` <ha-card> ${this.renderStatusBar()} ${this.renderError()} ${this.renderContent()} ${this.renderIncomingCallModal()} </ha-card> `;
  }

  private renderStatusBar(): TemplateResult {
    const statusClass = this.registered ? "connected" : this.connected ? "connecting" : "disconnected";
    const statusText = this.registered ? "Connected" : this.connected ? "Connecting..." : "Disconnected";

    return html`
      <div class="status-bar">
        <div class="status-indicator">
          <div class="status-dot ${statusClass}"></div>
          <span>${statusText}</span>
        </div>
        <div class="card-title">${this.config.title || "WebRTC SIP Phone"}</div>
      </div>
    `;
  }

  private renderError(): TemplateResult {
    if (!this.error) return html``;

    return html`
      <div class="error-message">
        <ha-icon icon="mdi:alert-circle"></ha-icon>
        ${this.error}
      </div>
    `;
  }

  private renderContent(): TemplateResult {
    if (this.callState.active) {
      return this.renderActiveCall();
    }

    return html` <div class="card-content">${this.renderContacts()} ${this.renderManualDial()} ${this.showKeypad ? this.renderKeypad() : ""}</div> `;
  }

  private renderContacts(): TemplateResult {
    if (!this.config.contacts.length) {
      return html`<div class="no-contacts">No contacts configured</div>`;
    }

    return html`
      <div class="contacts-section">
        <h3>Quick Dial</h3>
        <div class="contacts-grid">${this.config.contacts.map((contact) => this.renderContact(contact))}</div>
      </div>
    `;
  }

  private renderContact(contact: SIPContact): TemplateResult {
    return html`
      <button class="contact-button" @click=${() => this.callContact(contact)} ?disabled=${!this.registered}>
        <ha-icon class="contact-icon" icon=${contact.icon || "mdi:phone"}></ha-icon>
        <div class="contact-name">${contact.name}</div>
        <div class="contact-extension">${formatPhoneNumber(contact.extension)}</div>
      </button>
    `;
  }

  private renderManualDial(): TemplateResult {
    return html`
      <div class="manual-dial">
        <div class="dial-input-container">
          <ha-textfield .value=${this.currentInput} @input=${this.handleInputChange} placeholder="Enter number..." ?disabled=${!this.registered}></ha-textfield>
          <ha-icon-button @click=${this.toggleKeypad} icon="mdi:dialpad" ?disabled=${!this.registered}></ha-icon-button>
        </div>
        <div class="dial-actions">
          <ha-button @click=${this.makeCall} ?disabled=${!this.registered || !this.currentInput.trim()} class="primary">
            <ha-icon icon="mdi:phone" slot="icon"></ha-icon> Call
          </ha-button>
          <ha-button
            @click=${() => this.makeVideoCall()}
            ?disabled=${!this.registered || !this.currentInput.trim() || !this.config.video_enabled}
            class="video-call"
          >
            <ha-icon icon="mdi:video" slot="icon"></ha-icon> Video Call
          </ha-button>
          <ha-button @click=${this.clearInput} ?disabled=${!this.currentInput.length}> Clear </ha-button>
        </div>
      </div>
    `;
  }

  private renderKeypad(): TemplateResult {
    return html`
      <div class="keypad">
        ${DTMF_KEYS.flat().map((key) => html` <button class="keypad-button" @click=${() => this.handleKeypadPress(key)}>${key}</button> `)}
      </div>
    `;
  }

  private renderActiveCall(): TemplateResult {
    const isIncoming = this.callState.incoming && this.callState.status === "ringing";
    const isActive = this.callState.status === "answered";

    return html`
      <div class="active-call">
        ${this.renderCallInfo()} ${this.renderVideoStatus()} ${this.callState.remoteVideoEnabled ? this.renderVideoArea() : ""}
        ${isIncoming ? this.renderIncomingCallControls() : ""} ${isActive ? this.renderCallControls() : ""}
        ${isActive && !this.config.hide_keypad ? this.renderInCallKeypad() : ""}
      </div>
    `;
  }

  private renderCallInfo(): TemplateResult {
    // Force update the duration by accessing it directly
    const duration = this.callManager?.getFormattedDuration() || "00:00";

    return html`
      <div class="call-info">
        <div class="caller-name">${this.callState.callerName || "Unknown"}</div>
        <div class="caller-number">${formatPhoneNumber(this.callState.callerId || "")}</div>
        <div class="call-status">${this.getCallStatusText()}</div>
        ${this.callState.status === "answered" ? html`<div class="call-duration">${duration}</div>` : ""}
      </div>
    `;
  }

  // NEW: Video status indicator
  private renderVideoStatus(): TemplateResult {
    if (!this.config.video_enabled) {
      return html``;
    }

    return html`
      <div class="video-status">
        <div class="video-indicator ${this.callState.localVideoTransmitting ? "active" : "inactive"}">
          <ha-icon icon=${this.callState.localVideoTransmitting ? "mdi:video" : "mdi:video-off"}></ha-icon>
          <span>${this.callState.localVideoTransmitting ? "Camera On" : "Camera Off"}</span>
        </div>
      </div>
    `;
  }

  private renderVideoArea(): TemplateResult {
    return html`
      <div class="video-container">
        <video id="remote-video" autoplay playsinline ?muted=${false}></video>
        ${!this.callState.remoteVideoEnabled
          ? html`
              <div class="video-overlay">
                <ha-icon icon="mdi:video-off"></ha-icon>
                <div>No remote video</div>
              </div>
            `
          : ""}
      </div>
    `;
  }

  private renderIncomingCallControls(): TemplateResult {
    return html`
      <div class="call-controls">
        <button class="control-button primary" @click=${this.answerCall}>
          <ha-icon icon="mdi:phone"></ha-icon>
        </button>
        ${this.config.video_enabled
          ? html`
              <button class="control-button video" @click=${() => this.answerCall(true)}>
                <ha-icon icon="mdi:video"></ha-icon>
              </button>
            `
          : ""}
        <button class="control-button danger" @click=${this.rejectCall}>
          <ha-icon icon="mdi:phone-hangup"></ha-icon>
        </button>
      </div>
    `;
  }

  private renderCallControls(): TemplateResult {
    return html`
      <div class="call-controls">
        <button class="control-button ${this.callState.muted ? "danger" : "secondary"}" @click=${this.toggleMute}>
          <ha-icon icon=${this.callState.muted ? "mdi:microphone-off" : "mdi:microphone"}></ha-icon>
        </button>

        ${this.config.video_enabled
          ? html`
              <button
                class="control-button ${this.callState.localVideoTransmitting ? "primary" : "secondary"}"
                @click=${this.toggleVideo}
                title=${this.callState.localVideoTransmitting ? "Turn off camera" : "Turn on camera"}
              >
                <ha-icon icon=${this.callState.localVideoTransmitting ? "mdi:video" : "mdi:video-off"}></ha-icon>
              </button>
            `
          : ""}

        <button class="control-button ${this.callState.onHold ? "primary" : "secondary"}" @click=${this.toggleHold}>
          <ha-icon icon=${this.callState.onHold ? "mdi:play" : "mdi:pause"}></ha-icon>
        </button>

        <button class="control-button danger" @click=${this.hangupCall}>
          <ha-icon icon="mdi:phone-hangup"></ha-icon>
        </button>

        <button class="control-button secondary" @click=${() => (this.showKeypad = !this.showKeypad)}>
          <ha-icon icon="mdi:dialpad"></ha-icon>
        </button>
      </div>
    `;
  }

  private renderInCallKeypad(): TemplateResult {
    if (!this.showKeypad) return html``;

    return html`
      <div class="in-call-keypad">
        <div class="keypad">${DTMF_KEYS.flat().map((key) => html` <button class="keypad-button" @click=${() => this.sendDTMF(key)}>${key}</button> `)}</div>
      </div>
    `;
  }

  private renderIncomingCallModal(): TemplateResult {
    if (!this.callState.incoming || this.callState.status !== "ringing") {
      return html``;
    }

    return html`
      <div class="incoming-call-modal">
        <div class="incoming-call-content">
          <div class="incoming-call-avatar">
            <ha-icon icon="mdi:account"></ha-icon>
          </div>
          <div class="caller-name">${this.callState.callerName || "Unknown Caller"}</div>
          <div class="caller-number">${formatPhoneNumber(this.callState.callerId || "")}</div>
          <div class="incoming-call-actions">
            <button class="answer-button" @click=${this.answerCall}>
              <ha-icon icon="mdi:phone"></ha-icon>
            </button>
            ${this.config.video_enabled
              ? html`
                  <button class="video-answer-button" @click=${() => this.answerCall(true)}>
                    <ha-icon icon="mdi:video"></ha-icon>
                  </button>
                `
              : ""}
            <button class="reject-button" @click=${this.rejectCall}>
              <ha-icon icon="mdi:phone-hangup"></ha-icon>
            </button>
          </div>
        </div>
      </div>
    `;
  }

  private getCallStatusText(): string {
    switch (this.callState.status) {
      case "connecting":
        return "Connecting...";
      case "ringing":
        return this.callState.incoming ? "Incoming call" : "Ringing...";
      case "answered":
        return this.callState.onHold ? "On hold" : "Connected";
      case "ended":
        return "Call ended";
      case "error":
        return "Call failed";
      default:
        return "";
    }
  }

  // Event handlers
  private handleInputChange(event: Event): void {
    const target = event.target as HTMLInputElement;
    this.currentInput = sanitizeExtension(target.value);
  }

  private handleKeypadPress(key: string): void {
    this.currentInput += key;
    this.requestUpdate();
  }

  private toggleKeypad(): void {
    this.showKeypad = !this.showKeypad;
  }

  private clearInput(): void {
    this.currentInput = "";
  }

  private async callContact(contact: SIPContact): Promise<void> {
    if (!this.callManager || !this.registered) return;

    try {
      await this.callManager.makeCall(contact.extension);
    } catch (error) {
      console.error("Failed to call contact:", error);
      this.error = `Failed to call ${contact.name}`;
    }
  }

  private async makeCall(): Promise<void> {
    if (!this.callManager || !this.registered || !this.currentInput.trim()) return;

    try {
      await this.callManager.makeCall(this.currentInput.trim());
      this.currentInput = "";
      this.showKeypad = false;
    } catch (error) {
      console.error("Failed to make call:", error);
      this.error = "Failed to make call";
    }
  }

  // NEW: Video call method
  private async makeVideoCall(): Promise<void> {
    if (!this.callManager || !this.registered || !this.currentInput.trim()) return;

    try {
      await this.callManager.makeCall(this.currentInput.trim(), true); // Include video
      this.currentInput = "";
      this.showKeypad = false;
    } catch (error) {
      console.error("Failed to make video call:", error);
      this.error = "Failed to make video call";
    }
  }

  private async answerCall(withVideo = false): Promise<void> {
    if (!this.callManager) return;

    try {
      if (withVideo && this.config.video_enabled) {
        // Enable video before answering
        await this.callManager.enableVideo();
      }
      await this.callManager.answerCall();
    } catch (error) {
      console.error("Failed to answer call:", error);
      this.error = "Failed to answer call";
    }
  }

  private async rejectCall(): Promise<void> {
    if (!this.callManager) return;

    try {
      await this.callManager.rejectCall();
    } catch (error) {
      console.error("Failed to reject call:", error);
    }
  }

  private async hangupCall(): Promise<void> {
    if (!this.callManager) return;

    try {
      await this.callManager.hangupCall();
      this.showKeypad = false;
    } catch (error) {
      console.error("Failed to hangup call:", error);
    }
  }

  private async toggleMute(): Promise<void> {
    if (!this.callManager) return;

    try {
      await this.callManager.toggleMute();
    } catch (error) {
      console.error("Failed to toggle mute:", error);
      this.error = "Failed to toggle mute";
    }
  }

  // NEW: Video toggle method
  private async toggleVideo(): Promise<void> {
    if (!this.callManager) return;

    try {
      await this.callManager.toggleVideo();
    } catch (error) {
      console.error("Toggle video failed:", error);
      this.error = "Failed to toggle video";
    }
  }

  private async toggleHold(): Promise<void> {
    if (!this.callManager) return;

    try {
      if (this.callState.onHold) {
        await this.callManager.unholdCall();
      } else {
        await this.callManager.holdCall();
      }
    } catch (error) {
      console.error("Failed to toggle hold:", error);
      this.error = "Failed to toggle hold";
    }
  }

  private sendDTMF(tone: string): void {
    if (!this.callManager) return;
    this.callManager.sendDTMF(tone);
  }

  static get styles(): CSSResultGroup {
    return [
      sharedStyles,
      css`
        .card-title {
          font-weight: 500;
          font-size: 16px;
        }

        .no-contacts {
          text-align: center;
          color: var(--sip-text-secondary-color);
          padding: 32px;
          font-style: italic;
        }

        .contacts-section h3 {
          margin: 0 0 16px 0;
          font-size: 18px;
          font-weight: 500;
        }

        .manual-dial {
          margin-top: 24px;
          padding-top: 24px;
          border-top: 1px solid var(--sip-divider-color);
        }

        .dial-input-container {
          display: flex;
          gap: 8px;
          margin-bottom: 16px;
        }

        .dial-input-container ha-textfield {
          flex: 1;
        }

        .dial-actions {
          display: flex;
          gap: 12px;
          justify-content: center;
          flex-wrap: wrap;
        }

        .active-call {
          padding: 16px;
        }

        .call-status {
          font-size: 14px;
          color: var(--sip-text-secondary-color);
          margin-bottom: 8px;
        }

        .in-call-keypad {
          margin-top: 16px;
          padding-top: 16px;
          border-top: 1px solid var(--sip-divider-color);
        }

        /* Video status styles */
        .video-status {
          display: flex;
          justify-content: center;
          padding: 8px 16px;
          background: var(--secondary-background-color);
          border-radius: 8px;
          margin-bottom: 16px;
        }

        .video-indicator {
          display: flex;
          align-items: center;
          gap: 8px;
          padding: 4px 12px;
          border-radius: 16px;
          font-size: 12px;
          font-weight: 500;
          transition: all 0.2s ease;
        }

        .video-indicator.active {
          background: rgba(var(--success-color-rgb, 76, 175, 80), 0.1);
          color: var(--success-color, #4caf50);
        }

        .video-indicator.active ha-icon {
          color: var(--success-color, #4caf50);
        }

        .video-indicator.inactive {
          background: rgba(var(--disabled-text-color-rgb, 128, 128, 128), 0.1);
          color: var(--disabled-text-color, #808080);
        }

        .video-indicator.inactive ha-icon {
          color: var(--disabled-text-color, #808080);
        }

        /* Call controls enhancements */
        .control-button.primary {
          background: var(--sip-success-color);
          color: white;
        }

        .control-button.video {
          background: var(--primary-color);
          color: white;
        }

        .control-button.secondary {
          background: var(--secondary-background-color);
          color: var(--primary-text-color);
        }

        .control-button.danger {
          background: var(--sip-danger-color);
          color: white;
        }

        /* Incoming call modal enhancements */
        .incoming-call-actions {
          display: flex;
          justify-content: center;
          gap: 24px;
        }

        .video-answer-button {
          background: var(--primary-color);
          border: none;
          border-radius: 50%;
          width: 64px;
          height: 64px;
          color: white;
          font-size: 24px;
          cursor: pointer;
          transition: all 0.2s ease;
        }

        .video-answer-button:hover {
          transform: scale(1.1);
        }

        ha-button.primary {
          --mdc-theme-primary: var(--sip-success-color);
        }

        ha-button.video-call {
          --mdc-theme-primary: var(--primary-color);
        }

        ha-textfield {
          width: 100%;
        }

        ha-icon-button {
          --mdc-icon-button-size: 40px;
        }
      `,
    ];
  }
}

declare global {
  interface HTMLElementTagNameMap {
    "ha-webrtc-sip-card": WebRTCSipCard;
  }
}

// Register the card with Home Assistant
(window as any).customCards = (window as any).customCards || [];
(window as any).customCards.push({
  type: "ha-webrtc-sip-card",
  name: "WebRTC SIP Card",
  description: "A modern WebRTC SIP client card for Home Assistant",
  version: CARD_VERSION,
});

console.info(
  `%c HA-WEBRTC-SIP-CARD %c ${CARD_VERSION} `,
  "color: white; background: #03a9f4; font-weight: bold;",
  "color: #03a9f4; background: white; font-weight: bold;"
);

---

=== Object: 709be8b98c3af0226e5d5df622a49a3ef1b576ee | Date: 2025-09-22 13:01:13 | Type: blob ===

# Multi-stage build for development and production

# Base stage with Node.js
FROM node:20-alpine as base
WORKDIR /workspace
RUN apk add --no-cache git
COPY package*.json ./
RUN npm ci --only=production && npm cache clean --force

# Development stage
FROM base as development
RUN npm ci
COPY . .
EXPOSE 3000 24678
CMD ["npm", "run", "dev"]

# Build stage
FROM base as build
RUN npm ci
COPY . .
RUN npm run build && npm run type-check

# Production stage for serving files
FROM nginx:alpine as production
COPY --from=build /workspace/dist /usr/share/nginx/html
COPY ./nginx.conf /etc/nginx/nginx.conf
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]

# Test stage with built files
FROM node:20-alpine as test
WORKDIR /app
COPY --from=build /workspace/dist ./dist
COPY --from=build /workspace/package*.json ./
RUN npm ci --only=production
EXPOSE 3000
CMD ["npm", "run", "preview"]

---

=== Object: 704d6f0bf6297718578fb7f87b83ed909d5cfaf6 | Date: 2025-09-22 13:01:13 | Type: blob ===

import { debugLog, errorLog } from "./utils";

type SimpleUser = any;
type SimpleUserOptions = any;
let Web: any = null;

export interface SipConfig {
  server: string;
  username: string;
  password: string;
  domain: string;
  websocket_port: number;
  use_secure: boolean;
  display_name?: string;
  debug?: boolean;
}

export interface CallInfo {
  id: string;
  remoteIdentity: string;
  displayName: string;
  state: "incoming" | "outgoing" | "connected" | "ended";
  startTime?: Date;
  duration: number;
}

export class SipManager extends EventTarget {
  private simpleUser: SimpleUser | null = null;
  private config: SipConfig | null = null;
  private isRegistered = false;
  private isConnected = false;
  private connectionTimer: number | null = null;
  private currentCall: CallInfo | null = null;
  private remoteAudio: HTMLAudioElement | null = null;
  private localVideo: HTMLVideoElement | null = null;
  private localStream: MediaStream | null = null;
  private videoEnabled = false;
  private isInitialized = false;
  private isInitializing = false;

  constructor() {
    super();
    this.setupMediaElements();
  }

  private setupMediaElements(): void {
    // Setup remote audio element
    this.remoteAudio = document.createElement("audio");
    this.remoteAudio.autoplay = true;
    this.remoteAudio.style.display = "none";
    document.body.appendChild(this.remoteAudio);

    // Setup local video element (hidden, for capture only)
    this.localVideo = document.createElement("video");
    this.localVideo.autoplay = true;
    this.localVideo.muted = true;
    this.localVideo.playsInline = true;
    this.localVideo.style.display = "none";
    document.body.appendChild(this.localVideo);
  }

  /**
   * Get user media with video constraints
   */
  private async getUserMedia(includeVideo: boolean = false): Promise<MediaStream> {
    const constraints: MediaStreamConstraints = {
      audio: {
        echoCancellation: true,
        noiseSuppression: true,
        autoGainControl: true,
        sampleRate: 48000
      },
      video: includeVideo ? {
        width: { ideal: 640, min: 320, max: 1280 },
        height: { ideal: 480, min: 240, max: 720 },
        frameRate: { ideal: 30, min: 15, max: 30 },
        facingMode: "user"
      } : false
    };

    return navigator.mediaDevices.getUserMedia(constraints);
  }

  /**
   * Enable local video stream
   */
  public async enableVideo(): Promise<void> {
    try {
      // Get new media stream with video
      const stream = await this.getUserMedia(true);
      
      // Update local video element
      if (this.localVideo) {
        this.localVideo.srcObject = stream;
      }

      // Store stream and update state
      this.localStream = stream;
      this.videoEnabled = true;

      debugLog(this.config?.debug || false, "Local video enabled with stream:", {
        videoTracks: stream.getVideoTracks().length,
        audioTracks: stream.getAudioTracks().length
      });

      // If in call, replace tracks in the current session
      if (this.simpleUser?.session && this.currentCall?.state === "connected") {
        await this.replaceMediaTracks(stream);
      }

      // Notify that video state changed
      this.dispatchEvent(
        new CustomEvent("localVideoChanged", {
          detail: { 
            enabled: true,
            transmitting: stream.getVideoTracks().some(track => track.enabled && track.readyState === 'live')
          },
        })
      );

    } catch (error) {
      errorLog("Enable video failed", error);
      throw error;
    }
  }

  /**
   * Disable local video stream
   */
  public async disableVideo(): Promise<void> {
    try {
      if (!this.localStream) return;

      // Get new media stream without video (audio only)
      const audioOnlyStream = await this.getUserMedia(false);

      // Update local video element
      if (this.localVideo) {
        this.localVideo.srcObject = null;
      }

      // Stop video tracks from old stream
      this.localStream.getVideoTracks().forEach(track => track.stop());

      // Update stream and state
      this.localStream = audioOnlyStream;
      this.videoEnabled = false;

      debugLog(this.config?.debug || false, "Local video disabled");

      // If in call, replace tracks in the current session
      if (this.simpleUser?.session && this.currentCall?.state === "connected") {
        await this.replaceMediaTracks(audioOnlyStream);
      }

      this.dispatchEvent(
        new CustomEvent("localVideoChanged", {
          detail: { 
            enabled: false,
            transmitting: false
          },
        })
      );

    } catch (error) {
      errorLog("Disable video failed", error);
      throw error;
    }
  }

  /**
   * Replace media tracks in current session
   */
  private async replaceMediaTracks(newStream: MediaStream): Promise<void> {
    try {
      const session = this.simpleUser?.session;
      if (!session || !session.sessionDescriptionHandler) {
        debugLog(this.config?.debug || false, "No active session to replace tracks");
        return;
      }

      const pc = session.sessionDescriptionHandler.peerConnection;
      if (!pc) {
        debugLog(this.config?.debug || false, "No peer connection found");
        return;
      }

      // Get current senders
      const senders = pc.getSenders();
      
      // Replace audio track
      const audioTrack = newStream.getAudioTracks()[0];
      const audioSender = senders.find(sender => sender.track && sender.track.kind === 'audio');
      if (audioSender && audioTrack) {
        await audioSender.replaceTrack(audioTrack);
        debugLog(this.config?.debug || false, "Audio track replaced");
      }

      // Handle video track
      const videoTrack = newStream.getVideoTracks()[0] || null;
      const videoSender = senders.find(sender => sender.track && sender.track.kind === 'video');
      
      if (videoSender) {
        await videoSender.replaceTrack(videoTrack);
        debugLog(this.config?.debug || false, videoTrack ? "Video track replaced" : "Video track removed");
      } else if (videoTrack) {
        // Add video track if no sender exists
        pc.addTrack(videoTrack, newStream);
        debugLog(this.config?.debug || false, "Video track added to peer connection");
        
        // Renegotiate to establish video
        if (session.invite) {
          await session.invite();
          debugLog(this.config?.debug || false, "Session renegotiated for video");
        }
      }

    } catch (error) {
      errorLog("Replace media tracks failed", error);
      throw error;
    }
  }

  /**
   * Toggle video state
   */
  public async toggleVideo(): Promise<boolean> {
    if (this.videoEnabled) {
      await this.disableVideo();
      return false;
    } else {
      await this.enableVideo();
      return true;
    }
  }

  /**
   * Get current video state
   */
  public getLocalVideoState(): { enabled: boolean; transmitting: boolean } {
    return {
      enabled: this.videoEnabled,
      transmitting: this.localStream ? 
        this.localStream.getVideoTracks().some(track => track.enabled && track.readyState === 'live') : false
    };
  }

  /**
   * Wait for SIP.js library to be fully loaded and functional
   */
  private async waitForSipLibrary(timeout = 15000): Promise<void> {
    return new Promise<void>(async (resolve, reject) => {
      const startTime = Date.now();
      const timeoutId = setTimeout(() => {
        reject(new Error(`SIP.js library loading timeout after ${timeout}ms`));
      }, timeout);

      const checkLibrary = async () => {
        try {
          if (!Web) {
            const SIP = await import("sip.js");
            Web = (SIP as any).Web || SIP;
          }

          const isFullyLoaded =
            Web &&
            Web.SimpleUser &&
            Web.SimpleUser.prototype &&
            typeof Web.SimpleUser.prototype.register === "function" &&
            typeof Web.SimpleUser.prototype.connect === "function" &&
            typeof Web.SimpleUser.prototype.disconnect === "function";

          if (isFullyLoaded) {
            clearTimeout(timeoutId);
            debugLog(this.config?.debug || false, "SIP.js library fully loaded and verified");
            resolve();
            return;
          }

          if (Date.now() - startTime > timeout) {
            clearTimeout(timeoutId);
            reject(new Error("SIP.js library verification timeout"));
            return;
          }

          setTimeout(checkLibrary, 100);
        } catch (error) {
          setTimeout(checkLibrary, 200);
        }
      };

      checkLibrary();
    });
  }

  /**
   * Ensure SIP client is initialized - lazy loading approach
   */
  private async ensureSipClient(): Promise<void> {
    if (this.isInitialized) return;

    if (this.isInitializing) {
      return new Promise((resolve, reject) => {
        const checkInterval = setInterval(() => {
          if (this.isInitialized) {
            clearInterval(checkInterval);
            resolve();
          } else if (!this.isInitializing) {
            clearInterval(checkInterval);
            reject(new Error("Initialization failed"));
          }
        }, 100);
      });
    }

    if (!this.config) {
      throw new Error("SIP configuration not set");
    }

    await this.initialize(this.config);
  }

  /**
   * Set configuration but don't initialize immediately
   */
  setConfig(config: SipConfig): void {
    this.config = config;
    debugLog(config.debug || false, "SIP configuration set, will initialize on first use");
  }

  /**
   * Initialize SIP client with full library loading verification
   */
  async initialize(config: SipConfig): Promise<void> {
    if (this.isInitializing || this.isInitialized) return;

    this.isInitializing = true;
    this.config = config;

    debugLog(config.debug || false, "Starting lazy SIP initialization");

    try {
      await this.waitForSipLibrary();
      await new Promise((resolve) => setTimeout(resolve, 500));

      const wsProtocol = config.use_secure ? "wss" : "ws";
      const wsPort = config.websocket_port || (config.use_secure ? 443 : 80);
      const wsServer = `${wsProtocol}://${config.server}:${wsPort}`;
      const sipAor = `sip:${config.username}@${config.domain}`;

      debugLog(config.debug || false, "WebSocket URL:", wsServer);
      debugLog(config.debug || false, "SIP AOR:", sipAor);

      // Create media helper function that supports video
      const getMediaOptions = (includeVideo: boolean = false) => ({
        constraints: includeVideo ? {
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true
          },
          video: {
            width: { ideal: 640 },
            height: { ideal: 480 },
            frameRate: { ideal: 30 }
          }
        } : {
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true
          },
          video: false
        },
        remote: {
          audio: this.remoteAudio!,
        }
      });

      const options: SimpleUserOptions = {
        aor: sipAor,
        media: getMediaOptions(false), // Start with audio only
        userAgentOptions: {
          authorizationUsername: config.username,
          authorizationPassword: config.password,
          displayName: config.display_name || config.username,
          transportOptions: {
            server: wsServer,
            connectionTimeout: 15,
            maxReconnectionAttempts: 3,
            reconnectionTimeout: 4,
          },
          logLevel: config.debug ? "debug" : "error",
          sessionDescriptionHandlerFactoryOptions: {
            constraints: {
              audio: true,
              video: false,
            },
            peerConnectionConfiguration: {
              iceServers: [
                { urls: "stun:stun.l.google.com:19302" }, 
                { urls: "stun:stun1.l.google.com:19302" }
              ],
            },
          },
        },
      };

      if (!Web || !Web.SimpleUser) {
        throw new Error("SIP.js Web.SimpleUser not available after loading");
      }

      this.simpleUser = new Web.SimpleUser(wsServer, options);

      if (!this.simpleUser) {
        throw new Error("Failed to create SimpleUser instance");
      }

      if (!this.simpleUser.register || typeof this.simpleUser.register !== "function") {
        throw new Error("SimpleUser register method not available - library incomplete");
      }

      debugLog(config.debug || false, "SimpleUser created and verified successfully");

      this.setupEventHandlers();

      debugLog(config.debug || false, `Connecting to: ${wsServer}`);
      await this.simpleUser.connect();

      this.isConnected = true;
      this.dispatchEvent(new CustomEvent("connected"));
      debugLog(config.debug || false, "Connected to WebSocket server");

      debugLog(config.debug || false, "Registering with SIP server...");
      await this.simpleUser.register();

      this.isRegistered = true;
      this.dispatchEvent(new CustomEvent("registered", { detail: { registered: true } }));

      this.startConnectionMonitoring();

      this.isInitialized = true;
      this.isInitializing = false;

      debugLog(config.debug || false, "SIP client lazy initialization completed successfully");
    } catch (error) {
      this.isInitializing = false;
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      errorLog("SIP lazy initialization failed:", errorMessage);

      this.isConnected = false;
      this.isRegistered = false;

      if (this.simpleUser) {
        try {
          await this.simpleUser.disconnect();
        } catch (cleanupError) {
          debugLog(config.debug || false, "Cleanup error", cleanupError);
        }
        this.simpleUser = null;
      }

      this.dispatchEvent(
        new CustomEvent("error", {
          detail: {
            error: errorMessage,
            type: "initialization",
          },
        })
      );

      throw new Error(`Failed to initialize SIP client: ${errorMessage}`);
    }
  }

  private setupEventHandlers(): void {
    if (!this.simpleUser) {
      errorLog("Cannot setup event handlers: SimpleUser is null");
      return;
    }

    debugLog(this.config?.debug || false, "Setting up event handlers");

    this.simpleUser.delegate = {
      onCallCreated: () => {
        debugLog(this.config?.debug || false, "Call created");
        this.dispatchEvent(new CustomEvent("callCreated"));
      },

      onCallReceived: () => {
        debugLog(this.config?.debug || false, "Incoming call received");

        let remoteIdentity = "unknown";
        let displayName = "Unknown Caller";

        try {
          const session = this.simpleUser?.session;
          debugLog(this.config?.debug || false, "Current session:", session);

          if (session) {
            if (session.request) {
              const fromHeader = session.request.getHeader("From");
              debugLog(this.config?.debug || false, "From header:", fromHeader);
              
              if (fromHeader) {
                const uriMatches = fromHeader.match(/<sip:([^@]+)@/) || fromHeader.match(/sip:([^@]+)@/);
                if (uriMatches && uriMatches[1]) {
                  remoteIdentity = uriMatches[1];
                  debugLog(this.config?.debug || false, "Extracted extension from From:", remoteIdentity);
                }
                
                const nameMatches = fromHeader.match(/^"([^"]*)"/) || fromHeader.match(/^([^<]*)</);
                if (nameMatches && nameMatches[1] && nameMatches[1].trim()) {
                  displayName = nameMatches[1].trim();
                  debugLog(this.config?.debug || false, "Extracted display name:", displayName);
                } else if (remoteIdentity !== "unknown") {
                  displayName = remoteIdentity;
                }
              }
            }

            if (remoteIdentity === "unknown" && session.remoteIdentity) {
              debugLog(this.config?.debug || false, "Trying session.remoteIdentity:", session.remoteIdentity);
              
              if (session.remoteIdentity.uri) {
                const uriString = session.remoteIdentity.uri.toString();
                debugLog(this.config?.debug || false, "Remote URI:", uriString);
                
                const matches = uriString.match(/sip:([^@]+)@/);
                if (matches && matches[1]) {
                  remoteIdentity = matches[1];
                  debugLog(this.config?.debug || false, "Extracted from remote URI:", remoteIdentity);
                }
              }
              
              if (session.remoteIdentity.displayName) {
                displayName = session.remoteIdentity.displayName;
                debugLog(this.config?.debug || false, "Remote display name:", displayName);
              } else if (remoteIdentity !== "unknown") {
                displayName = remoteIdentity;
              }
            }
          }
        } catch (error) {
          debugLog(this.config?.debug || false, "Error parsing caller info:", error);
        }

        debugLog(this.config?.debug || false, "Final parsed caller info:", { remoteIdentity, displayName });

        this.currentCall = {
          id: Date.now().toString(),
          remoteIdentity: remoteIdentity,
          displayName: displayName,
          state: "incoming",
          duration: 0,
        };

        this.dispatchEvent(
          new CustomEvent("incomingCall", {
            detail: {
              from: remoteIdentity,
              displayName: displayName,
              callInfo: this.currentCall,
            },
          })
        );
      },

      onCallAnswered: () => {
        if (this.currentCall) {
          this.currentCall.state = "connected";
          this.currentCall.startTime = new Date();
        }

        debugLog(this.config?.debug || false, "Call answered");
        this.dispatchEvent(
          new CustomEvent("callAnswered", {
            detail: { callInfo: this.currentCall },
          })
        );

        this.startCallTimer();
      },

      onCallHangup: () => {
        debugLog(this.config?.debug || false, "Call ended");

        if (this.currentCall) {
          this.currentCall.state = "ended";
        }

        this.stopCallTimer();
        this.dispatchEvent(
          new CustomEvent("callEnded", {
            detail: { callInfo: this.currentCall },
          })
        );

        this.currentCall = null;
      },

      onCallHold: (held: boolean) => {
        debugLog(this.config?.debug || false, "Call hold state changed", held);
        this.dispatchEvent(
          new CustomEvent("callHold", {
            detail: { held, callInfo: this.currentCall },
          })
        );
      },

      onRegistered: () => {
        this.isRegistered = true;
        debugLog(this.config?.debug || false, "Registration successful");
        this.dispatchEvent(new CustomEvent("registered", { detail: { registered: true } }));
      },

      onUnregistered: () => {
        this.isRegistered = false;
        debugLog(this.config?.debug || false, "Unregistered");
        this.dispatchEvent(new CustomEvent("registered", { detail: { registered: false } }));
      },

      onServerConnect: () => {
        this.isConnected = true;
        debugLog(this.config?.debug || false, "Server connected");
        this.dispatchEvent(new CustomEvent("connected"));
      },

      onServerDisconnect: () => {
        this.isConnected = false;
        this.isRegistered = false;
        debugLog(this.config?.debug || false, "Server disconnected");
        this.dispatchEvent(new CustomEvent("disconnected"));
      },
    };
  }

  private callTimer: number | null = null;

  private startCallTimer(): void {
    this.stopCallTimer();
    this.callTimer = window.setInterval(() => {
      if (this.currentCall && this.currentCall.startTime) {
        this.currentCall.duration = Math.floor((Date.now() - this.currentCall.startTime.getTime()) / 1000);
        this.dispatchEvent(
          new CustomEvent("callTimer", {
            detail: { duration: this.currentCall.duration, callInfo: this.currentCall },
          })
        );
      }
    }, 1000);
  }

  private stopCallTimer(): void {
    if (this.callTimer) {
      clearInterval(this.callTimer);
      this.callTimer = null;
    }
  }

  private startConnectionMonitoring(): void {
    this.connectionTimer = window.setInterval(() => {
      const connected = this.simpleUser?.isConnected() || false;

      if (connected !== this.isConnected) {
        this.isConnected = connected;
        this.dispatchEvent(
          new CustomEvent("heartbeat", {
            detail: {
              connected,
              registered: this.isRegistered,
            },
          })
        );
      }
    }, 5000);
  }

  /**
   * Make a call to the specified target
   */
  async makeCall(target: string, includeVideo = false): Promise<void> {
    await this.ensureSipClient();

    if (!this.simpleUser || !this.isRegistered) {
      throw new Error("SIP client not registered");
    }

    if (this.currentCall) {
      throw new Error("Another call is already in progress");
    }

    try {
      const targetUri = `sip:${target}@${this.config!.domain}`;
      debugLog(this.config?.debug || false, "Making call to", targetUri, "with video:", includeVideo);

      // Get media stream for the call
      let mediaStream: MediaStream;
      if (includeVideo) {
        // Enable video if requested and get stream
        if (!this.videoEnabled) {
          await this.enableVideo();
        }
        mediaStream = this.localStream!;
      } else {
        // Get audio-only stream
        mediaStream = await this.getUserMedia(false);
      }

      this.currentCall = {
        id: Date.now().toString(),
        remoteIdentity: target,
        displayName: target,
        state: "outgoing",
        duration: 0,
      };

      // Call with proper media stream
      const callOptions = {
        sessionDescriptionHandlerOptions: {
          constraints: {
            audio: true,
            video: includeVideo
          }
        },
        sessionDescriptionHandlerFactory: (session: any, options: any) => {
          // Pass our media stream to the session
          options.localStream = mediaStream;
          return session.sessionDescriptionHandlerFactory(session, options);
        }
      };

      await this.simpleUser.call(targetUri, callOptions);

      this.dispatchEvent(
        new CustomEvent("callStarted", {
          detail: { 
            target, 
            callInfo: this.currentCall,
            videoEnabled: includeVideo
          },
        })
      );
    } catch (error) {
      errorLog("Call failed", error);
      this.currentCall = null;
      this.dispatchEvent(
        new CustomEvent("callFailed", {
          detail: {
            error: error instanceof Error ? error.message : "Call failed",
            target,
          },
        })
      );
      throw error;
    }
  }

  async answerCall(): Promise<void> {
    await this.ensureSipClient();

    if (!this.simpleUser) {
      throw new Error("SIP client not available");
    }

    try {
      // If video is enabled, get video stream before answering
      let mediaStream: MediaStream;
      if (this.videoEnabled) {
        mediaStream = this.localStream!;
      } else {
        mediaStream = await this.getUserMedia(false);
      }

      const answerOptions = {
        sessionDescriptionHandlerOptions: {
          constraints: {
            audio: true,
            video: this.videoEnabled
          }
        },
        sessionDescriptionHandlerFactory: (session: any, options: any) => {
          options.localStream = mediaStream;
          return session.sessionDescriptionHandlerFactory(session, options);
        }
      };

      await this.simpleUser.answer(answerOptions);
      debugLog(this.config?.debug || false, "Call answered");
    } catch (error) {
      errorLog("Answer call failed", error);
      throw error;
    }
  }

  async rejectCall(): Promise<void> {
    await this.ensureSipClient();

    if (!this.simpleUser) {
      throw new Error("SIP client not available");
    }

    try {
      await this.simpleUser.decline();

      if (this.currentCall) {
        this.currentCall.state = "ended";
      }

      this.currentCall = null;
      debugLog(this.config?.debug || false, "Call rejected");
    } catch (error) {
      errorLog("Reject call failed", error);
      throw error;
    }
  }

  async hangup(): Promise<void> {
    if (!this.simpleUser) return;

    try {
      await this.simpleUser.hangup();
      debugLog(this.config?.debug || false, "Call hung up");
    } catch (error) {
      errorLog("Hangup failed", error);
      throw error;
    }
  }

  async hold(): Promise<void> {
    if (!this.simpleUser) return;

    try {
      await this.simpleUser.hold();
      debugLog(this.config?.debug || false, "Call put on hold");
    } catch (error) {
      errorLog("Hold failed", error);
      throw error;
    }
  }

  async unhold(): Promise<void> {
    if (!this.simpleUser) return;

    try {
      await this.simpleUser.unhold();
      debugLog(this.config?.debug || false, "Call removed from hold");
    } catch (error) {
      errorLog("Unhold failed", error);
      throw error;
    }
  }

  async mute(): Promise<void> {
    if (!this.simpleUser) return;

    try {
      await this.simpleUser.mute();
      debugLog(this.config?.debug || false, "Call muted");
    } catch (error) {
      errorLog("Mute failed", error);
      throw error;
    }
  }

  async unmute(): Promise<void> {
    if (!this.simpleUser) return;

    try {
      await this.simpleUser.unmute();
      debugLog(this.config?.debug || false, "Call unmuted");
    } catch (error) {
      errorLog("Unmute failed", error);
      throw error;
    }
  }

  sendDTMF(tone: string): void {
    if (!this.simpleUser || !this.currentCall) return;

    try {
      if (typeof this.simpleUser.sendDTMF === "function") {
        this.simpleUser.sendDTMF(tone);
        debugLog(this.config?.debug || false, "DTMF sent", tone);

        this.dispatchEvent(
          new CustomEvent("dtmfSent", {
            detail: { tone, callInfo: this.currentCall },
          })
        );
      }
    } catch (error) {
      errorLog("DTMF send failed", error);
    }
  }

  getRemoteVideo(): HTMLVideoElement | null {
    return null;
  }

  getRemoteAudio(): HTMLAudioElement | null {
    return this.remoteAudio;
  }

  getCurrentCall(): CallInfo | null {
    return this.currentCall;
  }

  getConnectionStatus(): { connected: boolean; registered: boolean; initialized: boolean } {
    return {
      connected: this.isConnected,
      registered: this.isRegistered,
      initialized: this.isInitialized,
    };
  }

  async connect(): Promise<void> {
    await this.ensureSipClient();
  }

  async disconnect(): Promise<void> {
    if (this.connectionTimer) {
      clearInterval(this.connectionTimer);
      this.connectionTimer = null;
    }

    this.stopCallTimer();

    if (this.simpleUser) {
      try {
        if (this.currentCall) {
          await this.hangup();
        }

        if (this.isRegistered) {
          await this.simpleUser.unregister();
        }

        if (this.isConnected) {
          await this.simpleUser.disconnect();
        }
      } catch (error) {
        errorLog("Disconnect error", error);
      }

      this.simpleUser = null;
    }

    // Cleanup video and audio resources
    try {
      if (this.localStream) {
        this.localStream.getTracks().forEach(track => track.stop());
        this.localStream = null;
      }

      if (this.localVideo && this.localVideo.parentNode) {
        this.localVideo.pause();
        this.localVideo.srcObject = null;
        this.localVideo.parentNode.removeChild(this.localVideo);
        this.localVideo = null;
      }

      this.videoEnabled = false;

      if (this.remoteAudio && this.remoteAudio.parentNode) {
        this.remoteAudio.pause();
        this.remoteAudio.srcObject = null;
        this.remoteAudio.parentNode.removeChild(this.remoteAudio);
        this.remoteAudio = null;
      }
    } catch (error) {
      errorLog("Error cleaning up media resources:", error);
    }

    this.isConnected = false;
    this.isRegistered = false;
    this.isInitialized = false;
    this.isInitializing = false;
    this.currentCall = null;

    debugLog(this.config?.debug || false, "SIP client disconnected");
  }
}
---

=== Object: 295155e8bafa93a5e8a85c131e174e5ff472d725 | Date: 2025-09-22 13:01:13 | Type: blob ===

{
  "name": "ha-webrtc-sip-card",
  "version": "1.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "ha-webrtc-sip-card",
      "version": "1.0.0",
      "license": "MIT",
      "dependencies": {
        "custom-card-helpers": "^1.9.0",
        "lit": "^3.1.2",
        "sip.js": "^0.21.2"
      },
      "devDependencies": {
        "@typescript-eslint/eslint-plugin": "^6.21.0",
        "@typescript-eslint/parser": "^6.21.0",
        "eslint": "^8.57.0",
        "typescript": "^5.4.3",
        "vite": "^5.2.8"
      }
    },
    "node_modules/@esbuild/aix-ppc64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/aix-ppc64/-/aix-ppc64-0.21.5.tgz",
      "integrity": "sha512-1SDgH6ZSPTlggy1yI6+Dbkiz8xzpHJEVAlF/AM1tHPLsf5STom9rwtjE4hKAF20FfXXNTFqEYXyJNWh1GiZedQ==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "aix"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/android-arm": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/android-arm/-/android-arm-0.21.5.tgz",
      "integrity": "sha512-vCPvzSjpPHEi1siZdlvAlsPxXl7WbOVUBBAowWug4rJHb68Ox8KualB+1ocNvT5fjv6wpkX6o/iEpbDrf68zcg==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/android-arm64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/android-arm64/-/android-arm64-0.21.5.tgz",
      "integrity": "sha512-c0uX9VAUBQ7dTDCjq+wdyGLowMdtR/GoC2U5IYk/7D1H1JYC0qseD7+11iMP2mRLN9RcCMRcjC4YMclCzGwS/A==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/android-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/android-x64/-/android-x64-0.21.5.tgz",
      "integrity": "sha512-D7aPRUUNHRBwHxzxRvp856rjUHRFW1SdQATKXH2hqA0kAZb1hKmi02OpYRacl0TxIGz/ZmXWlbZgjwWYaCakTA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/darwin-arm64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/darwin-arm64/-/darwin-arm64-0.21.5.tgz",
      "integrity": "sha512-DwqXqZyuk5AiWWf3UfLiRDJ5EDd49zg6O9wclZ7kUMv2WRFr4HKjXp/5t8JZ11QbQfUS6/cRCKGwYhtNAY88kQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/darwin-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/darwin-x64/-/darwin-x64-0.21.5.tgz",
      "integrity": "sha512-se/JjF8NlmKVG4kNIuyWMV/22ZaerB+qaSi5MdrXtd6R08kvs2qCN4C09miupktDitvh8jRFflwGFBQcxZRjbw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/freebsd-arm64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/freebsd-arm64/-/freebsd-arm64-0.21.5.tgz",
      "integrity": "sha512-5JcRxxRDUJLX8JXp/wcBCy3pENnCgBR9bN6JsY4OmhfUtIHe3ZW0mawA7+RDAcMLrMIZaf03NlQiX9DGyB8h4g==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/freebsd-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/freebsd-x64/-/freebsd-x64-0.21.5.tgz",
      "integrity": "sha512-J95kNBj1zkbMXtHVH29bBriQygMXqoVQOQYA+ISs0/2l3T9/kj42ow2mpqerRBxDJnmkUDCaQT/dfNXWX/ZZCQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-arm": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-arm/-/linux-arm-0.21.5.tgz",
      "integrity": "sha512-bPb5AHZtbeNGjCKVZ9UGqGwo8EUu4cLq68E95A53KlxAPRmUyYv2D6F0uUI65XisGOL1hBP5mTronbgo+0bFcA==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-arm64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-arm64/-/linux-arm64-0.21.5.tgz",
      "integrity": "sha512-ibKvmyYzKsBeX8d8I7MH/TMfWDXBF3db4qM6sy+7re0YXya+K1cem3on9XgdT2EQGMu4hQyZhan7TeQ8XkGp4Q==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-ia32": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-ia32/-/linux-ia32-0.21.5.tgz",
      "integrity": "sha512-YvjXDqLRqPDl2dvRODYmmhz4rPeVKYvppfGYKSNGdyZkA01046pLWyRKKI3ax8fbJoK5QbxblURkwK/MWY18Tg==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-loong64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-loong64/-/linux-loong64-0.21.5.tgz",
      "integrity": "sha512-uHf1BmMG8qEvzdrzAqg2SIG/02+4/DHB6a9Kbya0XDvwDEKCoC8ZRWI5JJvNdUjtciBGFQ5PuBlpEOXQj+JQSg==",
      "cpu": [
        "loong64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-mips64el": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-mips64el/-/linux-mips64el-0.21.5.tgz",
      "integrity": "sha512-IajOmO+KJK23bj52dFSNCMsz1QP1DqM6cwLUv3W1QwyxkyIWecfafnI555fvSGqEKwjMXVLokcV5ygHW5b3Jbg==",
      "cpu": [
        "mips64el"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-ppc64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-ppc64/-/linux-ppc64-0.21.5.tgz",
      "integrity": "sha512-1hHV/Z4OEfMwpLO8rp7CvlhBDnjsC3CttJXIhBi+5Aj5r+MBvy4egg7wCbe//hSsT+RvDAG7s81tAvpL2XAE4w==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-riscv64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-riscv64/-/linux-riscv64-0.21.5.tgz",
      "integrity": "sha512-2HdXDMd9GMgTGrPWnJzP2ALSokE/0O5HhTUvWIbD3YdjME8JwvSCnNGBnTThKGEB91OZhzrJ4qIIxk/SBmyDDA==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-s390x": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-s390x/-/linux-s390x-0.21.5.tgz",
      "integrity": "sha512-zus5sxzqBJD3eXxwvjN1yQkRepANgxE9lgOW2qLnmr8ikMTphkjgXu1HR01K4FJg8h1kEEDAqDcZQtbrRnB41A==",
      "cpu": [
        "s390x"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/linux-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-x64/-/linux-x64-0.21.5.tgz",
      "integrity": "sha512-1rYdTpyv03iycF1+BhzrzQJCdOuAOtaqHTWJZCWvijKD2N5Xu0TtVC8/+1faWqcP9iBCWOmjmhoH94dH82BxPQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/netbsd-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/netbsd-x64/-/netbsd-x64-0.21.5.tgz",
      "integrity": "sha512-Woi2MXzXjMULccIwMnLciyZH4nCIMpWQAs049KEeMvOcNADVxo0UBIQPfSmxB3CWKedngg7sWZdLvLczpe0tLg==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "netbsd"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/openbsd-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/openbsd-x64/-/openbsd-x64-0.21.5.tgz",
      "integrity": "sha512-HLNNw99xsvx12lFBUwoT8EVCsSvRNDVxNpjZ7bPn947b8gJPzeHWyNVhFsaerc0n3TsbOINvRP2byTZ5LKezow==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openbsd"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/sunos-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/sunos-x64/-/sunos-x64-0.21.5.tgz",
      "integrity": "sha512-6+gjmFpfy0BHU5Tpptkuh8+uw3mnrvgs+dSPQXQOv3ekbordwnzTVEb4qnIvQcYXq6gzkyTnoZ9dZG+D4garKg==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "sunos"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/win32-arm64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-arm64/-/win32-arm64-0.21.5.tgz",
      "integrity": "sha512-Z0gOTd75VvXqyq7nsl93zwahcTROgqvuAcYDUr+vOv8uHhNSKROyU961kgtCD1e95IqPKSQKH7tBTslnS3tA8A==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/win32-ia32": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-ia32/-/win32-ia32-0.21.5.tgz",
      "integrity": "sha512-SWXFF1CL2RVNMaVs+BBClwtfZSvDgtL//G/smwAc5oVK/UPu2Gu9tIaRgFmYFFKrmg3SyAjSrElf0TiJ1v8fYA==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@esbuild/win32-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-x64/-/win32-x64-0.21.5.tgz",
      "integrity": "sha512-tQd/1efJuzPC6rCFwEvLtci/xNFcTZknmXs98FYDfGE4wP9ClFV98nyKrzJKVPMhdDnjzLhdUyMX4PsQAPjwIw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@eslint-community/eslint-utils": {
      "version": "4.9.0",
      "resolved": "https://registry.npmjs.org/@eslint-community/eslint-utils/-/eslint-utils-4.9.0.tgz",
      "integrity": "sha512-ayVFHdtZ+hsq1t2Dy24wCmGXGe4q9Gu3smhLYALJrr473ZH27MsnSL+LKUlimp4BWJqMDMLmPpx/Q9R3OAlL4g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "eslint-visitor-keys": "^3.4.3"
      },
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      },
      "peerDependencies": {
        "eslint": "^6.0.0 || ^7.0.0 || >=8.0.0"
      }
    },
    "node_modules/@eslint-community/regexpp": {
      "version": "4.12.1",
      "resolved": "https://registry.npmjs.org/@eslint-community/regexpp/-/regexpp-4.12.1.tgz",
      "integrity": "sha512-CCZCDJuduB9OUkFkY2IgppNZMi2lBQgD2qzwXkEia16cge2pijY/aXi96CJMquDMn3nJdlPV1A5KrJEXwfLNzQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^12.0.0 || ^14.0.0 || >=16.0.0"
      }
    },
    "node_modules/@eslint/eslintrc": {
      "version": "2.1.4",
      "resolved": "https://registry.npmjs.org/@eslint/eslintrc/-/eslintrc-2.1.4.tgz",
      "integrity": "sha512-269Z39MS6wVJtsoUl10L60WdkhJVdPG24Q4eZTH3nnF6lpvSShEK3wQjDX9JRWAUPvPh7COouPpU9IrqaZFvtQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ajv": "^6.12.4",
        "debug": "^4.3.2",
        "espree": "^9.6.0",
        "globals": "^13.19.0",
        "ignore": "^5.2.0",
        "import-fresh": "^3.2.1",
        "js-yaml": "^4.1.0",
        "minimatch": "^3.1.2",
        "strip-json-comments": "^3.1.1"
      },
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/@eslint/eslintrc/node_modules/brace-expansion": {
      "version": "1.1.12",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.12.tgz",
      "integrity": "sha512-9T9UjW3r0UW5c1Q7GTwllptXwhvYmEzFhzMfZ9H7FQWt+uZePjZPjBP/W1ZEyZ1twGWom5/56TF4lPcqjnDHcg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "balanced-match": "^1.0.0",
        "concat-map": "0.0.1"
      }
    },
    "node_modules/@eslint/eslintrc/node_modules/minimatch": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz",
      "integrity": "sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "brace-expansion": "^1.1.7"
      },
      "engines": {
        "node": "*"
      }
    },
    "node_modules/@eslint/js": {
      "version": "8.57.1",
      "resolved": "https://registry.npmjs.org/@eslint/js/-/js-8.57.1.tgz",
      "integrity": "sha512-d9zaMRSTIKDLhctzH12MtXvJKSSUhaHcjV+2Z+GK+EEY7XKpP5yR4x+N3TAcHTcu963nIr+TMcCb4DBCYX1z6Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      }
    },
    "node_modules/@formatjs/ecma402-abstract": {
      "version": "1.11.4",
      "resolved": "https://registry.npmjs.org/@formatjs/ecma402-abstract/-/ecma402-abstract-1.11.4.tgz",
      "integrity": "sha512-EBikYFp2JCdIfGEb5G9dyCkTGDmC57KSHhRQOC3aYxoPWVZvfWCDjZwkGYHN7Lis/fmuWl906bnNTJifDQ3sXw==",
      "license": "MIT",
      "dependencies": {
        "@formatjs/intl-localematcher": "0.2.25",
        "tslib": "^2.1.0"
      }
    },
    "node_modules/@formatjs/fast-memoize": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/@formatjs/fast-memoize/-/fast-memoize-1.2.1.tgz",
      "integrity": "sha512-Rg0e76nomkz3vF9IPlKeV+Qynok0r7YZjL6syLz4/urSg0IbjPZCB/iYUMNsYA643gh4mgrX3T7KEIFIxJBQeg==",
      "license": "MIT",
      "dependencies": {
        "tslib": "^2.1.0"
      }
    },
    "node_modules/@formatjs/icu-messageformat-parser": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/@formatjs/icu-messageformat-parser/-/icu-messageformat-parser-2.1.0.tgz",
      "integrity": "sha512-Qxv/lmCN6hKpBSss2uQ8IROVnta2r9jd3ymUEIjm2UyIkUCHVcbUVRGL/KS/wv7876edvsPe+hjHVJ4z8YuVaw==",
      "license": "MIT",
      "dependencies": {
        "@formatjs/ecma402-abstract": "1.11.4",
        "@formatjs/icu-skeleton-parser": "1.3.6",
        "tslib": "^2.1.0"
      }
    },
    "node_modules/@formatjs/icu-skeleton-parser": {
      "version": "1.3.6",
      "resolved": "https://registry.npmjs.org/@formatjs/icu-skeleton-parser/-/icu-skeleton-parser-1.3.6.tgz",
      "integrity": "sha512-I96mOxvml/YLrwU2Txnd4klA7V8fRhb6JG/4hm3VMNmeJo1F03IpV2L3wWt7EweqNLES59SZ4d6hVOPCSf80Bg==",
      "license": "MIT",
      "dependencies": {
        "@formatjs/ecma402-abstract": "1.11.4",
        "tslib": "^2.1.0"
      }
    },
    "node_modules/@formatjs/intl-localematcher": {
      "version": "0.2.25",
      "resolved": "https://registry.npmjs.org/@formatjs/intl-localematcher/-/intl-localematcher-0.2.25.tgz",
      "integrity": "sha512-YmLcX70BxoSopLFdLr1Ds99NdlTI2oWoLbaUW2M406lxOIPzE1KQhRz2fPUkq34xVZQaihCoU29h0KK7An3bhA==",
      "license": "MIT",
      "dependencies": {
        "tslib": "^2.1.0"
      }
    },
    "node_modules/@formatjs/intl-utils": {
      "version": "3.8.4",
      "resolved": "https://registry.npmjs.org/@formatjs/intl-utils/-/intl-utils-3.8.4.tgz",
      "integrity": "sha512-j5C6NyfKevIxsfLK8KwO1C0vvP7k1+h4A9cFpc+cr6mEwCc1sPkr17dzh0Ke6k9U5pQccAQoXdcNBl3IYa4+ZQ==",
      "deprecated": "the package is rather renamed to @formatjs/ecma-abstract with some changes in functionality (primarily selectUnit is removed and we don't plan to make any further changes to this package",
      "license": "MIT",
      "dependencies": {
        "emojis-list": "^3.0.0"
      }
    },
    "node_modules/@humanwhocodes/config-array": {
      "version": "0.13.0",
      "resolved": "https://registry.npmjs.org/@humanwhocodes/config-array/-/config-array-0.13.0.tgz",
      "integrity": "sha512-DZLEEqFWQFiyK6h5YIeynKx7JlvCYWL0cImfSRXZ9l4Sg2efkFGTuFf6vzXjK1cq6IYkU+Eg/JizXw+TD2vRNw==",
      "deprecated": "Use @eslint/config-array instead",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@humanwhocodes/object-schema": "^2.0.3",
        "debug": "^4.3.1",
        "minimatch": "^3.0.5"
      },
      "engines": {
        "node": ">=10.10.0"
      }
    },
    "node_modules/@humanwhocodes/config-array/node_modules/brace-expansion": {
      "version": "1.1.12",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.12.tgz",
      "integrity": "sha512-9T9UjW3r0UW5c1Q7GTwllptXwhvYmEzFhzMfZ9H7FQWt+uZePjZPjBP/W1ZEyZ1twGWom5/56TF4lPcqjnDHcg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "balanced-match": "^1.0.0",
        "concat-map": "0.0.1"
      }
    },
    "node_modules/@humanwhocodes/config-array/node_modules/minimatch": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz",
      "integrity": "sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "brace-expansion": "^1.1.7"
      },
      "engines": {
        "node": "*"
      }
    },
    "node_modules/@humanwhocodes/module-importer": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/@humanwhocodes/module-importer/-/module-importer-1.0.1.tgz",
      "integrity": "sha512-bxveV4V8v5Yb4ncFTT3rPSgZBOpCkjfK0y4oVVVJwIuDVBRMDXrPyXRL988i5ap9m9bnyEEjWfm5WkBmtffLfA==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">=12.22"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/nzakas"
      }
    },
    "node_modules/@humanwhocodes/object-schema": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/@humanwhocodes/object-schema/-/object-schema-2.0.3.tgz",
      "integrity": "sha512-93zYdMES/c1D69yZiKDBj0V24vqNzB/koF26KPaagAfd3P/4gUlh3Dys5ogAK+Exi9QyzlD8x/08Zt7wIKcDcA==",
      "deprecated": "Use @eslint/object-schema instead",
      "dev": true,
      "license": "BSD-3-Clause"
    },
    "node_modules/@lit-labs/ssr-dom-shim": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/@lit-labs/ssr-dom-shim/-/ssr-dom-shim-1.4.0.tgz",
      "integrity": "sha512-ficsEARKnmmW5njugNYKipTm4SFnbik7CXtoencDZzmzo/dQ+2Q0bgkzJuoJP20Aj0F+izzJjOqsnkd6F/o1bw==",
      "license": "BSD-3-Clause"
    },
    "node_modules/@lit/reactive-element": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/@lit/reactive-element/-/reactive-element-2.1.1.tgz",
      "integrity": "sha512-N+dm5PAYdQ8e6UlywyyrgI2t++wFGXfHx+dSJ1oBrg6FAxUj40jId++EaRm80MKX5JnlH1sBsyZ5h0bcZKemCg==",
      "license": "BSD-3-Clause",
      "dependencies": {
        "@lit-labs/ssr-dom-shim": "^1.4.0"
      }
    },
    "node_modules/@nodelib/fs.scandir": {
      "version": "2.1.5",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.scandir/-/fs.scandir-2.1.5.tgz",
      "integrity": "sha512-vq24Bq3ym5HEQm2NKCr3yXDwjc7vTsEThRDnkp2DK9p1uqLR+DHurm/NOTo0KG7HYHU7eppKZj3MyqYuMBf62g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@nodelib/fs.stat": "2.0.5",
        "run-parallel": "^1.1.9"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/@nodelib/fs.stat": {
      "version": "2.0.5",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.stat/-/fs.stat-2.0.5.tgz",
      "integrity": "sha512-RkhPPp2zrqDAQA/2jNhnztcPAlv64XdhIp7a7454A5ovI7Bukxgt7MX7udwAu3zg1DcpPU0rz3VV1SeaqvY4+A==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/@nodelib/fs.walk": {
      "version": "1.2.8",
      "resolved": "https://registry.npmjs.org/@nodelib/fs.walk/-/fs.walk-1.2.8.tgz",
      "integrity": "sha512-oGB+UxlgWcgQkgwo8GcEGwemoTFt3FIO9ababBmaGwXIoBKZ+GTy0pP185beGg7Llih/NSHSV2XAs1lnznocSg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@nodelib/fs.scandir": "2.1.5",
        "fastq": "^1.6.0"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/@rollup/rollup-android-arm-eabi": {
      "version": "4.52.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm-eabi/-/rollup-android-arm-eabi-4.52.0.tgz",
      "integrity": "sha512-VxDYCDqOaR7NXzAtvRx7G1u54d2kEHopb28YH/pKzY6y0qmogP3gG7CSiWsq9WvDFxOQMpNEyjVAHZFXfH3o/A==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ]
    },
    "node_modules/@rollup/rollup-android-arm64": {
      "version": "4.52.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm64/-/rollup-android-arm64-4.52.0.tgz",
      "integrity": "sha512-pqDirm8koABIKvzL59YI9W9DWbRlTX7RWhN+auR8HXJxo89m4mjqbah7nJZjeKNTNYopqL+yGg+0mhCpf3xZtQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ]
    },
    "node_modules/@rollup/rollup-darwin-arm64": {
      "version": "4.52.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-darwin-arm64/-/rollup-darwin-arm64-4.52.0.tgz",
      "integrity": "sha512-YCdWlY/8ltN6H78HnMsRHYlPiKvqKagBP1r+D7SSylxX+HnsgXGCmLiV3Y4nSyY9hW8qr8U9LDUx/Lo7M6MfmQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ]
    },
    "node_modules/@rollup/rollup-darwin-x64": {
      "version": "4.52.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-darwin-x64/-/rollup-darwin-x64-4.52.0.tgz",
      "integrity": "sha512-z4nw6y1j+OOSGzuVbSWdIp1IUks9qNw4dc7z7lWuWDKojY38VMWBlEN7F9jk5UXOkUcp97vA1N213DF+Lz8BRg==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ]
    },
    "node_modules/@rollup/rollup-freebsd-arm64": {
      "version": "4.52.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-freebsd-arm64/-/rollup-freebsd-arm64-4.52.0.tgz",
      "integrity": "sha512-Q/dv9Yvyr5rKlK8WQJZVrp5g2SOYeZUs9u/t2f9cQ2E0gJjYB/BWoedXfUT0EcDJefi2zzVfhcOj8drWCzTviw==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ]
    },
    "node_modules/@rollup/rollup-freebsd-x64": {
      "version": "4.52.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-freebsd-x64/-/rollup-freebsd-x64-4.52.0.tgz",
      "integrity": "sha512-kdBsLs4Uile/fbjZVvCRcKB4q64R+1mUq0Yd7oU1CMm1Av336ajIFqNFovByipciuUQjBCPMxwJhCgfG2re3rg==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm-gnueabihf": {
      "version": "4.52.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm-gnueabihf/-/rollup-linux-arm-gnueabihf-4.52.0.tgz",
      "integrity": "sha512-aL6hRwu0k7MTUESgkg7QHY6CoqPgr6gdQXRJI1/VbFlUMwsSzPGSR7sG5d+MCbYnJmJwThc2ol3nixj1fvI/zQ==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm-musleabihf": {
      "version": "4.52.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm-musleabihf/-/rollup-linux-arm-musleabihf-4.52.0.tgz",
      "integrity": "sha512-BTs0M5s1EJejgIBJhCeiFo7GZZ2IXWkFGcyZhxX4+8usnIo5Mti57108vjXFIQmmJaRyDwmV59Tw64Ap1dkwMw==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm64-gnu": {
      "version": "4.52.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm64-gnu/-/rollup-linux-arm64-gnu-4.52.0.tgz",
      "integrity": "sha512-uj672IVOU9m08DBGvoPKPi/J8jlVgjh12C9GmjjBxCTQc3XtVmRkRKyeHSmIKQpvJ7fIm1EJieBUcnGSzDVFyw==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-arm64-musl": {
      "version": "4.52.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm64-musl/-/rollup-linux-arm64-musl-4.52.0.tgz",
      "integrity": "sha512-/+IVbeDMDCtB/HP/wiWsSzduD10SEGzIZX2945KSgZRNi4TSkjHqRJtNTVtVb8IRwhJ65ssI56krlLik+zFWkw==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-loong64-gnu": {
      "version": "4.52.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-loong64-gnu/-/rollup-linux-loong64-gnu-4.52.0.tgz",
      "integrity": "sha512-U1vVzvSWtSMWKKrGoROPBXMh3Vwn93TA9V35PldokHGqiUbF6erSzox/5qrSMKp6SzakvyjcPiVF8yB1xKr9Pg==",
      "cpu": [
        "loong64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-ppc64-gnu": {
      "version": "4.52.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-ppc64-gnu/-/rollup-linux-ppc64-gnu-4.52.0.tgz",
      "integrity": "sha512-X/4WfuBAdQRH8cK3DYl8zC00XEE6aM472W+QCycpQJeLWVnHfkv7RyBFVaTqNUMsTgIX8ihMjCvFF9OUgeABzw==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-riscv64-gnu": {
      "version": "4.52.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-riscv64-gnu/-/rollup-linux-riscv64-gnu-4.52.0.tgz",
      "integrity": "sha512-xIRYc58HfWDBZoLmWfWXg2Sq8VCa2iJ32B7mqfWnkx5mekekl0tMe7FHpY8I72RXEcUkaWawRvl3qA55og+cwQ==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-riscv64-musl": {
      "version": "4.52.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-riscv64-musl/-/rollup-linux-riscv64-musl-4.52.0.tgz",
      "integrity": "sha512-mbsoUey05WJIOz8U1WzNdf+6UMYGwE3fZZnQqsM22FZ3wh1N887HT6jAOjXs6CNEK3Ntu2OBsyQDXfIjouI4dw==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-s390x-gnu": {
      "version": "4.52.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-s390x-gnu/-/rollup-linux-s390x-gnu-4.52.0.tgz",
      "integrity": "sha512-qP6aP970bucEi5KKKR4AuPFd8aTx9EF6BvutvYxmZuWLJHmnq4LvBfp0U+yFDMGwJ+AIJEH5sIP+SNypauMWzg==",
      "cpu": [
        "s390x"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-x64-gnu": {
      "version": "4.52.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-x64-gnu/-/rollup-linux-x64-gnu-4.52.0.tgz",
      "integrity": "sha512-nmSVN+F2i1yKZ7rJNKO3G7ZzmxJgoQBQZ/6c4MuS553Grmr7WqR7LLDcYG53Z2m9409z3JLt4sCOhLdbKQ3HmA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-linux-x64-musl": {
      "version": "4.52.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-x64-musl/-/rollup-linux-x64-musl-4.52.0.tgz",
      "integrity": "sha512-2d0qRo33G6TfQVjaMR71P+yJVGODrt5V6+T0BDYH4EMfGgdC/2HWDVjSSFw888GSzAZUwuska3+zxNUCDco6rQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/@rollup/rollup-openharmony-arm64": {
      "version": "4.52.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-openharmony-arm64/-/rollup-openharmony-arm64-4.52.0.tgz",
      "integrity": "sha512-A1JalX4MOaFAAyGgpO7XP5khquv/7xKzLIyLmhNrbiCxWpMlnsTYr8dnsWM7sEeotNmxvSOEL7F65j0HXFcFsw==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openharmony"
      ]
    },
    "node_modules/@rollup/rollup-win32-arm64-msvc": {
      "version": "4.52.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-arm64-msvc/-/rollup-win32-arm64-msvc-4.52.0.tgz",
      "integrity": "sha512-YQugafP/rH0eOOHGjmNgDURrpYHrIX0yuojOI8bwCyXwxC9ZdTd3vYkmddPX0oHONLXu9Rb1dDmT0VNpjkzGGw==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@rollup/rollup-win32-ia32-msvc": {
      "version": "4.52.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-ia32-msvc/-/rollup-win32-ia32-msvc-4.52.0.tgz",
      "integrity": "sha512-zYdUYhi3Qe2fndujBqL5FjAFzvNeLxtIqfzNEVKD1I7C37/chv1VxhscWSQHTNfjPCrBFQMnynwA3kpZpZ8w4A==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@rollup/rollup-win32-x64-gnu": {
      "version": "4.52.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-x64-gnu/-/rollup-win32-x64-gnu-4.52.0.tgz",
      "integrity": "sha512-fGk03kQylNaCOQ96HDMeT7E2n91EqvCDd3RwvT5k+xNdFCeMGnj5b5hEgTGrQuyidqSsD3zJDQ21QIaxXqTBJw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@rollup/rollup-win32-x64-msvc": {
      "version": "4.52.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-x64-msvc/-/rollup-win32-x64-msvc-4.52.0.tgz",
      "integrity": "sha512-6iKDCVSIUQ8jPMoIV0OytRKniaYyy5EbY/RRydmLW8ZR3cEBhxbWl5ro0rkUNe0ef6sScvhbY79HrjRm8i3vDQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@types/estree": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/@types/estree/-/estree-1.0.8.tgz",
      "integrity": "sha512-dWHzHa2WqEXI/O1E9OjrocMTKJl2mSrEolh1Iomrv6U+JuNwaHXsXx9bLu5gG7BUWFIN0skIQJQ/L1rIex4X6w==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/json-schema": {
      "version": "7.0.15",
      "resolved": "https://registry.npmjs.org/@types/json-schema/-/json-schema-7.0.15.tgz",
      "integrity": "sha512-5+fP8P8MFNC+AyZCDxrB2pkZFPGzqQWUzpSeuuVLvm8VMcorNYavBqoFcxK8bQz4Qsbn4oUEEem4wDLfcysGHA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/semver": {
      "version": "7.7.1",
      "resolved": "https://registry.npmjs.org/@types/semver/-/semver-7.7.1.tgz",
      "integrity": "sha512-FmgJfu+MOcQ370SD0ev7EI8TlCAfKYU+B4m5T3yXc1CiRN94g/SZPtsCkk506aUDtlMnFZvasDwHHUcZUEaYuA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/trusted-types": {
      "version": "2.0.7",
      "resolved": "https://registry.npmjs.org/@types/trusted-types/-/trusted-types-2.0.7.tgz",
      "integrity": "sha512-ScaPdn1dQczgbl0QFTeTOmVHFULt394XJgOQNoyVhZ6r2vLnMLJfBPd53SB52T/3G36VI1/g2MZaX0cwDuXsfw==",
      "license": "MIT"
    },
    "node_modules/@typescript-eslint/eslint-plugin": {
      "version": "6.21.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/eslint-plugin/-/eslint-plugin-6.21.0.tgz",
      "integrity": "sha512-oy9+hTPCUFpngkEZUSzbf9MxI65wbKFoQYsgPdILTfbUldp5ovUuphZVe4i30emU9M/kP+T64Di0mxl7dSw3MA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@eslint-community/regexpp": "^4.5.1",
        "@typescript-eslint/scope-manager": "6.21.0",
        "@typescript-eslint/type-utils": "6.21.0",
        "@typescript-eslint/utils": "6.21.0",
        "@typescript-eslint/visitor-keys": "6.21.0",
        "debug": "^4.3.4",
        "graphemer": "^1.4.0",
        "ignore": "^5.2.4",
        "natural-compare": "^1.4.0",
        "semver": "^7.5.4",
        "ts-api-utils": "^1.0.1"
      },
      "engines": {
        "node": "^16.0.0 || >=18.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "@typescript-eslint/parser": "^6.0.0 || ^6.0.0-alpha",
        "eslint": "^7.0.0 || ^8.0.0"
      },
      "peerDependenciesMeta": {
        "typescript": {
          "optional": true
        }
      }
    },
    "node_modules/@typescript-eslint/parser": {
      "version": "6.21.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/parser/-/parser-6.21.0.tgz",
      "integrity": "sha512-tbsV1jPne5CkFQCgPBcDOt30ItF7aJoZL997JSF7MhGQqOeT3svWRYxiqlfA5RUdlHN6Fi+EI9bxqbdyAUZjYQ==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "@typescript-eslint/scope-manager": "6.21.0",
        "@typescript-eslint/types": "6.21.0",
        "@typescript-eslint/typescript-estree": "6.21.0",
        "@typescript-eslint/visitor-keys": "6.21.0",
        "debug": "^4.3.4"
      },
      "engines": {
        "node": "^16.0.0 || >=18.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "eslint": "^7.0.0 || ^8.0.0"
      },
      "peerDependenciesMeta": {
        "typescript": {
          "optional": true
        }
      }
    },
    "node_modules/@typescript-eslint/scope-manager": {
      "version": "6.21.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/scope-manager/-/scope-manager-6.21.0.tgz",
      "integrity": "sha512-OwLUIWZJry80O99zvqXVEioyniJMa+d2GrqpUTqi5/v5D5rOrppJVBPa0yKCblcigC0/aYAzxxqQ1B+DS2RYsg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@typescript-eslint/types": "6.21.0",
        "@typescript-eslint/visitor-keys": "6.21.0"
      },
      "engines": {
        "node": "^16.0.0 || >=18.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      }
    },
    "node_modules/@typescript-eslint/type-utils": {
      "version": "6.21.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/type-utils/-/type-utils-6.21.0.tgz",
      "integrity": "sha512-rZQI7wHfao8qMX3Rd3xqeYSMCL3SoiSQLBATSiVKARdFGCYSRvmViieZjqc58jKgs8Y8i9YvVVhRbHSTA4VBag==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@typescript-eslint/typescript-estree": "6.21.0",
        "@typescript-eslint/utils": "6.21.0",
        "debug": "^4.3.4",
        "ts-api-utils": "^1.0.1"
      },
      "engines": {
        "node": "^16.0.0 || >=18.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "eslint": "^7.0.0 || ^8.0.0"
      },
      "peerDependenciesMeta": {
        "typescript": {
          "optional": true
        }
      }
    },
    "node_modules/@typescript-eslint/types": {
      "version": "6.21.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/types/-/types-6.21.0.tgz",
      "integrity": "sha512-1kFmZ1rOm5epu9NZEZm1kckCDGj5UJEf7P1kliH4LKu/RkwpsfqqGmY2OOcUs18lSlQBKLDYBOGxRVtrMN5lpg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^16.0.0 || >=18.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      }
    },
    "node_modules/@typescript-eslint/typescript-estree": {
      "version": "6.21.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/typescript-estree/-/typescript-estree-6.21.0.tgz",
      "integrity": "sha512-6npJTkZcO+y2/kr+z0hc4HwNfrrP4kNYh57ek7yCNlrBjWQ1Y0OS7jiZTkgumrvkX5HkEKXFZkkdFNkaW2wmUQ==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "@typescript-eslint/types": "6.21.0",
        "@typescript-eslint/visitor-keys": "6.21.0",
        "debug": "^4.3.4",
        "globby": "^11.1.0",
        "is-glob": "^4.0.3",
        "minimatch": "9.0.3",
        "semver": "^7.5.4",
        "ts-api-utils": "^1.0.1"
      },
      "engines": {
        "node": "^16.0.0 || >=18.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependenciesMeta": {
        "typescript": {
          "optional": true
        }
      }
    },
    "node_modules/@typescript-eslint/utils": {
      "version": "6.21.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/utils/-/utils-6.21.0.tgz",
      "integrity": "sha512-NfWVaC8HP9T8cbKQxHcsJBY5YE1O33+jpMwN45qzWWaPDZgLIbo12toGMWnmhvCpd3sIxkpDw3Wv1B3dYrbDQQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@eslint-community/eslint-utils": "^4.4.0",
        "@types/json-schema": "^7.0.12",
        "@types/semver": "^7.5.0",
        "@typescript-eslint/scope-manager": "6.21.0",
        "@typescript-eslint/types": "6.21.0",
        "@typescript-eslint/typescript-estree": "6.21.0",
        "semver": "^7.5.4"
      },
      "engines": {
        "node": "^16.0.0 || >=18.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      },
      "peerDependencies": {
        "eslint": "^7.0.0 || ^8.0.0"
      }
    },
    "node_modules/@typescript-eslint/visitor-keys": {
      "version": "6.21.0",
      "resolved": "https://registry.npmjs.org/@typescript-eslint/visitor-keys/-/visitor-keys-6.21.0.tgz",
      "integrity": "sha512-JJtkDduxLi9bivAB+cYOVMtbkqdPOhZ+ZI5LC47MIRrDV4Yn2o+ZnW10Nkmr28xRpSpdJ6Sm42Hjf2+REYXm0A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@typescript-eslint/types": "6.21.0",
        "eslint-visitor-keys": "^3.4.1"
      },
      "engines": {
        "node": "^16.0.0 || >=18.0.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/typescript-eslint"
      }
    },
    "node_modules/@ungap/structured-clone": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/@ungap/structured-clone/-/structured-clone-1.3.0.tgz",
      "integrity": "sha512-WmoN8qaIAo7WTYWbAZuG8PYEhn5fkz7dZrqTBZ7dtt//lL2Gwms1IcnQ5yHqjDfX8Ft5j4YzDM23f87zBfDe9g==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/acorn": {
      "version": "8.15.0",
      "resolved": "https://registry.npmjs.org/acorn/-/acorn-8.15.0.tgz",
      "integrity": "sha512-NZyJarBfL7nWwIq+FDL6Zp/yHEhePMNnnJ0y3qfieCrmNvYct8uvtiV41UvlSe6apAfk0fY1FbWx+NwfmpvtTg==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "acorn": "bin/acorn"
      },
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/acorn-jsx": {
      "version": "5.3.2",
      "resolved": "https://registry.npmjs.org/acorn-jsx/-/acorn-jsx-5.3.2.tgz",
      "integrity": "sha512-rq9s+JNhf0IChjtDXxllJ7g41oZk5SlXtp0LHwyA5cejwn7vKmKp4pPri6YEePv2PU65sAsegbXtIinmDFDXgQ==",
      "dev": true,
      "license": "MIT",
      "peerDependencies": {
        "acorn": "^6.0.0 || ^7.0.0 || ^8.0.0"
      }
    },
    "node_modules/ajv": {
      "version": "6.12.6",
      "resolved": "https://registry.npmjs.org/ajv/-/ajv-6.12.6.tgz",
      "integrity": "sha512-j3fVLgvTo527anyYyJOGTYJbG+vnnQYvE0m5mmkc1TK+nxAppkCLMIL0aZ4dblVCNoGShhm+kzE4ZUykBoMg4g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "fast-deep-equal": "^3.1.1",
        "fast-json-stable-stringify": "^2.0.0",
        "json-schema-traverse": "^0.4.1",
        "uri-js": "^4.2.2"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/epoberezkin"
      }
    },
    "node_modules/ansi-regex": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.1.tgz",
      "integrity": "sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/ansi-styles": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz",
      "integrity": "sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "color-convert": "^2.0.1"
      },
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
      }
    },
    "node_modules/argparse": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/argparse/-/argparse-2.0.1.tgz",
      "integrity": "sha512-8+9WqebbFzpX9OR+Wa6O29asIogeRMzcGtAINdpMHHyAg10f05aSFVBbcEqGf/PXw1EjAZ+q2/bEBg3DvurK3Q==",
      "dev": true,
      "license": "Python-2.0"
    },
    "node_modules/array-union": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/array-union/-/array-union-2.1.0.tgz",
      "integrity": "sha512-HGyxoOTYUyCM6stUe6EJgnd4EoewAI7zMdfqO+kGjnlZmBDz/cR5pf8r/cR4Wq60sL/p0IkcjUEEPwS3GFrIyw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/balanced-match": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.2.tgz",
      "integrity": "sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/brace-expansion": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-2.0.2.tgz",
      "integrity": "sha512-Jt0vHyM+jmUBqojB7E1NIYadt0vI0Qxjxd2TErW94wDz+E2LAm5vKMXXwg6ZZBTHPuUlDgQHKXvjGBdfcF1ZDQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "balanced-match": "^1.0.0"
      }
    },
    "node_modules/braces": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/braces/-/braces-3.0.3.tgz",
      "integrity": "sha512-yQbXgO/OSZVD2IsiLlro+7Hf6Q18EJrKSEsdoMzKePKXct3gvD8oLcOQdIzGupr5Fj+EDe8gO/lxc1BzfMpxvA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "fill-range": "^7.1.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/callsites": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/callsites/-/callsites-3.1.0.tgz",
      "integrity": "sha512-P8BjAsXvZS+VIDUI11hHCQEv74YT67YUi5JJFNWIqL235sBmjX4+qx9Muvls5ivyNENctx46xQLQ3aTuE7ssaQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/chalk": {
      "version": "4.1.2",
      "resolved": "https://registry.npmjs.org/chalk/-/chalk-4.1.2.tgz",
      "integrity": "sha512-oKnbhFyRIXpUuez8iBMmyEa4nbj4IOQyuhc/wy9kY7/WVPcwIO9VA668Pu8RkO7+0G76SLROeyw9CpQ061i4mA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-styles": "^4.1.0",
        "supports-color": "^7.1.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/chalk/chalk?sponsor=1"
      }
    },
    "node_modules/color-convert": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
      "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "color-name": "~1.1.4"
      },
      "engines": {
        "node": ">=7.0.0"
      }
    },
    "node_modules/color-name": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz",
      "integrity": "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/concat-map": {
      "version": "0.0.1",
      "resolved": "https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz",
      "integrity": "sha512-/Srv4dswyQNBfohGpz9o6Yb3Gz3SrUDqBH5rTuhGR7ahtlbYKnVxw2bCFMRljaA7EXHaXZ8wsHdodFvbkhKmqg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/cross-spawn": {
      "version": "7.0.6",
      "resolved": "https://registry.npmjs.org/cross-spawn/-/cross-spawn-7.0.6.tgz",
      "integrity": "sha512-uV2QOWP2nWzsy2aMp8aRibhi9dlzF5Hgh5SHaB9OiTGEyDTiJJyx0uy51QXdyWbtAHNua4XJzUKca3OzKUd3vA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "path-key": "^3.1.0",
        "shebang-command": "^2.0.0",
        "which": "^2.0.1"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/custom-card-helpers": {
      "version": "1.9.0",
      "resolved": "https://registry.npmjs.org/custom-card-helpers/-/custom-card-helpers-1.9.0.tgz",
      "integrity": "sha512-5IW4OXq3MiiCqDvqeu+MYsM1NmntKW1WfJhyJFsdP2tbzqEI4BOnqRz2qzdp08lE4QLVhYfRLwe0WAqgQVNeFg==",
      "license": "MIT",
      "dependencies": {
        "@formatjs/intl-utils": "^3.8.4",
        "home-assistant-js-websocket": "^6.0.1",
        "intl-messageformat": "^9.11.1",
        "lit": "^2.1.1",
        "rollup": "^2.63.0",
        "superstruct": "^0.15.3",
        "typescript": "^4.5.4"
      }
    },
    "node_modules/custom-card-helpers/node_modules/@lit/reactive-element": {
      "version": "1.6.3",
      "resolved": "https://registry.npmjs.org/@lit/reactive-element/-/reactive-element-1.6.3.tgz",
      "integrity": "sha512-QuTgnG52Poic7uM1AN5yJ09QMe0O28e10XzSvWDz02TJiiKee4stsiownEIadWm8nYzyDAyT+gKzUoZmiWQtsQ==",
      "license": "BSD-3-Clause",
      "dependencies": {
        "@lit-labs/ssr-dom-shim": "^1.0.0"
      }
    },
    "node_modules/custom-card-helpers/node_modules/lit": {
      "version": "2.8.0",
      "resolved": "https://registry.npmjs.org/lit/-/lit-2.8.0.tgz",
      "integrity": "sha512-4Sc3OFX9QHOJaHbmTMk28SYgVxLN3ePDjg7hofEft2zWlehFL3LiAuapWc4U/kYwMYJSh2hTCPZ6/LIC7ii0MA==",
      "license": "BSD-3-Clause",
      "dependencies": {
        "@lit/reactive-element": "^1.6.0",
        "lit-element": "^3.3.0",
        "lit-html": "^2.8.0"
      }
    },
    "node_modules/custom-card-helpers/node_modules/lit-element": {
      "version": "3.3.3",
      "resolved": "https://registry.npmjs.org/lit-element/-/lit-element-3.3.3.tgz",
      "integrity": "sha512-XbeRxmTHubXENkV4h8RIPyr8lXc+Ff28rkcQzw3G6up2xg5E8Zu1IgOWIwBLEQsu3cOVFqdYwiVi0hv0SlpqUA==",
      "license": "BSD-3-Clause",
      "dependencies": {
        "@lit-labs/ssr-dom-shim": "^1.1.0",
        "@lit/reactive-element": "^1.3.0",
        "lit-html": "^2.8.0"
      }
    },
    "node_modules/custom-card-helpers/node_modules/lit-html": {
      "version": "2.8.0",
      "resolved": "https://registry.npmjs.org/lit-html/-/lit-html-2.8.0.tgz",
      "integrity": "sha512-o9t+MQM3P4y7M7yNzqAyjp7z+mQGa4NS4CxiyLqFPyFWyc4O+nodLrkrxSaCTrla6M5YOLaT3RpbbqjszB5g3Q==",
      "license": "BSD-3-Clause",
      "dependencies": {
        "@types/trusted-types": "^2.0.2"
      }
    },
    "node_modules/custom-card-helpers/node_modules/typescript": {
      "version": "4.9.5",
      "resolved": "https://registry.npmjs.org/typescript/-/typescript-4.9.5.tgz",
      "integrity": "sha512-1FXk9E2Hm+QzZQ7z+McJiHL4NW1F2EzMu9Nq9i3zAaGqibafqYwCVU6WyWAuyQRRzOlxou8xZSyXLEN8oKj24g==",
      "license": "Apache-2.0",
      "bin": {
        "tsc": "bin/tsc",
        "tsserver": "bin/tsserver"
      },
      "engines": {
        "node": ">=4.2.0"
      }
    },
    "node_modules/debug": {
      "version": "4.4.3",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.3.tgz",
      "integrity": "sha512-RGwwWnwQvkVfavKVt22FGLw+xYSdzARwm0ru6DhTVA3umU5hZc28V3kO4stgYryrTlLpuvgI9GiijltAjNbcqA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ms": "^2.1.3"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/deep-is": {
      "version": "0.1.4",
      "resolved": "https://registry.npmjs.org/deep-is/-/deep-is-0.1.4.tgz",
      "integrity": "sha512-oIPzksmTg4/MriiaYGO+okXDT7ztn/w3Eptv/+gSIdMdKsJo0u4CfYNFJPy+4SKMuCqGw2wxnA+URMg3t8a/bQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/dir-glob": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/dir-glob/-/dir-glob-3.0.1.tgz",
      "integrity": "sha512-WkrWp9GR4KXfKGYzOLmTuGVi1UWFfws377n9cc55/tb6DuqyF6pcQ5AbiHEshaDpY9v6oaSr2XCDidGmMwdzIA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "path-type": "^4.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/doctrine": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/doctrine/-/doctrine-3.0.0.tgz",
      "integrity": "sha512-yS+Q5i3hBf7GBkd4KG8a7eBNNWNGLTaEwwYWUijIYM7zrlYDM0BFXHjjPWlWZ1Rg7UaddZeIDmi9jF3HmqiQ2w==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "esutils": "^2.0.2"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/emojis-list": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/emojis-list/-/emojis-list-3.0.0.tgz",
      "integrity": "sha512-/kyM18EfinwXZbno9FyUGeFh87KC8HRQBQGildHZbEuRyWFOmv1U10o9BBp8XVZDVNNuQKyIGIu5ZYAAXJ0V2Q==",
      "license": "MIT",
      "engines": {
        "node": ">= 4"
      }
    },
    "node_modules/esbuild": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/esbuild/-/esbuild-0.21.5.tgz",
      "integrity": "sha512-mg3OPMV4hXywwpoDxu3Qda5xCKQi+vCTZq8S9J/EpkhB2HzKXq4SNFZE3+NK93JYxc8VMSep+lOUSC/RVKaBqw==",
      "dev": true,
      "hasInstallScript": true,
      "license": "MIT",
      "bin": {
        "esbuild": "bin/esbuild"
      },
      "engines": {
        "node": ">=12"
      },
      "optionalDependencies": {
        "@esbuild/aix-ppc64": "0.21.5",
        "@esbuild/android-arm": "0.21.5",
        "@esbuild/android-arm64": "0.21.5",
        "@esbuild/android-x64": "0.21.5",
        "@esbuild/darwin-arm64": "0.21.5",
        "@esbuild/darwin-x64": "0.21.5",
        "@esbuild/freebsd-arm64": "0.21.5",
        "@esbuild/freebsd-x64": "0.21.5",
        "@esbuild/linux-arm": "0.21.5",
        "@esbuild/linux-arm64": "0.21.5",
        "@esbuild/linux-ia32": "0.21.5",
        "@esbuild/linux-loong64": "0.21.5",
        "@esbuild/linux-mips64el": "0.21.5",
        "@esbuild/linux-ppc64": "0.21.5",
        "@esbuild/linux-riscv64": "0.21.5",
        "@esbuild/linux-s390x": "0.21.5",
        "@esbuild/linux-x64": "0.21.5",
        "@esbuild/netbsd-x64": "0.21.5",
        "@esbuild/openbsd-x64": "0.21.5",
        "@esbuild/sunos-x64": "0.21.5",
        "@esbuild/win32-arm64": "0.21.5",
        "@esbuild/win32-ia32": "0.21.5",
        "@esbuild/win32-x64": "0.21.5"
      }
    },
    "node_modules/escape-string-regexp": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-4.0.0.tgz",
      "integrity": "sha512-TtpcNJ3XAzx3Gq8sWRzJaVajRs0uVxA2YAkdb1jm2YkPz4G6egUFAyA3n5vtEIZefPk5Wa4UXbKuS5fKkJWdgA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/eslint": {
      "version": "8.57.1",
      "resolved": "https://registry.npmjs.org/eslint/-/eslint-8.57.1.tgz",
      "integrity": "sha512-ypowyDxpVSYpkXr9WPv2PAZCtNip1Mv5KTW0SCurXv/9iOpcrH9PaqUElksqEB6pChqHGDRCFTyrZlGhnLNGiA==",
      "deprecated": "This version is no longer supported. Please see https://eslint.org/version-support for other options.",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@eslint-community/eslint-utils": "^4.2.0",
        "@eslint-community/regexpp": "^4.6.1",
        "@eslint/eslintrc": "^2.1.4",
        "@eslint/js": "8.57.1",
        "@humanwhocodes/config-array": "^0.13.0",
        "@humanwhocodes/module-importer": "^1.0.1",
        "@nodelib/fs.walk": "^1.2.8",
        "@ungap/structured-clone": "^1.2.0",
        "ajv": "^6.12.4",
        "chalk": "^4.0.0",
        "cross-spawn": "^7.0.2",
        "debug": "^4.3.2",
        "doctrine": "^3.0.0",
        "escape-string-regexp": "^4.0.0",
        "eslint-scope": "^7.2.2",
        "eslint-visitor-keys": "^3.4.3",
        "espree": "^9.6.1",
        "esquery": "^1.4.2",
        "esutils": "^2.0.2",
        "fast-deep-equal": "^3.1.3",
        "file-entry-cache": "^6.0.1",
        "find-up": "^5.0.0",
        "glob-parent": "^6.0.2",
        "globals": "^13.19.0",
        "graphemer": "^1.4.0",
        "ignore": "^5.2.0",
        "imurmurhash": "^0.1.4",
        "is-glob": "^4.0.0",
        "is-path-inside": "^3.0.3",
        "js-yaml": "^4.1.0",
        "json-stable-stringify-without-jsonify": "^1.0.1",
        "levn": "^0.4.1",
        "lodash.merge": "^4.6.2",
        "minimatch": "^3.1.2",
        "natural-compare": "^1.4.0",
        "optionator": "^0.9.3",
        "strip-ansi": "^6.0.1",
        "text-table": "^0.2.0"
      },
      "bin": {
        "eslint": "bin/eslint.js"
      },
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/eslint-scope": {
      "version": "7.2.2",
      "resolved": "https://registry.npmjs.org/eslint-scope/-/eslint-scope-7.2.2.tgz",
      "integrity": "sha512-dOt21O7lTMhDM+X9mB4GX+DZrZtCUJPL/wlcTqxyrx5IvO0IYtILdtrQGQp+8n5S0gwSVmOf9NQrjMOgfQZlIg==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "esrecurse": "^4.3.0",
        "estraverse": "^5.2.0"
      },
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/eslint-visitor-keys": {
      "version": "3.4.3",
      "resolved": "https://registry.npmjs.org/eslint-visitor-keys/-/eslint-visitor-keys-3.4.3.tgz",
      "integrity": "sha512-wpc+LXeiyiisxPlEkUzU6svyS1frIO3Mgxj1fdy7Pm8Ygzguax2N3Fa/D/ag1WqbOprdI+uY6wMUl8/a2G+iag==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/eslint/node_modules/brace-expansion": {
      "version": "1.1.12",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.12.tgz",
      "integrity": "sha512-9T9UjW3r0UW5c1Q7GTwllptXwhvYmEzFhzMfZ9H7FQWt+uZePjZPjBP/W1ZEyZ1twGWom5/56TF4lPcqjnDHcg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "balanced-match": "^1.0.0",
        "concat-map": "0.0.1"
      }
    },
    "node_modules/eslint/node_modules/minimatch": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz",
      "integrity": "sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "brace-expansion": "^1.1.7"
      },
      "engines": {
        "node": "*"
      }
    },
    "node_modules/espree": {
      "version": "9.6.1",
      "resolved": "https://registry.npmjs.org/espree/-/espree-9.6.1.tgz",
      "integrity": "sha512-oruZaFkjorTpF32kDSI5/75ViwGeZginGGy2NoOSg3Q9bnwlnmDm4HLnkl0RE3n+njDXR037aY1+x58Z/zFdwQ==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "acorn": "^8.9.0",
        "acorn-jsx": "^5.3.2",
        "eslint-visitor-keys": "^3.4.1"
      },
      "engines": {
        "node": "^12.22.0 || ^14.17.0 || >=16.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/eslint"
      }
    },
    "node_modules/esquery": {
      "version": "1.6.0",
      "resolved": "https://registry.npmjs.org/esquery/-/esquery-1.6.0.tgz",
      "integrity": "sha512-ca9pw9fomFcKPvFLXhBKUK90ZvGibiGOvRJNbjljY7s7uq/5YO4BOzcYtJqExdx99rF6aAcnRxHmcUHcz6sQsg==",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "estraverse": "^5.1.0"
      },
      "engines": {
        "node": ">=0.10"
      }
    },
    "node_modules/esrecurse": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/esrecurse/-/esrecurse-4.3.0.tgz",
      "integrity": "sha512-KmfKL3b6G+RXvP8N1vr3Tq1kL/oCFgn2NYXEtqP8/L3pKapUA4G8cFVaoF3SU323CD4XypR/ffioHmkti6/Tag==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "estraverse": "^5.2.0"
      },
      "engines": {
        "node": ">=4.0"
      }
    },
    "node_modules/estraverse": {
      "version": "5.3.0",
      "resolved": "https://registry.npmjs.org/estraverse/-/estraverse-5.3.0.tgz",
      "integrity": "sha512-MMdARuVEQziNTeJD8DgMqmhwR11BRQ/cBP+pLtYdSTnf3MIO8fFeiINEbX36ZdNlfU/7A9f3gUw49B3oQsvwBA==",
      "dev": true,
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=4.0"
      }
    },
    "node_modules/esutils": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/esutils/-/esutils-2.0.3.tgz",
      "integrity": "sha512-kVscqXk4OCp68SZ0dkgEKVi6/8ij300KBWTJq32P/dYeWTSwK41WyTxalN1eRmA5Z9UU/LX9D7FWSmV9SAYx6g==",
      "dev": true,
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/fast-deep-equal": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/fast-deep-equal/-/fast-deep-equal-3.1.3.tgz",
      "integrity": "sha512-f3qQ9oQy9j2AhBe/H9VC91wLmKBCCU/gDOnKNAYG5hswO7BLKj09Hc5HYNz9cGI++xlpDCIgDaitVs03ATR84Q==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/fast-glob": {
      "version": "3.3.3",
      "resolved": "https://registry.npmjs.org/fast-glob/-/fast-glob-3.3.3.tgz",
      "integrity": "sha512-7MptL8U0cqcFdzIzwOTHoilX9x5BrNqye7Z/LuC7kCMRio1EMSyqRK3BEAUD7sXRq4iT4AzTVuZdhgQ2TCvYLg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@nodelib/fs.stat": "^2.0.2",
        "@nodelib/fs.walk": "^1.2.3",
        "glob-parent": "^5.1.2",
        "merge2": "^1.3.0",
        "micromatch": "^4.0.8"
      },
      "engines": {
        "node": ">=8.6.0"
      }
    },
    "node_modules/fast-glob/node_modules/glob-parent": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.2.tgz",
      "integrity": "sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "is-glob": "^4.0.1"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/fast-json-stable-stringify": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/fast-json-stable-stringify/-/fast-json-stable-stringify-2.1.0.tgz",
      "integrity": "sha512-lhd/wF+Lk98HZoTCtlVraHtfh5XYijIjalXck7saUtuanSDyLMxnHhSXEDJqHxD7msR8D0uCmqlkwjCV8xvwHw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/fast-levenshtein": {
      "version": "2.0.6",
      "resolved": "https://registry.npmjs.org/fast-levenshtein/-/fast-levenshtein-2.0.6.tgz",
      "integrity": "sha512-DCXu6Ifhqcks7TZKY3Hxp3y6qphY5SJZmrWMDrKcERSOXWQdMhU9Ig/PYrzyw/ul9jOIyh0N4M0tbC5hodg8dw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/fastq": {
      "version": "1.19.1",
      "resolved": "https://registry.npmjs.org/fastq/-/fastq-1.19.1.tgz",
      "integrity": "sha512-GwLTyxkCXjXbxqIhTsMI2Nui8huMPtnxg7krajPJAjnEG/iiOS7i+zCtWGZR9G0NBKbXKh6X9m9UIsYX/N6vvQ==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "reusify": "^1.0.4"
      }
    },
    "node_modules/file-entry-cache": {
      "version": "6.0.1",
      "resolved": "https://registry.npmjs.org/file-entry-cache/-/file-entry-cache-6.0.1.tgz",
      "integrity": "sha512-7Gps/XWymbLk2QLYK4NzpMOrYjMhdIxXuIvy2QBsLE6ljuodKvdkWs/cpyJJ3CVIVpH0Oi1Hvg1ovbMzLdFBBg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "flat-cache": "^3.0.4"
      },
      "engines": {
        "node": "^10.12.0 || >=12.0.0"
      }
    },
    "node_modules/fill-range": {
      "version": "7.1.1",
      "resolved": "https://registry.npmjs.org/fill-range/-/fill-range-7.1.1.tgz",
      "integrity": "sha512-YsGpe3WHLK8ZYi4tWDg2Jy3ebRz2rXowDxnld4bkQB00cc/1Zw9AWnC0i9ztDJitivtQvaI9KaLyKrc+hBW0yg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "to-regex-range": "^5.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/find-up": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/find-up/-/find-up-5.0.0.tgz",
      "integrity": "sha512-78/PXT1wlLLDgTzDs7sjq9hzz0vXD+zn+7wypEe4fXQxCmdmqfGsEPQxmiCSQI3ajFV91bVSsvNtrJRiW6nGng==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "locate-path": "^6.0.0",
        "path-exists": "^4.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/flat-cache": {
      "version": "3.2.0",
      "resolved": "https://registry.npmjs.org/flat-cache/-/flat-cache-3.2.0.tgz",
      "integrity": "sha512-CYcENa+FtcUKLmhhqyctpclsq7QF38pKjZHsGNiSQF5r4FtoKDWabFDl3hzaEQMvT1LHEysw5twgLvpYYb4vbw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "flatted": "^3.2.9",
        "keyv": "^4.5.3",
        "rimraf": "^3.0.2"
      },
      "engines": {
        "node": "^10.12.0 || >=12.0.0"
      }
    },
    "node_modules/flatted": {
      "version": "3.3.3",
      "resolved": "https://registry.npmjs.org/flatted/-/flatted-3.3.3.tgz",
      "integrity": "sha512-GX+ysw4PBCz0PzosHDepZGANEuFCMLrnRTiEy9McGjmkCQYwRq4A/X786G/fjM/+OjsWSU1ZrY5qyARZmO/uwg==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/fs.realpath": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/fs.realpath/-/fs.realpath-1.0.0.tgz",
      "integrity": "sha512-OO0pH2lK6a0hZnAdau5ItzHPI6pUlvI7jMVnxUQRtw4owF2wk8lOSabtGDCTP4Ggrg2MbGnWO9X8K1t4+fGMDw==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/fsevents": {
      "version": "2.3.3",
      "resolved": "https://registry.npmjs.org/fsevents/-/fsevents-2.3.3.tgz",
      "integrity": "sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==",
      "hasInstallScript": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": "^8.16.0 || ^10.6.0 || >=11.0.0"
      }
    },
    "node_modules/glob": {
      "version": "7.2.3",
      "resolved": "https://registry.npmjs.org/glob/-/glob-7.2.3.tgz",
      "integrity": "sha512-nFR0zLpU2YCaRxwoCJvL6UvCH2JFyFVIvwTLsIf21AuHlMskA1hhTdk+LlYJtOlYt9v6dvszD2BGRqBL+iQK9Q==",
      "deprecated": "Glob versions prior to v9 are no longer supported",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "fs.realpath": "^1.0.0",
        "inflight": "^1.0.4",
        "inherits": "2",
        "minimatch": "^3.1.1",
        "once": "^1.3.0",
        "path-is-absolute": "^1.0.0"
      },
      "engines": {
        "node": "*"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/glob-parent": {
      "version": "6.0.2",
      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-6.0.2.tgz",
      "integrity": "sha512-XxwI8EOhVQgWp6iDL+3b0r86f4d6AX6zSU55HfB4ydCEuXLXc5FcYeOu+nnGftS4TEju/11rt4KJPTMgbfmv4A==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "is-glob": "^4.0.3"
      },
      "engines": {
        "node": ">=10.13.0"
      }
    },
    "node_modules/glob/node_modules/brace-expansion": {
      "version": "1.1.12",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.12.tgz",
      "integrity": "sha512-9T9UjW3r0UW5c1Q7GTwllptXwhvYmEzFhzMfZ9H7FQWt+uZePjZPjBP/W1ZEyZ1twGWom5/56TF4lPcqjnDHcg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "balanced-match": "^1.0.0",
        "concat-map": "0.0.1"
      }
    },
    "node_modules/glob/node_modules/minimatch": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz",
      "integrity": "sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "brace-expansion": "^1.1.7"
      },
      "engines": {
        "node": "*"
      }
    },
    "node_modules/globals": {
      "version": "13.24.0",
      "resolved": "https://registry.npmjs.org/globals/-/globals-13.24.0.tgz",
      "integrity": "sha512-AhO5QUcj8llrbG09iWhPU2B204J1xnPeL8kQmVorSsy+Sjj1sk8gIyh6cUocGmH4L0UuhAJy+hJMRA4mgA4mFQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "type-fest": "^0.20.2"
      },
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/globby": {
      "version": "11.1.0",
      "resolved": "https://registry.npmjs.org/globby/-/globby-11.1.0.tgz",
      "integrity": "sha512-jhIXaOzy1sb8IyocaruWSn1TjmnBVs8Ayhcy83rmxNJ8q2uWKCAj3CnJY+KpGSXCueAPc0i05kVvVKtP1t9S3g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "array-union": "^2.1.0",
        "dir-glob": "^3.0.1",
        "fast-glob": "^3.2.9",
        "ignore": "^5.2.0",
        "merge2": "^1.4.1",
        "slash": "^3.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/graphemer": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/graphemer/-/graphemer-1.4.0.tgz",
      "integrity": "sha512-EtKwoO6kxCL9WO5xipiHTZlSzBm7WLT627TqC/uVRd0HKmq8NXyebnNYxDoBi7wt8eTWrUrKXCOVaFq9x1kgag==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/has-flag": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-4.0.0.tgz",
      "integrity": "sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/home-assistant-js-websocket": {
      "version": "6.1.1",
      "resolved": "https://registry.npmjs.org/home-assistant-js-websocket/-/home-assistant-js-websocket-6.1.1.tgz",
      "integrity": "sha512-TnZFzF4mn5F/v0XKUTK2GMQXrn/+eQpgaSDSELl6U0HSwSbFwRhGWLz330YT+hiKMspDflamsye//RPL+zwhDw==",
      "license": "Apache-2.0"
    },
    "node_modules/ignore": {
      "version": "5.3.2",
      "resolved": "https://registry.npmjs.org/ignore/-/ignore-5.3.2.tgz",
      "integrity": "sha512-hsBTNUqQTDwkWtcdYI2i06Y/nUBEsNEDJKjWdigLvegy8kDuJAS8uRlpkkcQpyEXL0Z/pjDy5HBmMjRCJ2gq+g==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 4"
      }
    },
    "node_modules/import-fresh": {
      "version": "3.3.1",
      "resolved": "https://registry.npmjs.org/import-fresh/-/import-fresh-3.3.1.tgz",
      "integrity": "sha512-TR3KfrTZTYLPB6jUjfx6MF9WcWrHL9su5TObK4ZkYgBdWKPOFoSoQIdEuTuR82pmtxH2spWG9h6etwfr1pLBqQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "parent-module": "^1.0.0",
        "resolve-from": "^4.0.0"
      },
      "engines": {
        "node": ">=6"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/imurmurhash": {
      "version": "0.1.4",
      "resolved": "https://registry.npmjs.org/imurmurhash/-/imurmurhash-0.1.4.tgz",
      "integrity": "sha512-JmXMZ6wuvDmLiHEml9ykzqO6lwFbof0GG4IkcGaENdCRDDmMVnny7s5HsIgHCbaq0w2MyPhDqkhTUgS2LU2PHA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.8.19"
      }
    },
    "node_modules/inflight": {
      "version": "1.0.6",
      "resolved": "https://registry.npmjs.org/inflight/-/inflight-1.0.6.tgz",
      "integrity": "sha512-k92I/b08q4wvFscXCLvqfsHCrjrF7yiXsQuIVvVE7N82W3+aqpzuUdBbfhWcy/FZR3/4IgflMgKLOsvPDrGCJA==",
      "deprecated": "This module is not supported, and leaks memory. Do not use it. Check out lru-cache if you want a good and tested way to coalesce async requests by a key value, which is much more comprehensive and powerful.",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "once": "^1.3.0",
        "wrappy": "1"
      }
    },
    "node_modules/inherits": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
      "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/intl-messageformat": {
      "version": "9.13.0",
      "resolved": "https://registry.npmjs.org/intl-messageformat/-/intl-messageformat-9.13.0.tgz",
      "integrity": "sha512-7sGC7QnSQGa5LZP7bXLDhVDtQOeKGeBFGHF2Y8LVBwYZoQZCgWeKoPGTa5GMG8g/TzDgeXuYJQis7Ggiw2xTOw==",
      "license": "BSD-3-Clause",
      "dependencies": {
        "@formatjs/ecma402-abstract": "1.11.4",
        "@formatjs/fast-memoize": "1.2.1",
        "@formatjs/icu-messageformat-parser": "2.1.0",
        "tslib": "^2.1.0"
      }
    },
    "node_modules/is-extglob": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/is-extglob/-/is-extglob-2.1.1.tgz",
      "integrity": "sha512-SbKbANkN603Vi4jEZv49LeVJMn4yGwsbzZworEoyEiutsN3nJYdbO36zfhGJ6QEDpOZIFkDtnq5JRxmvl3jsoQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-glob": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz",
      "integrity": "sha512-xelSayHH36ZgE7ZWhli7pW34hNbNl8Ojv5KVmkJD4hBdD3th8Tfk9vYasLM+mXWOZhFkgZfxhLSnrwRr4elSSg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-extglob": "^2.1.1"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-number": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/is-number/-/is-number-7.0.0.tgz",
      "integrity": "sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.12.0"
      }
    },
    "node_modules/is-path-inside": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/is-path-inside/-/is-path-inside-3.0.3.tgz",
      "integrity": "sha512-Fd4gABb+ycGAmKou8eMftCupSir5lRxqf4aD/vd0cD2qc4HL07OjCeuHMr8Ro4CoMaeCKDB0/ECBOVWjTwUvPQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/isexe": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/isexe/-/isexe-2.0.0.tgz",
      "integrity": "sha512-RHxMLp9lnKHGHRng9QFhRCMbYAcVpn69smSGcq3f36xjgVVWThj4qqLbTLlq7Ssj8B+fIQ1EuCEGI2lKsyQeIw==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/js-yaml": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.0.tgz",
      "integrity": "sha512-wpxZs9NoxZaJESJGIZTyDEaYpl0FKSA+FB9aJiyemKhMwkxQg63h4T1KJgUGHpTqPDNRcmmYLugrRjJlBtWvRA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "argparse": "^2.0.1"
      },
      "bin": {
        "js-yaml": "bin/js-yaml.js"
      }
    },
    "node_modules/json-buffer": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/json-buffer/-/json-buffer-3.0.1.tgz",
      "integrity": "sha512-4bV5BfR2mqfQTJm+V5tPPdf+ZpuhiIvTuAB5g8kcrXOZpTT/QwwVRWBywX1ozr6lEuPdbHxwaJlm9G6mI2sfSQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/json-schema-traverse": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-0.4.1.tgz",
      "integrity": "sha512-xbbCH5dCYU5T8LcEhhuh7HJ88HXuW3qsI3Y0zOZFKfZEHcpWiHU/Jxzk629Brsab/mMiHQti9wMP+845RPe3Vg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/json-stable-stringify-without-jsonify": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/json-stable-stringify-without-jsonify/-/json-stable-stringify-without-jsonify-1.0.1.tgz",
      "integrity": "sha512-Bdboy+l7tA3OGW6FjyFHWkP5LuByj1Tk33Ljyq0axyzdk9//JSi2u3fP1QSmd1KNwq6VOKYGlAu87CisVir6Pw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/keyv": {
      "version": "4.5.4",
      "resolved": "https://registry.npmjs.org/keyv/-/keyv-4.5.4.tgz",
      "integrity": "sha512-oxVHkHR/EJf2CNXnWxRLW6mg7JyCCUcG0DtEGmL2ctUo1PNTin1PUil+r/+4r5MpVgC/fn1kjsx7mjSujKqIpw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "json-buffer": "3.0.1"
      }
    },
    "node_modules/levn": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/levn/-/levn-0.4.1.tgz",
      "integrity": "sha512-+bT2uH4E5LGE7h/n3evcS/sQlJXCpIp6ym8OWJ5eV6+67Dsql/LaaT7qJBAt2rzfoa/5QBGBhxDix1dMt2kQKQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "prelude-ls": "^1.2.1",
        "type-check": "~0.4.0"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/lit": {
      "version": "3.3.1",
      "resolved": "https://registry.npmjs.org/lit/-/lit-3.3.1.tgz",
      "integrity": "sha512-Ksr/8L3PTapbdXJCk+EJVB78jDodUMaP54gD24W186zGRARvwrsPfS60wae/SSCTCNZVPd1chXqio1qHQmu4NA==",
      "license": "BSD-3-Clause",
      "dependencies": {
        "@lit/reactive-element": "^2.1.0",
        "lit-element": "^4.2.0",
        "lit-html": "^3.3.0"
      }
    },
    "node_modules/lit-element": {
      "version": "4.2.1",
      "resolved": "https://registry.npmjs.org/lit-element/-/lit-element-4.2.1.tgz",
      "integrity": "sha512-WGAWRGzirAgyphK2urmYOV72tlvnxw7YfyLDgQ+OZnM9vQQBQnumQ7jUJe6unEzwGU3ahFOjuz1iz1jjrpCPuw==",
      "license": "BSD-3-Clause",
      "dependencies": {
        "@lit-labs/ssr-dom-shim": "^1.4.0",
        "@lit/reactive-element": "^2.1.0",
        "lit-html": "^3.3.0"
      }
    },
    "node_modules/lit-html": {
      "version": "3.3.1",
      "resolved": "https://registry.npmjs.org/lit-html/-/lit-html-3.3.1.tgz",
      "integrity": "sha512-S9hbyDu/vs1qNrithiNyeyv64c9yqiW9l+DBgI18fL+MTvOtWoFR0FWiyq1TxaYef5wNlpEmzlXoBlZEO+WjoA==",
      "license": "BSD-3-Clause",
      "dependencies": {
        "@types/trusted-types": "^2.0.2"
      }
    },
    "node_modules/locate-path": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/locate-path/-/locate-path-6.0.0.tgz",
      "integrity": "sha512-iPZK6eYjbxRu3uB4/WZ3EsEIMJFMqAoopl3R+zuq0UjcAm/MO6KCweDgPfP3elTztoKP3KtnVHxTn2NHBSDVUw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "p-locate": "^5.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/lodash.merge": {
      "version": "4.6.2",
      "resolved": "https://registry.npmjs.org/lodash.merge/-/lodash.merge-4.6.2.tgz",
      "integrity": "sha512-0KpjqXRVvrYyCsX1swR/XTK0va6VQkQM6MNo7PqW77ByjAhoARA8EfrP1N4+KlKj8YS0ZUCtRT/YUuhyYDujIQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/merge2": {
      "version": "1.4.1",
      "resolved": "https://registry.npmjs.org/merge2/-/merge2-1.4.1.tgz",
      "integrity": "sha512-8q7VEgMJW4J8tcfVPy8g09NcQwZdbwFEqhe/WZkoIzjn/3TGDwtOCYtXGxA3O8tPzpczCCDgv+P2P5y00ZJOOg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/micromatch": {
      "version": "4.0.8",
      "resolved": "https://registry.npmjs.org/micromatch/-/micromatch-4.0.8.tgz",
      "integrity": "sha512-PXwfBhYu0hBCPw8Dn0E+WDYb7af3dSLVWKi3HGv84IdF4TyFoC0ysxFd0Goxw7nSv4T/PzEJQxsYsEiFCKo2BA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "braces": "^3.0.3",
        "picomatch": "^2.3.1"
      },
      "engines": {
        "node": ">=8.6"
      }
    },
    "node_modules/minimatch": {
      "version": "9.0.3",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-9.0.3.tgz",
      "integrity": "sha512-RHiac9mvaRw0x3AYRgDC1CxAP7HTcNrrECeA8YYJeWnpo+2Q5CegtZjaotWTWxDG3UeGA1coE05iH1mPjT/2mg==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "brace-expansion": "^2.0.1"
      },
      "engines": {
        "node": ">=16 || 14 >=14.17"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/nanoid": {
      "version": "3.3.11",
      "resolved": "https://registry.npmjs.org/nanoid/-/nanoid-3.3.11.tgz",
      "integrity": "sha512-N8SpfPUnUp1bK+PMYW8qSWdl9U+wwNWI4QKxOYDy9JAro3WMX7p2OeVRF9v+347pnakNevPmiHhNmZ2HbFA76w==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "bin": {
        "nanoid": "bin/nanoid.cjs"
      },
      "engines": {
        "node": "^10 || ^12 || ^13.7 || ^14 || >=15.0.1"
      }
    },
    "node_modules/natural-compare": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/natural-compare/-/natural-compare-1.4.0.tgz",
      "integrity": "sha512-OWND8ei3VtNC9h7V60qff3SVobHr996CTwgxubgyQYEpg290h9J0buyECNNJexkFm5sOajh5G116RYA1c8ZMSw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/once": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/once/-/once-1.4.0.tgz",
      "integrity": "sha512-lNaJgI+2Q5URQBkccEKHTQOPaXdUxnZZElQTZY0MFUAuaEqe1E+Nyvgdz/aIyNi6Z9MzO5dv1H8n58/GELp3+w==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "wrappy": "1"
      }
    },
    "node_modules/optionator": {
      "version": "0.9.4",
      "resolved": "https://registry.npmjs.org/optionator/-/optionator-0.9.4.tgz",
      "integrity": "sha512-6IpQ7mKUxRcZNLIObR0hz7lxsapSSIYNZJwXPGeF0mTVqGKFIXj1DQcMoT22S3ROcLyY/rz0PWaWZ9ayWmad9g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "deep-is": "^0.1.3",
        "fast-levenshtein": "^2.0.6",
        "levn": "^0.4.1",
        "prelude-ls": "^1.2.1",
        "type-check": "^0.4.0",
        "word-wrap": "^1.2.5"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/p-limit": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/p-limit/-/p-limit-3.1.0.tgz",
      "integrity": "sha512-TYOanM3wGwNGsZN2cVTYPArw454xnXj5qmWF1bEoAc4+cU/ol7GVh7odevjp1FNHduHc3KZMcFduxU5Xc6uJRQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "yocto-queue": "^0.1.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/p-locate": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/p-locate/-/p-locate-5.0.0.tgz",
      "integrity": "sha512-LaNjtRWUBY++zB5nE/NwcaoMylSPk+S+ZHNB1TzdbMJMny6dynpAGt7X/tl/QYq3TIeE6nxHppbo2LGymrG5Pw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "p-limit": "^3.0.2"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/parent-module": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/parent-module/-/parent-module-1.0.1.tgz",
      "integrity": "sha512-GQ2EWRpQV8/o+Aw8YqtfZZPfNRWZYkbidE9k5rpl/hC3vtHHBfGm2Ifi6qWV+coDGkrUKZAxE3Lot5kcsRlh+g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "callsites": "^3.0.0"
      },
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/path-exists": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/path-exists/-/path-exists-4.0.0.tgz",
      "integrity": "sha512-ak9Qy5Q7jYb2Wwcey5Fpvg2KoAc/ZIhLSLOSBmRmygPsGwkVVt0fZa0qrtMz+m6tJTAHfZQ8FnmB4MG4LWy7/w==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/path-is-absolute": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/path-is-absolute/-/path-is-absolute-1.0.1.tgz",
      "integrity": "sha512-AVbw3UJ2e9bq64vSaS9Am0fje1Pa8pbGqTTsmXfaIiMpnr5DlDhfJOuLj9Sf95ZPVDAUerDfEk88MPmPe7UCQg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/path-key": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/path-key/-/path-key-3.1.1.tgz",
      "integrity": "sha512-ojmeN0qd+y0jszEtoY48r0Peq5dwMEkIlCOu6Q5f41lfkswXuKtYrhgoTpLnyIcHm24Uhqx+5Tqm2InSwLhE6Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/path-type": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/path-type/-/path-type-4.0.0.tgz",
      "integrity": "sha512-gDKb8aZMDeD/tZWs9P6+q0J9Mwkdl6xMV8TjnGP3qJVJ06bdMgkbBlLU8IdfOsIsFz2BW1rNVT3XuNEl8zPAvw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/picocolors": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/picocolors/-/picocolors-1.1.1.tgz",
      "integrity": "sha512-xceH2snhtb5M9liqDsmEw56le376mTZkEX/jEb/RxNFyegNul7eNslCXP9FDj/Lcu0X8KEyMceP2ntpaHrDEVA==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/picomatch": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-2.3.1.tgz",
      "integrity": "sha512-JU3teHTNjmE2VCGFzuY8EXzCDVwEqB2a8fsIvwaStHhAWJEeVd1o1QD80CU6+ZdEXXSLbSsuLwJjkCBWqRQUVA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/jonschlinkert"
      }
    },
    "node_modules/postcss": {
      "version": "8.5.6",
      "resolved": "https://registry.npmjs.org/postcss/-/postcss-8.5.6.tgz",
      "integrity": "sha512-3Ybi1tAuwAP9s0r1UQ2J4n5Y0G05bJkpUIO0/bI9MhwmD70S5aTWbXGBwxHrelT+XM1k6dM0pk+SwNkpTRN7Pg==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/postcss"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "nanoid": "^3.3.11",
        "picocolors": "^1.1.1",
        "source-map-js": "^1.2.1"
      },
      "engines": {
        "node": "^10 || ^12 || >=14"
      }
    },
    "node_modules/prelude-ls": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/prelude-ls/-/prelude-ls-1.2.1.tgz",
      "integrity": "sha512-vkcDPrRZo1QZLbn5RLGPpg/WmIQ65qoWWhcGKf/b5eplkkarX0m9z8ppCat4mlOqUsWpyNuYgO3VRyrYHSzX5g==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/punycode": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/punycode/-/punycode-2.3.1.tgz",
      "integrity": "sha512-vYt7UD1U9Wg6138shLtLOvdAu+8DsC/ilFtEVHcH+wydcSpNE20AfSOduf6MkRFahL5FY7X1oU7nKVZFtfq8Fg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/queue-microtask": {
      "version": "1.2.3",
      "resolved": "https://registry.npmjs.org/queue-microtask/-/queue-microtask-1.2.3.tgz",
      "integrity": "sha512-NuaNSa6flKT5JaSYQzJok04JzTL1CA6aGhv5rfLW3PgqA+M2ChpZQnAC8h8i4ZFkBS8X5RqkDBHA7r4hej3K9A==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT"
    },
    "node_modules/resolve-from": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/resolve-from/-/resolve-from-4.0.0.tgz",
      "integrity": "sha512-pb/MYmXstAkysRFx8piNI1tGFNQIFA3vkE3Gq4EuA1dF6gHp/+vgZqsCGJapvy8N3Q+4o7FwvquPJcnZ7RYy4g==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/reusify": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/reusify/-/reusify-1.1.0.tgz",
      "integrity": "sha512-g6QUff04oZpHs0eG5p83rFLhHeV00ug/Yf9nZM6fLeUrPguBTkTQOdpAWWspMh55TZfVQDPaN3NQJfbVRAxdIw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "iojs": ">=1.0.0",
        "node": ">=0.10.0"
      }
    },
    "node_modules/rimraf": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/rimraf/-/rimraf-3.0.2.tgz",
      "integrity": "sha512-JZkJMZkAGFFPP2YqXZXPbMlMBgsxzE8ILs4lMIX/2o0L9UBw9O/Y3o6wFw/i9YLapcUJWwqbi3kdxIPdC62TIA==",
      "deprecated": "Rimraf versions prior to v4 are no longer supported",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "glob": "^7.1.3"
      },
      "bin": {
        "rimraf": "bin.js"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/rollup": {
      "version": "2.79.2",
      "resolved": "https://registry.npmjs.org/rollup/-/rollup-2.79.2.tgz",
      "integrity": "sha512-fS6iqSPZDs3dr/y7Od6y5nha8dW1YnbgtsyotCVvoFGKbERG++CVRFv1meyGDE1SNItQA8BrnCw7ScdAhRJ3XQ==",
      "license": "MIT",
      "bin": {
        "rollup": "dist/bin/rollup"
      },
      "engines": {
        "node": ">=10.0.0"
      },
      "optionalDependencies": {
        "fsevents": "~2.3.2"
      }
    },
    "node_modules/run-parallel": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/run-parallel/-/run-parallel-1.2.0.tgz",
      "integrity": "sha512-5l4VyZR86LZ/lDxZTR6jqL8AFE2S0IFLMP26AbjsLVADxHdhB/c0GUsH+y39UfCi3dzz8OlQuPmnaJOMoDHQBA==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "queue-microtask": "^1.2.2"
      }
    },
    "node_modules/semver": {
      "version": "7.7.2",
      "resolved": "https://registry.npmjs.org/semver/-/semver-7.7.2.tgz",
      "integrity": "sha512-RF0Fw+rO5AMf9MAyaRXI4AV0Ulj5lMHqVxxdSgiVbixSCXoEmmX/jk0CuJw4+3SqroYO9VoUh+HcuJivvtJemA==",
      "dev": true,
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/shebang-command": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/shebang-command/-/shebang-command-2.0.0.tgz",
      "integrity": "sha512-kHxr2zZpYtdmrN1qDjrrX/Z1rR1kG8Dx+gkpK1G4eXmvXswmcE1hTWBWYUzlraYw1/yZp6YuDY77YtvbN0dmDA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "shebang-regex": "^3.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/shebang-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/shebang-regex/-/shebang-regex-3.0.0.tgz",
      "integrity": "sha512-7++dFhtcx3353uBaq8DDR4NuxBetBzC7ZQOhmTQInHEd6bSrXdiEyzCvG07Z44UYdLShWUyXt5M/yhz8ekcb1A==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/sip.js": {
      "version": "0.21.2",
      "resolved": "https://registry.npmjs.org/sip.js/-/sip.js-0.21.2.tgz",
      "integrity": "sha512-tSqTcIgrOd2IhP/rd70JablvAp+fSfLSxO4hGNY6LkWRY1SKygTO7OtJEV/BQb8oIxtMRx0LE7nUF2MaqGbFzA==",
      "license": "MIT",
      "engines": {
        "node": ">=10.0"
      }
    },
    "node_modules/slash": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/slash/-/slash-3.0.0.tgz",
      "integrity": "sha512-g9Q1haeby36OSStwb4ntCGGGaKsaVSjQ68fBxoQcutl5fS1vuY18H3wSt3jFyFtrkx+Kz0V1G85A4MyAdDMi2Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/source-map-js": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/source-map-js/-/source-map-js-1.2.1.tgz",
      "integrity": "sha512-UXWMKhLOwVKb728IUtQPXxfYU+usdybtUrK/8uGE8CQMvrhOpwvzDBwj0QhSL7MQc7vIsISBG8VQ8+IDQxpfQA==",
      "dev": true,
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/strip-ansi": {
      "version": "6.0.1",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
      "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-regex": "^5.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/strip-json-comments": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.1.tgz",
      "integrity": "sha512-6fPc+R4ihwqP6N/aIv2f1gMH8lOVtWQHoqC4yK6oSDVVocumAsfCqjkXnqiYMhmMwS/mEHLp7Vehlt3ql6lEig==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/superstruct": {
      "version": "0.15.5",
      "resolved": "https://registry.npmjs.org/superstruct/-/superstruct-0.15.5.tgz",
      "integrity": "sha512-4AOeU+P5UuE/4nOUkmcQdW5y7i9ndt1cQd/3iUe+LTz3RxESf/W/5lg4B74HbDMMv8PHnPnGCQFH45kBcrQYoQ==",
      "license": "MIT"
    },
    "node_modules/supports-color": {
      "version": "7.2.0",
      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-7.2.0.tgz",
      "integrity": "sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "has-flag": "^4.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/text-table": {
      "version": "0.2.0",
      "resolved": "https://registry.npmjs.org/text-table/-/text-table-0.2.0.tgz",
      "integrity": "sha512-N+8UisAXDGk8PFXP4HAzVR9nbfmVJ3zYLAWiTIoqC5v5isinhr+r5uaO8+7r3BMfuNIufIsA7RdpVgacC2cSpw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/to-regex-range": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/to-regex-range/-/to-regex-range-5.0.1.tgz",
      "integrity": "sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-number": "^7.0.0"
      },
      "engines": {
        "node": ">=8.0"
      }
    },
    "node_modules/ts-api-utils": {
      "version": "1.4.3",
      "resolved": "https://registry.npmjs.org/ts-api-utils/-/ts-api-utils-1.4.3.tgz",
      "integrity": "sha512-i3eMG77UTMD0hZhgRS562pv83RC6ukSAC2GMNWc+9dieh/+jDM5u5YG+NHX6VNDRHQcHwmsTHctP9LhbC3WxVw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=16"
      },
      "peerDependencies": {
        "typescript": ">=4.2.0"
      }
    },
    "node_modules/tslib": {
      "version": "2.8.1",
      "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.8.1.tgz",
      "integrity": "sha512-oJFu94HQb+KVduSUQL7wnpmqnfmLsOA/nAh6b6EH0wCEoK0/mPeXU6c3wKDV83MkOuHPRHtSXKKU99IBazS/2w==",
      "license": "0BSD"
    },
    "node_modules/type-check": {
      "version": "0.4.0",
      "resolved": "https://registry.npmjs.org/type-check/-/type-check-0.4.0.tgz",
      "integrity": "sha512-XleUoc9uwGXqjWwXaUTZAmzMcFZ5858QA2vvx1Ur5xIcixXIP+8LnFDgRplU30us6teqdlskFfu+ae4K79Ooew==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "prelude-ls": "^1.2.1"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/type-fest": {
      "version": "0.20.2",
      "resolved": "https://registry.npmjs.org/type-fest/-/type-fest-0.20.2.tgz",
      "integrity": "sha512-Ne+eE4r0/iWnpAxD852z3A+N0Bt5RN//NjJwRd2VFHEmrywxf5vsZlh4R6lixl6B+wz/8d+maTSAkN1FIkI3LQ==",
      "dev": true,
      "license": "(MIT OR CC0-1.0)",
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/typescript": {
      "version": "5.9.2",
      "resolved": "https://registry.npmjs.org/typescript/-/typescript-5.9.2.tgz",
      "integrity": "sha512-CWBzXQrc/qOkhidw1OzBTQuYRbfyxDXJMVJ1XNwUHGROVmuaeiEm3OslpZ1RV96d7SKKjZKrSJu3+t/xlw3R9A==",
      "dev": true,
      "license": "Apache-2.0",
      "bin": {
        "tsc": "bin/tsc",
        "tsserver": "bin/tsserver"
      },
      "engines": {
        "node": ">=14.17"
      }
    },
    "node_modules/uri-js": {
      "version": "4.4.1",
      "resolved": "https://registry.npmjs.org/uri-js/-/uri-js-4.4.1.tgz",
      "integrity": "sha512-7rKUyy33Q1yc98pQ1DAmLtwX109F7TIfWlW1Ydo8Wl1ii1SeHieeh0HHfPeL2fMXK6z0s8ecKs9frCuLJvndBg==",
      "dev": true,
      "license": "BSD-2-Clause",
      "dependencies": {
        "punycode": "^2.1.0"
      }
    },
    "node_modules/vite": {
      "version": "5.4.20",
      "resolved": "https://registry.npmjs.org/vite/-/vite-5.4.20.tgz",
      "integrity": "sha512-j3lYzGC3P+B5Yfy/pfKNgVEg4+UtcIJcVRt2cDjIOmhLourAqPqf8P7acgxeiSgUB7E3p2P8/3gNIgDLpwzs4g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "esbuild": "^0.21.3",
        "postcss": "^8.4.43",
        "rollup": "^4.20.0"
      },
      "bin": {
        "vite": "bin/vite.js"
      },
      "engines": {
        "node": "^18.0.0 || >=20.0.0"
      },
      "funding": {
        "url": "https://github.com/vitejs/vite?sponsor=1"
      },
      "optionalDependencies": {
        "fsevents": "~2.3.3"
      },
      "peerDependencies": {
        "@types/node": "^18.0.0 || >=20.0.0",
        "less": "*",
        "lightningcss": "^1.21.0",
        "sass": "*",
        "sass-embedded": "*",
        "stylus": "*",
        "sugarss": "*",
        "terser": "^5.4.0"
      },
      "peerDependenciesMeta": {
        "@types/node": {
          "optional": true
        },
        "less": {
          "optional": true
        },
        "lightningcss": {
          "optional": true
        },
        "sass": {
          "optional": true
        },
        "sass-embedded": {
          "optional": true
        },
        "stylus": {
          "optional": true
        },
        "sugarss": {
          "optional": true
        },
        "terser": {
          "optional": true
        }
      }
    },
    "node_modules/vite/node_modules/rollup": {
      "version": "4.52.0",
      "resolved": "https://registry.npmjs.org/rollup/-/rollup-4.52.0.tgz",
      "integrity": "sha512-+IuescNkTJQgX7AkIDtITipZdIGcWF0pnVvZTWStiazUmcGA2ag8dfg0urest2XlXUi9kuhfQ+qmdc5Stc3z7g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/estree": "1.0.8"
      },
      "bin": {
        "rollup": "dist/bin/rollup"
      },
      "engines": {
        "node": ">=18.0.0",
        "npm": ">=8.0.0"
      },
      "optionalDependencies": {
        "@rollup/rollup-android-arm-eabi": "4.52.0",
        "@rollup/rollup-android-arm64": "4.52.0",
        "@rollup/rollup-darwin-arm64": "4.52.0",
        "@rollup/rollup-darwin-x64": "4.52.0",
        "@rollup/rollup-freebsd-arm64": "4.52.0",
        "@rollup/rollup-freebsd-x64": "4.52.0",
        "@rollup/rollup-linux-arm-gnueabihf": "4.52.0",
        "@rollup/rollup-linux-arm-musleabihf": "4.52.0",
        "@rollup/rollup-linux-arm64-gnu": "4.52.0",
        "@rollup/rollup-linux-arm64-musl": "4.52.0",
        "@rollup/rollup-linux-loong64-gnu": "4.52.0",
        "@rollup/rollup-linux-ppc64-gnu": "4.52.0",
        "@rollup/rollup-linux-riscv64-gnu": "4.52.0",
        "@rollup/rollup-linux-riscv64-musl": "4.52.0",
        "@rollup/rollup-linux-s390x-gnu": "4.52.0",
        "@rollup/rollup-linux-x64-gnu": "4.52.0",
        "@rollup/rollup-linux-x64-musl": "4.52.0",
        "@rollup/rollup-openharmony-arm64": "4.52.0",
        "@rollup/rollup-win32-arm64-msvc": "4.52.0",
        "@rollup/rollup-win32-ia32-msvc": "4.52.0",
        "@rollup/rollup-win32-x64-gnu": "4.52.0",
        "@rollup/rollup-win32-x64-msvc": "4.52.0",
        "fsevents": "~2.3.2"
      }
    },
    "node_modules/which": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/which/-/which-2.0.2.tgz",
      "integrity": "sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "isexe": "^2.0.0"
      },
      "bin": {
        "node-which": "bin/node-which"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/word-wrap": {
      "version": "1.2.5",
      "resolved": "https://registry.npmjs.org/word-wrap/-/word-wrap-1.2.5.tgz",
      "integrity": "sha512-BN22B5eaMMI9UMtjrGd5g5eCYPpCPDUy0FJXbYsaT5zYxjFOckS53SQDE3pWkVoWpHXVb3BrYcEN4Twa55B5cA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/wrappy": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
      "integrity": "sha512-l4Sp/DRseor9wL6EvV2+TuQn63dMkPjZ/sp9XkghTEbV9KlPS1xUsZ3u7/IQO4wxtcFB4bgpQPRcR3QCvezPcQ==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/yocto-queue": {
      "version": "0.1.0",
      "resolved": "https://registry.npmjs.org/yocto-queue/-/yocto-queue-0.1.0.tgz",
      "integrity": "sha512-rVksvsnNCdJ/ohGc6xgPwyN8eheCxsiLM8mxuE/t/mOVqJewPuO1miLpTHQiRgTKCLexL4MeAFVagts7HmNZ2Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    }
  }
}

---

=== Object: 1dd53e6be429256511e8d77579ec0450f90ed306 | Date: 2025-09-22 13:01:13 | Type: blob ===

{
  "compilerOptions": {
    "target": "ES2020",
    "lib": [
      "ES2020",
      "DOM",
      "DOM.Iterable"
    ],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "experimentalDecorators": true,
    "useDefineForClassFields": false
  },
  "include": [
    "src/**/*.ts",
    "src/**/*.d.ts"
  ]
}
---

=== Object: 11f02fe2a0061d6e6e1f271b21da95423b448b32 | Date: 2025-09-22 13:01:13 | Type: blob ===

/// <reference types="vite/client" />

---

=== Object: b994975a7e96f201f20e9113eaaae40f6233b1dd | Date: 2025-09-22 13:00:49 | Type: blob ===

{"pid": 67, "version": 1, "ha_version": "2025.10.0.dev202509180233", "start_ts": 1758536308.6425776}
---

=== Object: a547bf36d8d11a4f89c59c144f24795749086dd1 | Date: 2025-09-22 13:00:49 | Type: blob ===

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

---

=== Object: 38b587e2f626366eee46509eb9ad695b6b358bfc | Date: 2025-09-22 13:00:49 | Type: blob ===

2025.10.0.dev202509180233
---

=== Object: 8575fcf19aae97c7a196e271aa7a9205629c3d77 | Date: 2025-09-22 12:13:48 | Type: blob ===

services:
  # Development environment
  dev:
    build:
      context: .
      target: development
    volumes:
      - .:/workspace
      - /workspace/node_modules
      - ./dist:/workspace/dist
    ports:
      - "3000:3000" # Vite dev server
      - "24678:24678" # Vite HMR
    environment:
      - NODE_ENV=development
      - CHOKIDAR_USEPOLLING=true
    command: npm run dev
    stdin_open: true
    tty: true

  # Production build
  build:
    build:
      context: .
      target: build
    volumes:
      - ./dist:/app/dist
    command: npm run build

  # Home Assistant test environment
  homeassistant:
    image: homeassistant/home-assistant:dev
    container_name: ha-webrtc-test
    volumes:
      - ./test/config:/config
      - ./dist:/config/www/community/ha-webrtc-sip-card
      - /etc/localtime:/etc/localtime:ro
      - ./config/configuration.yaml:/config/configuration.yaml
      - ./config/ui-lovelace.yaml:/config/ui-lovelace.yaml
    ports:
      - "8123:8123"
    restart: unless-stopped
    environment:
      - TZ=Africa/Kigali
    depends_on:
      - build
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8123"]
      interval: 30s
      timeout: 10s
      retries: 3

  nginx:
    container_name: ha-nginx
    image: nginx:alpine
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./ssl:/etc/ssl:ro
    ports:
      - "443:443"
      - "80:80"
    restart: unless-stopped
    depends_on:
      - homeassistant

networks:
  default:
    name: ha-webrtc-network

---

=== Object: 6c8b67f94a29783b844aa61ac699210d5e530709 | Date: 2025-09-22 12:13:48 | Type: blob ===

import { LitElement, html, css, type CSSResultGroup, type TemplateResult } from "lit";
import { customElement, property, state, query } from "lit/decorators.js";
import type { HomeAssistant, SIPCardConfig, SIPContact } from "./types";
import { SipManager, type SipConfig } from "./sip-manager";
import { CallManager, type CallState } from "./call-manager";
import { sharedStyles } from "./styles";
import { CARD_VERSION, DEFAULT_CONFIG, DTMF_KEYS } from "./constants";
import { mergeConfig, validateConfig, formatPhoneNumber, sanitizeExtension } from "./utils";

@customElement("ha-webrtc-sip-card")
export class WebRTCSipCard extends LitElement {
  @property({ attribute: false }) public hass!: HomeAssistant;
  @state() private config!: SIPCardConfig;
  @state() private connected = false;
  @state() private registered = false;
  @state() private error: string | null = null;
  @state() private callState!: CallState;
  @state() private showKeypad = false;
  @state() private currentInput = "";

  @query("#remote-video") private remoteVideoElement?: HTMLVideoElement;

  private sipManager: SipManager | null = null;
  private callManager: CallManager | null = null;

  public static getConfigElement() {
    return document.createElement("ha-webrtc-sip-card-editor");
  }

  public static getStubConfig(): SIPCardConfig {
    return { ...DEFAULT_CONFIG };
  }

  public setConfig(config: SIPCardConfig): void {
    try {
      validateConfig(config);
      this.config = mergeConfig(config);
      this.initializeSipClient();
    } catch (error) {
      this.error = error instanceof Error ? error.message : "Invalid configuration";
      throw new Error(this.error);
    }
  }

  public getCardSize(): number {
    return this.callState && this.callState.active ? 6 : 4;
  }

  private async initializeSipClient(): Promise<void> {
    try {
      // Cleanup existing connections
      if (this.sipManager) {
        await this.sipManager.disconnect();
      }

      this.error = null;
      this.connected = false;
      this.registered = false;

      const sipConfig: SipConfig = {
        server: this.config.server_url.replace(/^wss?:\/\//, "").replace(/:\d+$/, ""),
        username: this.config.username,
        password: this.config.password,
        domain: this.config.domain || this.config.server_url.replace(/^wss?:\/\//, "").replace(/:\d+$/, ""),
        websocket_port: this.config.websocket_port ? Number(this.config.websocket_port) : this.config.server_url.includes("wss://") ? 443 : 80,
        use_secure: this.config.server_url.startsWith("wss://"),
        display_name: this.config.display_name,
        debug: this.config.debug,
      };

      this.sipManager = new SipManager();
      this.callManager = new CallManager(this.sipManager);

      // Setup event handlers
      this.setupEventHandlers();

      // Initialize call state
      this.callState = this.callManager.getCallState();

      //  FIX: Use the initialize method directly (should work now)
      await this.sipManager.initialize(sipConfig);
    } catch (error) {
      this.error = error instanceof Error ? error.message : "Configuration failed";
      this.connected = false;
      this.registered = false;
      console.error("SIP initialization failed:", error);
    }
  }

  private setupEventHandlers(): void {
    if (!this.sipManager || !this.callManager) return;

    // SIP connection events
    this.sipManager.addEventListener("connected", () => {
      this.connected = true;
      this.requestUpdate();
    });

    this.sipManager.addEventListener("disconnected", () => {
      this.connected = false;
      this.registered = false;
      this.requestUpdate();
    });

    this.sipManager.addEventListener("registered", (event: any) => {
      this.registered = event.detail.registered;
      if (this.registered) {
        this.error = null;
      }
      this.requestUpdate();
    });

    this.sipManager.addEventListener("error", (event: any) => {
      this.error = event.detail.error;
      this.connected = false;
      this.registered = false;
      this.requestUpdate();
    });

    // Local video state events
    this.sipManager.addEventListener("localVideoChanged", (event: any) => {
      // Update call state when local video changes
      this.callState = this.callManager?.getCallState() || this.callState;
      this.requestUpdate();
    });

    // Call state events
    this.callManager.addEventListener("callStateChanged", (event: any) => {
      this.callState = event.detail.callState;
      this.updateRemoteVideo();
      this.requestUpdate();
    });
  }

  private updateRemoteVideo(): void {
    if (this.callState.active && this.remoteVideoElement) {
      const remoteVideo = this.callManager?.getRemoteVideo();
      if (remoteVideo && remoteVideo.srcObject) {
        this.remoteVideoElement.srcObject = remoteVideo.srcObject;
      }
    }
  }

  connectedCallback() {
    super.connectedCallback();
    if (this.config) {
      this.initializeSipClient();
    }
  }

  disconnectedCallback() {
    super.disconnectedCallback();
    if (this.sipManager) {
      this.sipManager.disconnect().catch(console.error);
    }
  }

  protected render(): TemplateResult {
    if (!this.config) {
      return html`<ha-card><div class="error">Configuration required</div></ha-card>`;
    }

    return html` <ha-card> ${this.renderStatusBar()} ${this.renderError()} ${this.renderContent()} ${this.renderIncomingCallModal()} </ha-card> `;
  }

  private renderStatusBar(): TemplateResult {
    const statusClass = this.registered ? "connected" : this.connected ? "connecting" : "disconnected";
    const statusText = this.registered ? "Connected" : this.connected ? "Connecting..." : "Disconnected";

    return html`
      <div class="status-bar">
        <div class="status-indicator">
          <div class="status-dot ${statusClass}"></div>
          <span>${statusText}</span>
        </div>
        <div class="card-title">${this.config.title || "WebRTC SIP Phone"}</div>
      </div>
    `;
  }

  private renderError(): TemplateResult {
    if (!this.error) return html``;

    return html`
      <div class="error-message">
        <ha-icon icon="mdi:alert-circle"></ha-icon>
        ${this.error}
      </div>
    `;
  }

  private renderContent(): TemplateResult {
    if (this.callState.active) {
      return this.renderActiveCall();
    }

    return html` <div class="card-content">${this.renderContacts()} ${this.renderManualDial()} ${this.showKeypad ? this.renderKeypad() : ""}</div> `;
  }

  private renderContacts(): TemplateResult {
    if (!this.config.contacts.length) {
      return html`<div class="no-contacts">No contacts configured</div>`;
    }

    return html`
      <div class="contacts-section">
        <h3>Quick Dial</h3>
        <div class="contacts-grid">${this.config.contacts.map((contact) => this.renderContact(contact))}</div>
      </div>
    `;
  }

  private renderContact(contact: SIPContact): TemplateResult {
    return html`
      <button class="contact-button" @click=${() => this.callContact(contact)} ?disabled=${!this.registered}>
        <ha-icon class="contact-icon" icon=${contact.icon || "mdi:phone"}></ha-icon>
        <div class="contact-name">${contact.name}</div>
        <div class="contact-extension">${formatPhoneNumber(contact.extension)}</div>
      </button>
    `;
  }

  private renderManualDial(): TemplateResult {
    return html`
      <div class="manual-dial">
        <div class="dial-input-container">
          <ha-textfield .value=${this.currentInput} @input=${this.handleInputChange} placeholder="Enter number..." ?disabled=${!this.registered}></ha-textfield>
          <ha-icon-button @click=${this.toggleKeypad} icon="mdi:dialpad" ?disabled=${!this.registered}></ha-icon-button>
        </div>
        <div class="dial-actions">
          <ha-button @click=${this.makeCall} ?disabled=${!this.registered || !this.currentInput.trim()} class="primary">
            <ha-icon icon="mdi:phone" slot="icon"></ha-icon> Call
          </ha-button>
          <ha-button
            @click=${() => this.makeVideoCall()}
            ?disabled=${!this.registered || !this.currentInput.trim() || !this.config.video_enabled}
            class="video-call"
          >
            <ha-icon icon="mdi:video" slot="icon"></ha-icon> Video Call
          </ha-button>
          <ha-button @click=${this.clearInput} ?disabled=${!this.currentInput.length}> Clear </ha-button>
        </div>
      </div>
    `;
  }

  private renderKeypad(): TemplateResult {
    return html`
      <div class="keypad">
        ${DTMF_KEYS.flat().map((key) => html` <button class="keypad-button" @click=${() => this.handleKeypadPress(key)}>${key}</button> `)}
      </div>
    `;
  }

  private renderActiveCall(): TemplateResult {
    const isIncoming = this.callState.incoming && this.callState.status === "ringing";
    const isActive = this.callState.status === "answered";

    return html`
      <div class="active-call">
        ${this.renderCallInfo()} ${this.renderVideoStatus()} ${this.callState.remoteVideoEnabled ? this.renderVideoArea() : ""}
        ${isIncoming ? this.renderIncomingCallControls() : ""} ${isActive ? this.renderCallControls() : ""}
        ${isActive && !this.config.hide_keypad ? this.renderInCallKeypad() : ""}
      </div>
    `;
  }

  private renderCallInfo(): TemplateResult {
    // Force update the duration by accessing it directly
    const duration = this.callManager?.getFormattedDuration() || "00:00";

    return html`
      <div class="call-info">
        <div class="caller-name">${this.callState.callerName || "Unknown"}</div>
        <div class="caller-number">${formatPhoneNumber(this.callState.callerId || "")}</div>
        <div class="call-status">${this.getCallStatusText()}</div>
        ${this.callState.status === "answered" ? html`<div class="call-duration">${duration}</div>` : ""}
      </div>
    `;
  }

  // NEW: Video status indicator
  private renderVideoStatus(): TemplateResult {
    if (!this.config.video_enabled) {
      return html``;
    }

    return html`
      <div class="video-status">
        <div class="video-indicator ${this.callState.localVideoTransmitting ? "active" : "inactive"}">
          <ha-icon icon=${this.callState.localVideoTransmitting ? "mdi:video" : "mdi:video-off"}></ha-icon>
          <span>${this.callState.localVideoTransmitting ? "Camera On" : "Camera Off"}</span>
        </div>
      </div>
    `;
  }

  private renderVideoArea(): TemplateResult {
    return html`
      <div class="video-container">
        <video id="remote-video" autoplay playsinline ?muted=${false}></video>
        ${!this.callState.remoteVideoEnabled
          ? html`
              <div class="video-overlay">
                <ha-icon icon="mdi:video-off"></ha-icon>
                <div>No remote video</div>
              </div>
            `
          : ""}
      </div>
    `;
  }

  private renderIncomingCallControls(): TemplateResult {
    return html`
      <div class="call-controls">
        <button class="control-button primary" @click=${this.answerCall}>
          <ha-icon icon="mdi:phone"></ha-icon>
        </button>
        ${this.config.video_enabled
          ? html`
              <button class="control-button video" @click=${() => this.answerCall(true)}>
                <ha-icon icon="mdi:video"></ha-icon>
              </button>
            `
          : ""}
        <button class="control-button danger" @click=${this.rejectCall}>
          <ha-icon icon="mdi:phone-hangup"></ha-icon>
        </button>
      </div>
    `;
  }

  private renderCallControls(): TemplateResult {
    return html`
      <div class="call-controls">
        <button class="control-button ${this.callState.muted ? "danger" : "secondary"}" @click=${this.toggleMute}>
          <ha-icon icon=${this.callState.muted ? "mdi:microphone-off" : "mdi:microphone"}></ha-icon>
        </button>

        ${this.config.video_enabled
          ? html`
              <button
                class="control-button ${this.callState.localVideoTransmitting ? "primary" : "secondary"}"
                @click=${this.toggleVideo}
                title=${this.callState.localVideoTransmitting ? "Turn off camera" : "Turn on camera"}
              >
                <ha-icon icon=${this.callState.localVideoTransmitting ? "mdi:video" : "mdi:video-off"}></ha-icon>
              </button>
            `
          : ""}

        <button class="control-button ${this.callState.onHold ? "primary" : "secondary"}" @click=${this.toggleHold}>
          <ha-icon icon=${this.callState.onHold ? "mdi:play" : "mdi:pause"}></ha-icon>
        </button>

        <button class="control-button danger" @click=${this.hangupCall}>
          <ha-icon icon="mdi:phone-hangup"></ha-icon>
        </button>

        <button class="control-button secondary" @click=${() => (this.showKeypad = !this.showKeypad)}>
          <ha-icon icon="mdi:dialpad"></ha-icon>
        </button>
      </div>
    `;
  }

  private renderInCallKeypad(): TemplateResult {
    if (!this.showKeypad) return html``;

    return html`
      <div class="in-call-keypad">
        <div class="keypad">${DTMF_KEYS.flat().map((key) => html` <button class="keypad-button" @click=${() => this.sendDTMF(key)}>${key}</button> `)}</div>
      </div>
    `;
  }

  private renderIncomingCallModal(): TemplateResult {
    if (!this.callState.incoming || this.callState.status !== "ringing") {
      return html``;
    }

    return html`
      <div class="incoming-call-modal">
        <div class="incoming-call-content">
          <div class="incoming-call-avatar">
            <ha-icon icon="mdi:account"></ha-icon>
          </div>
          <div class="caller-name">${this.callState.callerName || "Unknown Caller"}</div>
          <div class="caller-number">${formatPhoneNumber(this.callState.callerId || "")}</div>
          <div class="incoming-call-actions">
            <button class="answer-button" @click=${this.answerCall}>
              <ha-icon icon="mdi:phone"></ha-icon>
            </button>
            ${this.config.video_enabled
              ? html`
                  <button class="video-answer-button" @click=${() => this.answerCall(true)}>
                    <ha-icon icon="mdi:video"></ha-icon>
                  </button>
                `
              : ""}
            <button class="reject-button" @click=${this.rejectCall}>
              <ha-icon icon="mdi:phone-hangup"></ha-icon>
            </button>
          </div>
        </div>
      </div>
    `;
  }

  private getCallStatusText(): string {
    switch (this.callState.status) {
      case "connecting":
        return "Connecting...";
      case "ringing":
        return this.callState.incoming ? "Incoming call" : "Ringing...";
      case "answered":
        return this.callState.onHold ? "On hold" : "Connected";
      case "ended":
        return "Call ended";
      case "error":
        return "Call failed";
      default:
        return "";
    }
  }

  // Event handlers
  private handleInputChange(event: Event): void {
    const target = event.target as HTMLInputElement;
    this.currentInput = sanitizeExtension(target.value);
  }

  private handleKeypadPress(key: string): void {
    this.currentInput += key;
    this.requestUpdate();
  }

  private toggleKeypad(): void {
    this.showKeypad = !this.showKeypad;
  }

  private clearInput(): void {
    this.currentInput = "";
  }

  private async callContact(contact: SIPContact): Promise<void> {
    if (!this.callManager || !this.registered) return;

    try {
      await this.callManager.makeCall(contact.extension);
    } catch (error) {
      console.error("Failed to call contact:", error);
      this.error = `Failed to call ${contact.name}`;
    }
  }

  private async makeCall(): Promise<void> {
    if (!this.callManager || !this.registered || !this.currentInput.trim()) return;

    try {
      await this.callManager.makeCall(this.currentInput.trim());
      this.currentInput = "";
      this.showKeypad = false;
    } catch (error) {
      console.error("Failed to make call:", error);
      this.error = "Failed to make call";
    }
  }

  // NEW: Video call method
  private async makeVideoCall(): Promise<void> {
    if (!this.callManager || !this.registered || !this.currentInput.trim()) return;

    try {
      await this.callManager.makeCall(this.currentInput.trim(), true); // Include video
      this.currentInput = "";
      this.showKeypad = false;
    } catch (error) {
      console.error("Failed to make video call:", error);
      this.error = "Failed to make video call";
    }
  }

  private async answerCall(withVideo = false): Promise<void> {
    if (!this.callManager) return;

    try {
      if (withVideo && this.config.video_enabled) {
        // Enable video before answering
        await this.callManager.enableVideo();
      }
      await this.callManager.answerCall();
    } catch (error) {
      console.error("Failed to answer call:", error);
      this.error = "Failed to answer call";
    }
  }

  private async rejectCall(): Promise<void> {
    if (!this.callManager) return;

    try {
      await this.callManager.rejectCall();
    } catch (error) {
      console.error("Failed to reject call:", error);
    }
  }

  private async hangupCall(): Promise<void> {
    if (!this.callManager) return;

    try {
      await this.callManager.hangupCall();
      this.showKeypad = false;
    } catch (error) {
      console.error("Failed to hangup call:", error);
    }
  }

  private async toggleMute(): Promise<void> {
    if (!this.callManager) return;

    try {
      await this.callManager.toggleMute();
    } catch (error) {
      console.error("Failed to toggle mute:", error);
      this.error = "Failed to toggle mute";
    }
  }

  // NEW: Video toggle method
  private async toggleVideo(): Promise<void> {
    if (!this.callManager) return;

    try {
      await this.callManager.toggleVideo();
    } catch (error) {
      console.error("Toggle video failed:", error);
      this.error = "Failed to toggle video";
    }
  }

  private async toggleHold(): Promise<void> {
    if (!this.callManager) return;

    try {
      if (this.callState.onHold) {
        await this.callManager.unholdCall();
      } else {
        await this.callManager.holdCall();
      }
    } catch (error) {
      console.error("Failed to toggle hold:", error);
      this.error = "Failed to toggle hold";
    }
  }

  private sendDTMF(tone: string): void {
    if (!this.callManager) return;
    this.callManager.sendDTMF(tone);
  }

  static get styles(): CSSResultGroup {
    return [
      sharedStyles,
      css`
        .card-title {
          font-weight: 500;
          font-size: 16px;
        }

        .no-contacts {
          text-align: center;
          color: var(--sip-text-secondary-color);
          padding: 32px;
          font-style: italic;
        }

        .contacts-section h3 {
          margin: 0 0 16px 0;
          font-size: 18px;
          font-weight: 500;
        }

        .manual-dial {
          margin-top: 24px;
          padding-top: 24px;
          border-top: 1px solid var(--sip-divider-color);
        }

        .dial-input-container {
          display: flex;
          gap: 8px;
          margin-bottom: 16px;
        }

        .dial-input-container ha-textfield {
          flex: 1;
        }

        .dial-actions {
          display: flex;
          gap: 12px;
          justify-content: center;
          flex-wrap: wrap;
        }

        .active-call {
          padding: 16px;
        }

        .call-status {
          font-size: 14px;
          color: var(--sip-text-secondary-color);
          margin-bottom: 8px;
        }

        .in-call-keypad {
          margin-top: 16px;
          padding-top: 16px;
          border-top: 1px solid var(--sip-divider-color);
        }

        /* Video status styles */
        .video-status {
          display: flex;
          justify-content: center;
          padding: 8px 16px;
          background: var(--secondary-background-color);
          border-radius: 8px;
          margin-bottom: 16px;
        }

        .video-indicator {
          display: flex;
          align-items: center;
          gap: 8px;
          padding: 4px 12px;
          border-radius: 16px;
          font-size: 12px;
          font-weight: 500;
          transition: all 0.2s ease;
        }

        .video-indicator.active {
          background: rgba(var(--success-color-rgb, 76, 175, 80), 0.1);
          color: var(--success-color, #4caf50);
        }

        .video-indicator.active ha-icon {
          color: var(--success-color, #4caf50);
        }

        .video-indicator.inactive {
          background: rgba(var(--disabled-text-color-rgb, 128, 128, 128), 0.1);
          color: var(--disabled-text-color, #808080);
        }

        .video-indicator.inactive ha-icon {
          color: var(--disabled-text-color, #808080);
        }

        /* Call controls enhancements */
        .control-button.primary {
          background: var(--sip-success-color);
          color: white;
        }

        .control-button.video {
          background: var(--primary-color);
          color: white;
        }

        .control-button.secondary {
          background: var(--secondary-background-color);
          color: var(--primary-text-color);
        }

        .control-button.danger {
          background: var(--sip-danger-color);
          color: white;
        }

        /* Incoming call modal enhancements */
        .incoming-call-actions {
          display: flex;
          justify-content: center;
          gap: 24px;
        }

        .video-answer-button {
          background: var(--primary-color);
          border: none;
          border-radius: 50%;
          width: 64px;
          height: 64px;
          color: white;
          font-size: 24px;
          cursor: pointer;
          transition: all 0.2s ease;
        }

        .video-answer-button:hover {
          transform: scale(1.1);
        }

        ha-button.primary {
          --mdc-theme-primary: var(--sip-success-color);
        }

        ha-button.video-call {
          --mdc-theme-primary: var(--primary-color);
        }

        ha-textfield {
          width: 100%;
        }

        ha-icon-button {
          --mdc-icon-button-size: 40px;
        }
      `,
    ];
  }
}

declare global {
  interface HTMLElementTagNameMap {
    "ha-webrtc-sip-card": WebRTCSipCard;
  }
}

// Register the card with Home Assistant
(window as any).customCards = (window as any).customCards || [];
(window as any).customCards.push({
  type: "ha-webrtc-sip-card",
  name: "WebRTC SIP Card",
  description: "A modern WebRTC SIP client card for Home Assistant",
  version: CARD_VERSION,
});

console.info(
  `%c HA-WEBRTC-SIP-CARD %c ${CARD_VERSION} `,
  "color: white; background: #03a9f4; font-weight: bold;",
  "color: #03a9f4; background: white; font-weight: bold;"
);

---

=== Object: 43c20c10f881bcda055b94c23efe2f0777544337 | Date: 2025-09-22 12:13:48 | Type: blob ===

import type { CallInfo } from "./sip-manager";
import { SipManager } from "./sip-manager";
import { formatDuration, playRingtone, stopRingtone } from "./utils";

export interface CallState {
  active: boolean;
  incoming: boolean;
  outgoing: boolean;
  onHold: boolean;
  muted: boolean;
  remoteVideoEnabled: boolean;
  localVideoTransmitting: boolean;
  callerId?: string;
  callerName?: string;
  duration: number;
  status: "idle" | "connecting" | "ringing" | "answered" | "held" | "ended" | "error";
}

export class CallManager extends EventTarget {
  private sipManager: SipManager;
  private callState: CallState;
  private ringtone: HTMLAudioElement | null = null;
  private ringTimeout: number | null = null;

  constructor(sipManager: SipManager) {
    super();
    this.sipManager = sipManager;
    this.callState = this.getInitialState();
    this.setupSipEventHandlers();
  }

  private getInitialState(): CallState {
    return {
      active: false,
      incoming: false,
      outgoing: false,
      onHold: false,
      muted: false,
      remoteVideoEnabled: false,
      localVideoTransmitting: false,
      duration: 0,
      status: "idle",
    };
  }

  private setupSipEventHandlers(): void {
    this.sipManager.addEventListener("incomingCall", this.handleIncomingCall.bind(this) as EventListener);
    this.sipManager.addEventListener("callStarted", this.handleCallStarted.bind(this) as EventListener);
    this.sipManager.addEventListener("callAnswered", this.handleCallAnswered.bind(this) as EventListener);
    this.sipManager.addEventListener("callEnded", this.handleCallEnded.bind(this) as EventListener);
    this.sipManager.addEventListener("callFailed", this.handleCallFailed.bind(this) as EventListener);
    this.sipManager.addEventListener("localVideoChanged", this.handleLocalVideoChanged.bind(this) as EventListener);
    this.sipManager.addEventListener("callTimer", this.handleCallTimer.bind(this) as EventListener);
    this.sipManager.addEventListener("callHold", this.handleCallHold.bind(this) as EventListener);
  }

  private handleIncomingCall(event: CustomEvent): void {
    const { from, displayName } = event.detail;

    this.callState = {
      ...this.callState,
      active: true,
      incoming: true,
      outgoing: false,
      callerId: from,
      callerName: displayName,
      status: "ringing",
    };

    // Start ringtone
    this.ringtone = playRingtone();

    // Auto-reject after timeout (configurable)
    this.ringTimeout = window.setTimeout(() => {
      this.rejectCall();
    }, 30000); // 30 seconds default

    this.dispatchCallStateUpdate();
  }

  private handleCallStarted(event: CustomEvent): void {
    const { target } = event.detail;

    this.callState = {
      ...this.callState,
      active: true,
      incoming: false,
      outgoing: true,
      callerId: target,
      callerName: target,
      status: "connecting",
    };

    this.dispatchCallStateUpdate();
  }

  private handleCallAnswered(_event: CustomEvent): void {
    this.stopRinging();

    this.callState = {
      ...this.callState,
      status: "answered",
      incoming: false,
      outgoing: false,
    };

    // Check if remote video is available
    const remoteVideo = this.sipManager.getRemoteVideo();
    if (remoteVideo && remoteVideo.srcObject) {
      const stream = remoteVideo.srcObject as MediaStream;
      this.callState.remoteVideoEnabled = stream.getVideoTracks().length > 0;
    }

    this.dispatchCallStateUpdate();
  }

  private handleCallEnded(_event: CustomEvent): void {
    this.stopRinging();
    this.clearRingTimeout();

    this.callState = this.getInitialState();
    this.callState.status = "ended";

    this.dispatchCallStateUpdate();

    // Reset to idle after a brief moment
    setTimeout(() => {
      this.callState.status = "idle";
      this.dispatchCallStateUpdate();
    }, 2000);
  }

  private handleCallFailed(_event: CustomEvent): void {
    this.stopRinging();
    this.clearRingTimeout();

    this.callState = this.getInitialState();
    this.callState.status = "error";

    this.dispatchCallStateUpdate();
  }

  private handleCallTimer(event: CustomEvent): void {
    const { duration } = event.detail;
    this.callState.duration = duration;
    this.dispatchCallStateUpdate();
  }

  private handleCallHold(event: CustomEvent): void {
    const { held } = event.detail;
    this.callState.onHold = held;
    this.callState.status = held ? "held" : "answered";
    this.dispatchCallStateUpdate();
  }

  private handleLocalVideoChanged(event: CustomEvent): void {
    const { transmitting } = event.detail;
    this.callState.localVideoTransmitting = transmitting;
    this.dispatchCallStateUpdate();
  }

  /**
   * Toggle video on/off
   */
  public async toggleVideo(): Promise<boolean> {
    try {
      const enabled = await this.sipManager.toggleVideo();
      return enabled;
    } catch (error) {
      console.error("Failed to toggle video:", error);
      throw error;
    }
  }

  /**
   * Enable video
   */
  public async enableVideo(): Promise<void> {
    try {
      await this.sipManager.enableVideo();
    } catch (error) {
      console.error("Failed to enable video:", error);
      throw error;
    }
  }

  /**
   * Disable video
   */
  public async disableVideo(): Promise<void> {
    try {
      await this.sipManager.disableVideo();
    } catch (error) {
      console.error("Failed to disable video:", error);
      throw error;
    }
  }

  /**
   * Make a call with optional video
   * @param target The SIP address or extension to call
   * @param withVideo Whether to start the call with video
   */
  public async makeCallWithVideo(target: string, withVideo = false): Promise<void> {
    try {
      await this.sipManager.makeCall(target, withVideo);
    } catch (error) {
      this.callState.status = "error";
      this.dispatchCallStateUpdate();
      throw error;
    }
  }

  private stopRinging(): void {
    if (this.ringtone) {
      stopRingtone(this.ringtone);
      this.ringtone = null;
    }
  }

  private clearRingTimeout(): void {
    if (this.ringTimeout) {
      clearTimeout(this.ringTimeout);
      this.ringTimeout = null;
    }
  }

  private dispatchCallStateUpdate(): void {
    this.dispatchEvent(
      new CustomEvent("callStateChanged", {
        detail: { callState: { ...this.callState } },
      })
    );
  }

  // Public methods for call control
  async makeCall(target: string, includeVideo?: boolean): Promise<void> {
    try {
      await this.sipManager.makeCall(target, includeVideo);
    } catch (error) {
      this.callState.status = "error";
      this.dispatchCallStateUpdate();
      throw error;
    }
  }

  async answerCall(): Promise<void> {
    try {
      await this.sipManager.answerCall();
    } catch (error) {
      this.callState.status = "error";
      this.dispatchCallStateUpdate();
      throw error;
    }
  }

  async rejectCall(): Promise<void> {
    this.stopRinging();
    this.clearRingTimeout();

    try {
      await this.sipManager.rejectCall();
    } catch (error) {
      // Still update state even if rejection fails
      this.callState = this.getInitialState();
      this.dispatchCallStateUpdate();
      throw error;
    }
  }

  async hangupCall(): Promise<void> {
    try {
      await this.sipManager.hangup();
    } catch (error) {
      // Force end call state even if hangup fails
      this.callState = this.getInitialState();
      this.dispatchCallStateUpdate();
      throw error;
    }
  }

  async holdCall(): Promise<void> {
    try {
      await this.sipManager.hold();
    } catch (error) {
      throw error;
    }
  }

  async unholdCall(): Promise<void> {
    try {
      await this.sipManager.unhold();
    } catch (error) {
      throw error;
    }
  }

  async toggleMute(): Promise<boolean> {
    try {
      if (this.callState.muted) {
        await this.sipManager.unmute();
        this.callState.muted = false;
      } else {
        await this.sipManager.mute();
        this.callState.muted = true;
      }

      this.dispatchCallStateUpdate();
      return this.callState.muted;
    } catch (error) {
      throw error;
    }
  }

  sendDTMF(tone: string): void {
    if (this.callState.active && this.callState.status === "answered") {
      this.sipManager.sendDTMF(tone);
    }
  }

  getCallState(): CallState {
    return { ...this.callState };
  }

  getRemoteVideo(): HTMLVideoElement | null {
    return this.sipManager.getRemoteVideo();
  }

  getCurrentCall(): CallInfo | null {
    return this.sipManager.getCurrentCall();
  }

  getFormattedDuration(): string {
    return formatDuration(this.callState.duration);
  }
}

---

=== Object: 0fd8b0ad49cd10808e56e2fd332970776d277fd8 | Date: 2025-09-22 12:13:48 | Type: blob ===

{"pid": 67, "version": 1, "ha_version": "2025.10.0.dev202509180233", "start_ts": 1758533060.289645}
---

=== Object: 0c463f5a8eab89d43018c158aa253f543c444ead | Date: 2025-09-22 12:13:48 | Type: blob ===

import { debugLog, errorLog } from "./utils";

type SimpleUser = any;
type SimpleUserOptions = any;
let Web: any = null;

export interface SipConfig {
  server: string;
  username: string;
  password: string;
  domain: string;
  websocket_port: number;
  use_secure: boolean;
  display_name?: string;
  debug?: boolean;
}

export interface CallInfo {
  id: string;
  remoteIdentity: string;
  displayName: string;
  state: "incoming" | "outgoing" | "connected" | "ended";
  startTime?: Date;
  duration: number;
}

export class SipManager extends EventTarget {
  private simpleUser: SimpleUser | null = null;
  private config: SipConfig | null = null;
  private isRegistered = false;
  private isConnected = false;
  private connectionTimer: number | null = null;
  private currentCall: CallInfo | null = null;
  private remoteAudio: HTMLAudioElement | null = null;
  private localVideo: HTMLVideoElement | null = null;
  private localStream: MediaStream | null = null;
  private videoEnabled = false;
  private isInitialized = false;
  private isInitializing = false;

  constructor() {
    super();
    this.setupMediaElements();
  }

  private setupMediaElements(): void {
    // Setup remote audio element
    this.remoteAudio = document.createElement("audio");
    this.remoteAudio.autoplay = true;
    this.remoteAudio.style.display = "none";
    document.body.appendChild(this.remoteAudio);

    // Setup local video element (hidden, for capture only)
    this.localVideo = document.createElement("video");
    this.localVideo.autoplay = true;
    this.localVideo.muted = true; // Always mute own video
    this.localVideo.playsInline = true;
    this.localVideo.style.display = "none";
    document.body.appendChild(this.localVideo);
  }

  /**
   * Enable local video stream
   */
  public async enableVideo(): Promise<void> {
    try {
      if (!this.localStream) {
        this.localStream = await navigator.mediaDevices.getUserMedia({
          video: {
            width: { ideal: 320 },
            height: { ideal: 240 },
            frameRate: { ideal: 15, max: 30 },
          },
          audio: false // We already have audio from the call
        });
      }

      if (this.localVideo && this.localStream) {
        this.localVideo.srcObject = this.localStream;
      }

      this.videoEnabled = true;
      debugLog(this.config?.debug || false, "Local video enabled");

      // Notify that video state changed
      this.dispatchEvent(
        new CustomEvent("localVideoChanged", {
          detail: { 
            enabled: true,
            transmitting: this.localStream.getVideoTracks().some(track => track.enabled)
          },
        })
      );

      // If in call, add video track to existing session
      if (this.simpleUser && this.currentCall?.state === "connected") {
        await this.updateCallWithVideo(true);
      }

    } catch (error) {
      errorLog("Enable video failed", error);
      throw error;
    }
  }

  /**
   * Disable local video stream
   */
  public async disableVideo(): Promise<void> {
    try {
      if (this.localStream) {
        this.localStream.getVideoTracks().forEach(track => {
          track.stop();
        });
        this.localStream = null;
      }

      if (this.localVideo) {
        this.localVideo.srcObject = null;
      }

      this.videoEnabled = false;
      debugLog(this.config?.debug || false, "Local video disabled");

      this.dispatchEvent(
        new CustomEvent("localVideoChanged", {
          detail: { 
            enabled: false,
            transmitting: false
          },
        })
      );

      // If in call, remove video track
      if (this.simpleUser && this.currentCall?.state === "connected") {
        await this.updateCallWithVideo(false);
      }

    } catch (error) {
      errorLog("Disable video failed", error);
      throw error;
    }
  }

  /**
   * Toggle video state
   * @returns New video state (true if enabled, false if disabled)
   */
  public async toggleVideo(): Promise<boolean> {
    if (this.videoEnabled) {
      await this.disableVideo();
      return false;
    } else {
      await this.enableVideo();
      return true;
    }
  }

  /**
   * Get current video state
   */
  public getLocalVideoState(): { enabled: boolean; transmitting: boolean } {
    return {
      enabled: this.videoEnabled,
      transmitting: this.localStream ? 
        this.localStream.getVideoTracks().some(track => track.enabled) : false
    };
  }

  /**
   * Update call with current video state
   * @param enable Whether to enable or disable video
   */
  private async updateCallWithVideo(enable: boolean): Promise<void> {
    try {
      if (this.simpleUser) {
        const constraints = {
          audio: true,
          video: enable
        };
        
        // Update the call with new media constraints
        if (typeof this.simpleUser.setMediaConstraints === 'function') {
          await this.simpleUser.setMediaConstraints(constraints);
        }
        
        debugLog(this.config?.debug || false, `Updated call video: ${enable}`);
      }
    } catch (error) {
      errorLog("Update call video failed", error);
      throw error;
    }
  }

  /**
   * Wait for SIP.js library to be fully loaded and functional
   */
  private async waitForSipLibrary(timeout = 15000): Promise<void> {
    return new Promise<void>(async (resolve, reject) => {
      const startTime = Date.now();
      const timeoutId = setTimeout(() => {
        reject(new Error(`SIP.js library loading timeout after ${timeout}ms`));
      }, timeout);

      const checkLibrary = async () => {
        try {
          // Try to dynamically import the library
          if (!Web) {
            const SIP = await import("sip.js");
            Web = (SIP as any).Web || SIP;
          }

          // Check if library is fully loaded with required methods
          const isFullyLoaded =
            Web &&
            Web.SimpleUser &&
            Web.SimpleUser.prototype &&
            typeof Web.SimpleUser.prototype.register === "function" &&
            typeof Web.SimpleUser.prototype.connect === "function" &&
            typeof Web.SimpleUser.prototype.disconnect === "function";

          if (isFullyLoaded) {
            clearTimeout(timeoutId);
            debugLog(this.config?.debug || false, "SIP.js library fully loaded and verified");
            resolve();
            return;
          }

          // Check timeout
          if (Date.now() - startTime > timeout) {
            clearTimeout(timeoutId);
            reject(new Error("SIP.js library verification timeout"));
            return;
          }

          // Retry after short delay
          setTimeout(checkLibrary, 100);
        } catch (error) {
          // If import fails, try again
          setTimeout(checkLibrary, 200);
        }
      };

      // Start checking
      checkLibrary();
    });
  }

  /**
   * Ensure SIP client is initialized - lazy loading approach
   */
  private async ensureSipClient(): Promise<void> {
    if (this.isInitialized) return;

    if (this.isInitializing) {
      // Wait for current initialization to complete
      return new Promise((resolve, reject) => {
        const checkInterval = setInterval(() => {
          if (this.isInitialized) {
            clearInterval(checkInterval);
            resolve();
          } else if (!this.isInitializing) {
            clearInterval(checkInterval);
            reject(new Error("Initialization failed"));
          }
        }, 100);
      });
    }

    if (!this.config) {
      throw new Error("SIP configuration not set");
    }

    await this.initialize(this.config);
  }

  /**
   * Set configuration but don't initialize immediately
   */
  setConfig(config: SipConfig): void {
    this.config = config;
    // Don't initialize here - wait for actual use
    debugLog(config.debug || false, "SIP configuration set, will initialize on first use");
  }

  /**
   * Initialize SIP client with full library loading verification
   */
  async initialize(config: SipConfig): Promise<void> {
    if (this.isInitializing || this.isInitialized) return;

    this.isInitializing = true;
    this.config = config;

    debugLog(config.debug || false, "Starting lazy SIP initialization", {
      server: config.server,
      username: config.username,
      domain: config.domain,
      websocket_port: config.websocket_port,
      use_secure: config.use_secure,
    });

    try {
      // Step 1: Wait for SIP.js library to be fully loaded
      debugLog(config.debug || false, "Waiting for SIP.js library to load...");
      await this.waitForSipLibrary();

      // Step 2: Add safety delay for library stabilization
      await new Promise((resolve) => setTimeout(resolve, 500));

      // Step 3: Construct connection parameters
      const wsProtocol = config.use_secure ? "wss" : "ws";
      const wsPort = config.websocket_port || (config.use_secure ? 443 : 80);
      const wsServer = `${wsProtocol}://${config.server}:${wsPort}`;
      const sipAor = `sip:${config.username}@${config.domain}`;

      debugLog(config.debug || false, "WebSocket URL:", wsServer);
      debugLog(config.debug || false, "SIP AOR:", sipAor);

      // Step 4: Helper function for audio element
      const getAudioElement = (): HTMLAudioElement => {
        if (!this.remoteAudio) {
          this.setupMediaElements();
        }
        return this.remoteAudio!;
      };

      // Step 5: Create SimpleUser options
      const options: SimpleUserOptions = {
        aor: sipAor,
        media: {
          constraints: {
            audio: true,
            video: false,
          },
          remote: {
            audio: getAudioElement(),
          },
        },
        userAgentOptions: {
          authorizationUsername: config.username,
          authorizationPassword: config.password,
          displayName: config.display_name || config.username,
          transportOptions: {
            server: wsServer,
            connectionTimeout: 15,
            maxReconnectionAttempts: 3,
            reconnectionTimeout: 4,
          },
          logLevel: config.debug ? "debug" : "error",
          sessionDescriptionHandlerFactoryOptions: {
            constraints: {
              audio: true,
              video: false,
            },
            peerConnectionConfiguration: {
              iceServers: [{ urls: "stun:stun.l.google.com:19302" }, { urls: "stun:stun1.l.google.com:19302" }],
            },
          },
        },
      };

      // Step 6: Create SimpleUser instance with verification
      debugLog(config.debug || false, "Creating SimpleUser instance...");

      if (!Web || !Web.SimpleUser) {
        throw new Error("SIP.js Web.SimpleUser not available after loading");
      }

      this.simpleUser = new Web.SimpleUser(wsServer, options);

      if (!this.simpleUser) {
        throw new Error("Failed to create SimpleUser instance");
      }

      // Step 7: Verify critical methods exist
      if (!this.simpleUser.register || typeof this.simpleUser.register !== "function") {
        throw new Error("SimpleUser register method not available - library incomplete");
      }

      if (!this.simpleUser.connect || typeof this.simpleUser.connect !== "function") {
        throw new Error("SimpleUser connect method not available - library incomplete");
      }

      debugLog(config.debug || false, "SimpleUser created and verified successfully");

      // Step 8: Set up event handlers
      this.setupEventHandlers();

      // Step 9: Connect to server
      debugLog(config.debug || false, `Connecting to: ${wsServer}`);
      await this.simpleUser.connect();

      this.isConnected = true;
      this.dispatchEvent(new CustomEvent("connected"));
      debugLog(config.debug || false, "Connected to WebSocket server");

      // Step 10: Register with server
      debugLog(config.debug || false, "Registering with SIP server...");
      await this.simpleUser.register();

      this.isRegistered = true;
      this.dispatchEvent(new CustomEvent("registered", { detail: { registered: true } }));

      // Step 11: Start monitoring
      this.startConnectionMonitoring();

      this.isInitialized = true;
      this.isInitializing = false;

      debugLog(config.debug || false, "SIP client lazy initialization completed successfully");
    } catch (error) {
      this.isInitializing = false;
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      errorLog("SIP lazy initialization failed:", errorMessage);

      this.isConnected = false;
      this.isRegistered = false;

      // Cleanup on failure
      if (this.simpleUser) {
        try {
          await this.simpleUser.disconnect();
        } catch (cleanupError) {
          debugLog(config.debug || false, "Cleanup error", cleanupError);
        }
        this.simpleUser = null;
      }

      this.dispatchEvent(
        new CustomEvent("error", {
          detail: {
            error: errorMessage,
            type: "initialization",
          },
        })
      );

      throw new Error(`Failed to initialize SIP client: ${errorMessage}`);
    }
  }

  private setupEventHandlers(): void {
    if (!this.simpleUser) {
      errorLog("Cannot setup event handlers: SimpleUser is null");
      return;
    }

    debugLog(this.config?.debug || false, "Setting up event handlers");

    // Set delegate for SimpleUser events
    this.simpleUser.delegate = {
      onCallCreated: () => {
        debugLog(this.config?.debug || false, "Call created");
        this.dispatchEvent(new CustomEvent("callCreated"));
      },

      onCallReceived: () => {
        debugLog(this.config?.debug || false, "Incoming call received");

        this.currentCall = {
          id: Date.now().toString(),
          remoteIdentity: "unknown",
          displayName: "Incoming Call",
          state: "incoming",
          duration: 0,
        };

        this.dispatchEvent(
          new CustomEvent("incomingCall", {
            detail: {
              from: this.currentCall.remoteIdentity,
              displayName: this.currentCall.displayName,
              callInfo: this.currentCall,
            },
          })
        );
      },

      onCallAnswered: () => {
        if (this.currentCall) {
          this.currentCall.state = "connected";
          this.currentCall.startTime = new Date();
        }

        debugLog(this.config?.debug || false, "Call answered");
        this.dispatchEvent(
          new CustomEvent("callAnswered", {
            detail: { callInfo: this.currentCall },
          })
        );

        this.startCallTimer();
      },

      onCallHangup: () => {
        debugLog(this.config?.debug || false, "Call ended");

        if (this.currentCall) {
          this.currentCall.state = "ended";
        }

        this.stopCallTimer();
        this.dispatchEvent(
          new CustomEvent("callEnded", {
            detail: { callInfo: this.currentCall },
          })
        );

        this.currentCall = null;
      },

      onCallHold: (held: boolean) => {
        debugLog(this.config?.debug || false, "Call hold state changed", held);
        this.dispatchEvent(
          new CustomEvent("callHold", {
            detail: { held, callInfo: this.currentCall },
          })
        );
      },

      onRegistered: () => {
        this.isRegistered = true;
        debugLog(this.config?.debug || false, "Registration successful");
        this.dispatchEvent(new CustomEvent("registered", { detail: { registered: true } }));
      },

      onUnregistered: () => {
        this.isRegistered = false;
        debugLog(this.config?.debug || false, "Unregistered");
        this.dispatchEvent(new CustomEvent("registered", { detail: { registered: false } }));
      },

      onServerConnect: () => {
        this.isConnected = true;
        debugLog(this.config?.debug || false, "Server connected");
        this.dispatchEvent(new CustomEvent("connected"));
      },

      onServerDisconnect: () => {
        this.isConnected = false;
        this.isRegistered = false;
        debugLog(this.config?.debug || false, "Server disconnected");
        this.dispatchEvent(new CustomEvent("disconnected"));
      },
    };
  }

  private callTimer: number | null = null;

  private startCallTimer(): void {
    this.stopCallTimer();
    this.callTimer = window.setInterval(() => {
      if (this.currentCall && this.currentCall.startTime) {
        this.currentCall.duration = Math.floor((Date.now() - this.currentCall.startTime.getTime()) / 1000);
        this.dispatchEvent(
          new CustomEvent("callTimer", {
            detail: { duration: this.currentCall.duration, callInfo: this.currentCall },
          })
        );
      }
    }, 1000);
  }

  private stopCallTimer(): void {
    if (this.callTimer) {
      clearInterval(this.callTimer);
      this.callTimer = null;
    }
  }

  private startConnectionMonitoring(): void {
    this.connectionTimer = window.setInterval(() => {
      const connected = this.simpleUser?.isConnected() || false;

      if (connected !== this.isConnected) {
        this.isConnected = connected;
        this.dispatchEvent(
          new CustomEvent("heartbeat", {
            detail: {
              connected,
              registered: this.isRegistered,
            },
          })
        );
      }
    }, 5000);
  }

  // All public methods now ensure SIP client is initialized before use
  /**
   * Make a call to the specified target
   * @param target The SIP address or extension to call
   * @param includeVideo Whether to include video in the call
   */
  async makeCall(target: string, includeVideo = false): Promise<void> {
    await this.ensureSipClient();

    if (!this.simpleUser || !this.isRegistered) {
      throw new Error("SIP client not registered");
    }

    if (this.currentCall) {
      throw new Error("Another call is already in progress");
    }

    try {
      const targetUri = `sip:${target}@${this.config!.domain}`;
      debugLog(this.config?.debug || false, "Making call to", targetUri, "with video:", includeVideo);

      // Setup video if requested
      if (includeVideo && !this.videoEnabled) {
        await this.enableVideo();
      }

      this.currentCall = {
        id: Date.now().toString(),
        remoteIdentity: target,
        displayName: target,
        state: "outgoing",
        duration: 0,
      };

      // Call with video constraints
      const callOptions = {
        sessionDescriptionHandlerOptions: {
          constraints: {
            audio: true,
            video: includeVideo || this.videoEnabled
          }
        }
      };

      await this.simpleUser.call(targetUri, callOptions);

      this.dispatchEvent(
        new CustomEvent("callStarted", {
          detail: { 
            target, 
            callInfo: this.currentCall,
            videoEnabled: includeVideo || this.videoEnabled
          },
        })
      );
    } catch (error) {
      errorLog("Call failed", error);
      this.currentCall = null;
      this.dispatchEvent(
        new CustomEvent("callFailed", {
          detail: {
            error: error instanceof Error ? error.message : "Call failed",
            target,
          },
        })
      );
      throw error;
    }
  }

  async answerCall(): Promise<void> {
    await this.ensureSipClient();

    if (!this.simpleUser) {
      throw new Error("SIP client not available");
    }

    try {
      await this.simpleUser.answer();
      debugLog(this.config?.debug || false, "Call answered");
    } catch (error) {
      errorLog("Answer call failed", error);
      throw error;
    }
  }

  async rejectCall(): Promise<void> {
    await this.ensureSipClient();

    if (!this.simpleUser) {
      throw new Error("SIP client not available");
    }

    try {
      await this.simpleUser.decline();

      if (this.currentCall) {
        this.currentCall.state = "ended";
      }

      this.currentCall = null;
      debugLog(this.config?.debug || false, "Call rejected");
    } catch (error) {
      errorLog("Reject call failed", error);
      throw error;
    }
  }

  async hangup(): Promise<void> {
    if (!this.simpleUser) return;

    try {
      await this.simpleUser.hangup();
      debugLog(this.config?.debug || false, "Call hung up");
    } catch (error) {
      errorLog("Hangup failed", error);
      throw error;
    }
  }

  async hold(): Promise<void> {
    if (!this.simpleUser) return;

    try {
      await this.simpleUser.hold();
      debugLog(this.config?.debug || false, "Call put on hold");
    } catch (error) {
      errorLog("Hold failed", error);
      throw error;
    }
  }

  async unhold(): Promise<void> {
    if (!this.simpleUser) return;

    try {
      await this.simpleUser.unhold();
      debugLog(this.config?.debug || false, "Call removed from hold");
    } catch (error) {
      errorLog("Unhold failed", error);
      throw error;
    }
  }

  async mute(): Promise<void> {
    if (!this.simpleUser) return;

    try {
      await this.simpleUser.mute();
      debugLog(this.config?.debug || false, "Call muted");
    } catch (error) {
      errorLog("Mute failed", error);
      throw error;
    }
  }

  async unmute(): Promise<void> {
    if (!this.simpleUser) return;

    try {
      await this.simpleUser.unmute();
      debugLog(this.config?.debug || false, "Call unmuted");
    } catch (error) {
      errorLog("Unmute failed", error);
      throw error;
    }
  }

  sendDTMF(tone: string): void {
    if (!this.simpleUser || !this.currentCall) return;

    try {
      if (typeof this.simpleUser.sendDTMF === "function") {
        this.simpleUser.sendDTMF(tone);
        debugLog(this.config?.debug || false, "DTMF sent", tone);

        this.dispatchEvent(
          new CustomEvent("dtmfSent", {
            detail: { tone, callInfo: this.currentCall },
          })
        );
      }
    } catch (error) {
      errorLog("DTMF send failed", error);
    }
  }

  getRemoteVideo(): HTMLVideoElement | null {
    return null;
  }

  getRemoteAudio(): HTMLAudioElement | null {
    return this.remoteAudio;
  }

  getCurrentCall(): CallInfo | null {
    return this.currentCall;
  }

  getConnectionStatus(): { connected: boolean; registered: boolean; initialized: boolean } {
    return {
      connected: this.isConnected,
      registered: this.isRegistered,
      initialized: this.isInitialized,
    };
  }

  /**
   * Force initialization (useful for manual connection)
   */
  async connect(): Promise<void> {
    await this.ensureSipClient();
  }

  async disconnect(): Promise<void> {
    if (this.connectionTimer) {
      clearInterval(this.connectionTimer);
      this.connectionTimer = null;
    }

    this.stopCallTimer();

    if (this.simpleUser) {
      try {
        if (this.currentCall) {
          await this.hangup();
        }

        if (this.isRegistered) {
          await this.simpleUser.unregister();
        }

        if (this.isConnected) {
          await this.simpleUser.disconnect();
        }
      } catch (error) {
        errorLog("Disconnect error", error);
      }

      this.simpleUser = null;
    }

    // Cleanup video resources
    try {
      if (this.localStream) {
        this.localStream.getTracks().forEach(track => track.stop());
        this.localStream = null;
      }

      if (this.localVideo) {
        if (this.localVideo.parentNode) {
          this.localVideo.pause();
          this.localVideo.srcObject = null;
          this.localVideo.parentNode.removeChild(this.localVideo);
        }
        this.localVideo = null;
      }

      this.videoEnabled = false;
    } catch (error) {
      errorLog("Error cleaning up video resources:", error);
    }

    this.isConnected = false;
    this.isRegistered = false;
    this.isInitialized = false;
    this.isInitializing = false;
    this.currentCall = null;

    // Cleanup audio element
    if (this.remoteAudio) {
      if (this.remoteAudio.parentNode) {
        this.remoteAudio.pause();
        this.remoteAudio.srcObject = null;
        this.remoteAudio.parentNode.removeChild(this.remoteAudio);
      }
      this.remoteAudio = null;
    }

    debugLog(this.config?.debug || false, "SIP client disconnected");
  }
}

---

